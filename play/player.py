#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/8# @Author : cyq# @File : player# @Software: PyCharm# @Desc:import asyncioimport jsonimport osfrom typing import List, Dict, Sequencefrom playwright.async_api import Page, LocatorAssertions, BrowserContextfrom playwright._impl._errors import TimeoutError, TargetClosedErrorfrom app.exception import UIRuntimeErrorfrom app.mapper.interface import InterfaceMapperfrom app.mapper.play import PlayCaseMapper, PlayCaseResultMapper, PlayStepMapper, PlayCaseVariablesMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.model.interface import InterfaceModelfrom app.model.playUI import PlayCaseResult, PlayCase, PlayStepfrom interface.runner import InterFaceRunnerfrom play.browser import get_browser_contextfrom play.methods import CustomizeMethod, new_pagefrom play.exception import APIAssertExceptionfrom play._exec.execCondition import ExecConditionfrom utils import log, GenerateToolsfrom utils.execDBScript import ExecDBScriptfrom play.writer import Writerfrom play.starter import UIStarterfrom config import Configfrom utils.variableTrans import VariableTransclass Player:    """    UIè‡ªåŠ¨åŒ– å¤„ç†ä¸æ‰§è¡Œ    """    page: Page    browser_context: BrowserContext    def __init__(self, starter: UIStarter):        self._starter = starter        self._api_runner = InterFaceRunner(starter)        self._var = VariableTrans()        self._condition = ExecCondition(self._var)    async def run_case(self, caseId: int):        """        æ ¹æ®ç”¨ä¾‹IDæŸ¥è¯¢ç”¨ä¾‹å¹¶å‡†å¤‡æ‰§è¡Œã€‚        :param caseId: éœ€è¦æ‰§è¡Œçš„ç”¨ä¾‹IDï¼Œç±»å‹ä¸ºintã€‚        :return: æ— è¿”å›å€¼ã€‚        """        # é€šè¿‡ç”¨ä¾‹IDè·å–ç”¨ä¾‹ä¿¡æ¯        play_case = await PlayCaseMapper.get_by_id(caseId)        await self._starter.send(f"å‡†å¤‡æ‰§è¡Œç”¨ä¾‹ :{play_case}")        # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœï¼Œ        init_case_result: PlayCaseResult = await PlayCaseResultMapper.init_case_result(play_case=play_case,                                                                                       user=self._starter)        # æ‰§è¡Œç”¨ä¾‹        await self.execute_case(play_case=play_case, play_case_result=init_case_result)    async def execute_case(self,                           play_case: PlayCase,                           play_case_result: PlayCaseResult) -> bool:        """        case æ‰§è¡Œ        :param play_case: å¾…æ‰§è¡Œç”¨ä¾‹        :param play_case_result: åˆå§‹åŒ–çš„ç”¨ä¾‹ç»“æœæ¨¡å‹        :return:        """        error_info = {}        success_flag = True        try:            # æ‰§è¡Œå‡†å¤‡            play_steps: Sequence[PlayStep] = await PlayStepMapper.query_steps_by_caseId(play_case.id)            await self._starter.send(f"è·å–ç”¨ä¾‹æ­¥éª¤é•¿åº¦ :{len(play_steps)}")            if not play_steps:                await self._starter.send(f"æ— ç”¨ä¾‹æ­¥éª¤âš ï¸ è¿è¡Œç»“æŸ")                await Writer.write_case_result(case_result=play_case_result,                                               starter=self._starter)                return success_flag            # åˆå§‹åŒ–å˜é‡            await self.init_case_variables(play_case, play_case_result)            # åˆå§‹åŒ–play            try:                await self.init_play()            except Exception as e:                success_flag = False                error_info = {                    "ui_case_err_step": -1,                    "ui_case_err_step_title": "-",                    "ui_case_err_step_msg": f"Service Error {str(e)}"                }                return success_flag            # æ­¥éª¤æ‰§è¡Œ            for i, step in enumerate(play_steps, start=1):                try:                    await self._starter.send(f'æ‰§è¡Œæ­¥éª¤ >> step[{i}] : {step} \n')                    if step.is_group:                        # æ‰§è¡Œç»„                        await self.execute_group_step(step, play_case_result)                    else:                        # å•æ­¥éª¤æ¡ä»¶æ‰§è¡Œ                        await self.condition_execute(step, play_case_result)                except Exception as e:                    log.exception(e)                    await self._starter.send(f"æ­¥éª¤ \"{step}\" æ‰§è¡Œå¤±è´¥ >> \"{e}\"")                    # is_ignore true å¿½ç•¥æœ¬æ¬¡å¤±è´¥ ã€ç»§ç»­                    if step.is_ignore:                        await self._starter.send('step is ignore, continue...')                        continue                    success_flag = False                    error_info = await self.format_error_info(i, step, e)                    log.error(f"æ­¥éª¤æ‰§è¡Œå¤±è´¥ >> {step} : {error_info}")                    # é¡µé¢å…³é—­ã€ æ¥å£è¯·æ±‚å¤±è´¥ ã€ä¸æˆªå›¾                    if not isinstance(e, (TargetClosedError, APIAssertException)):                        errorPath = await self.to_screenshot()                        error_info['ui_case_err_step_pic_path'] = errorPath        finally:            # æœ€ç»ˆå°è¯• æ¸…ç©ºèµ„æº            await self._starter.send(f'æ‰§è¡Œå®Œæˆ >> {play_case}, ç»“æœ: {success_flag}')            await Writer.write_case_result(play_case_result, self._starter, error_info)            await self._starter.over(play_case_result.uid)            await self.cleanup_resources()            return success_flag    async def __execute_condition_sub(self, step: PlayStep):        """        æ¡ä»¶æ‰§è¡Œ        """        # æ¡ä»¶åˆ¤æ–­        flag = await self._condition.invoke(step, self._starter)        if flag:            subSteps: List[PlayStep] = await PlayStepMapper.query_condition(step.id)            if len(subSteps) > 0:                for subStep in subSteps:                    await self._starter.send(f'æ‰§è¡Œå­æ­¥éª¤ >> {subStep}'),                    await self.__execute_step(subStep)            else:                await self._starter.send("æ— å­æ­¥éª¤ ...")        else:            await self._starter.send(f'æ¡ä»¶æ‰§è¡Œå¤±è´¥ >> {step.condition}')    async def condition_execute(self, play_step: PlayStep, case_result: PlayCaseResult):        """        æ ¹æ®æ¡ä»¶æ‰§è¡Œæµ‹è¯•æ­¥éª¤ã€‚æ­¤å‡½æ•°è´Ÿè´£æ ¹æ®æä¾›çš„æ­¥éª¤æ¨¡å‹å’Œæµ‹è¯•ç»“æœæ¨¡å‹ï¼Œæ‰§è¡Œç›¸å…³çš„APIæˆ–SQLå‰ç½®å’Œåç½®åŠ¨ä½œï¼Œ        å¹¶æ ¹æ®æ­¥éª¤ç±»å‹æ‰§è¡Œå•ä¸ªæ­¥éª¤æˆ–æ­¥éª¤ç»„ã€‚        :param play_step: UICaseStepsModelç±»å‹çš„å®ä¾‹ï¼Œä»£è¡¨å½“å‰è¦æ‰§è¡Œçš„æµ‹è¯•æ­¥éª¤ã€‚        :param case_result: UIResultModelç±»å‹çš„å®ä¾‹ï¼Œç”¨äºå­˜å‚¨æµ‹è¯•ç»“æœã€‚        :return: æ— è¿”å›å€¼ã€‚å¦‚æœåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ°å¼‚å¸¸ï¼Œå°†æŠ›å‡ºå¼‚å¸¸ã€‚        """        try:            async def execute_actions(is_pre: int):                """                å‰åç½®æ‰§è¡Œ                """                if play_step.interface_a_or_b == is_pre and play_step.interface_id:                    step_api = await InterfaceMapper.get_by_id(ident=play_step.interface_id)                    await self.__execute_api(step_api, play_step, case_result)                if play_step.db_id and play_step.db_a_or_b == is_pre:                    await self.__execute_sql(play_step, case_result)            # æ‰§è¡Œ            if play_step.interface_id or play_step.db_id:                await execute_actions(is_pre=1)                await self.__execute_step(play_step, case_result)                await execute_actions(is_pre=0)            else:                await self.__execute_step(play_step, case_result)            # å­æ­¥éª¤ åˆ¤æ–­æ‰§è¡Œ            if play_step.condition:                await self.__execute_condition_sub(play_step)        except Exception as e:            raise    async def __execute_sql(self, playStep: PlayStep, case_result: PlayCaseResult):        """        oracle æ‰§è¡Œ        :param playStep:        :return:        """        title = "å‰ç½®" if playStep.db_a_or_b else "åç½®"        _db = await DbConfigMapper.get_by_id(playStep.db_id)        script = await self._var.trans(playStep.sql_script)        await self._starter.send(f'æ‰§è¡Œ{title}SQL >> {script}')        db_script = ExecDBScript(self._starter, script)        _vars = await db_script.invoke(_db.db_type, **_db.config)        if _vars:            await self._starter.send(f"SQL æå–å˜é‡ >> {_vars}")            await self._var.add_vars(_vars)            await Writer.write_vars_info(case_result=case_result,                                         extract_method="SQLæå–",                                         step_name=playStep.name,                                         varsInfo=_vars)        return    async def __execute_api(self,                            stepApi: InterfaceModel,                            step: PlayStep,                            case_result: PlayCaseResult):        """        æ‰§è¡Œå‰åç½®APIè°ƒç”¨        ç›®å‰çœ‹ åªç”¨äºè°ƒç”¨è·å¾—å˜é‡æˆ–ç€ä½¿ç”¨ã€‚ä¸æ–­è¨€ç»ˆæ­¢        :param stepApi: æ­¥éª¤API        :param step: UIæ­¥éª¤        :param case_result: ç”¨ä¾‹ç»“æœå¯¹è±¡å†™å…¥        :return:        """        title = "å‰ç½®" if step.interface_a_or_b else "åç½®"        await self._starter.send(f'æ‰§è¡Œ{title}æ¥å£ >> {stepApi}')        result_info, flag = await self._api_runner.execute_interface_by_ui(stepApi, self._var())        # å¤„ç†æå–å˜é‡        if extracts := result_info.get('extracts', []):            _ex = GenerateTools.list2dict(extracts)            await self._starter.send(f"æ¥å£æå–å˜é‡ >> {_ex}")            await self._var.add_vars(_ex)            await Writer.write_vars_info(case_result=case_result,                                         extract_method="APIæ‰§è¡Œ",                                         step_name=step.name,                                         varsInfo=_ex)        # å¦‚æœæœ‰æ–­è¨€å†™å…¥æ–­è¨€        # å¤„ç†æ–­è¨€        if asserts := result_info.get("asserts", []):            await Writer.write_assert_info(case_result=case_result, assertsInfo=asserts)        # å¦‚æœæ¥å£æ–­è¨€å¤±è´¥äº†åˆ‡ä¸è·³è¿‡ æŠ›å‡ºå¼‚å¸¸        if not flag and step.interface_fail_stop == 1:            await self._starter.send(f"æ¥å£æ‰§è¡Œå¤±è´¥ >> {stepApi}")            await self._starter.over(reportId=case_result.id)            raise APIAssertException()    async def execute_group_step(self, step: PlayStep, case_result: PlayCaseResult):        """        æ­¥éª¤ç»„æ‰§è¡Œ        :param step:        :return:        """        g_steps = await PlayStepMapper.query_steps_by_groupId(groupId=step.id)        log.error(f"æ­¥éª¤ç»„ >> {g_steps}")        if g_steps:            await self._starter.send(f"===== å¼€å§‹æ‰§è¡Œæ­¥éª¤ç»„ {step.name}")            for i, step in enumerate(g_steps, start=1):                log.info(f"æ­¥éª¤ç»„ >> {g_steps}")                await self.condition_execute(step, case_result)            await self._starter.send(f"===== {step.name} æ‰§è¡Œæ­¥éª¤ç»„ç»“æŸ")        else:            await self._starter.send(f"æ­¥éª¤ç»„ >> {step.name} æ­¥éª¤ç»„ä¸ºç©º")    async def __execute_step(self,                             play_step: PlayStep,                             play_case_result: PlayCaseResult = None):        """        æ‰§è¡Œå•æ­¥éª¤        :param play_step: PlayStep        :param play_case_result: PlayCaseResult        :return: None        """        log.info(f"æ‰§è¡Œæ­¥éª¤ >> {play_step}")        # æ‰“å¼€æ–°é¡µé¢ç‰¹æ®Šå¤„ç†        if play_step.new_page:            self.page = await new_page(page=self.page, play_step=play_step, starter=self._starter, vt=self._var)            return        # å…¶ä»–è‡ªå®šä¹‰æ­¥éª¤        else:            await CustomizeMethod.play(                page=self.page,                play_step=play_step,                starter=self._starter,                vt=self._var,                play_result=play_case_result            )            return    async def init_play(self):        """        åˆå§‹åŒ–playwright        æŒ‡å®š            headless True            slow_mo 1s            devè¶…æ—¶5s            proè¶…æ—¶10s        :return:        """        try:            self.browser_context = await get_browser_context()            self.page = await self.browser_context.new_page()            log.info(f"åˆå§‹åŒ–æµè§ˆå™¨æˆåŠŸ {self.browser_context} {self.page}")        except Exception as e:            log.exception(e)            raise UIRuntimeError("åˆå§‹åŒ–æµè§ˆå™¨å¤±è´¥")    async def init_case_variables(self, play_case: PlayCase, case_result: PlayCaseResult):        """        åˆå§‹åŒ–å˜é‡        :param play_case: UICaseModel        :return:        """        try:            if variables := await PlayCaseVariablesMapper.query_by(play_case_id=play_case.id):                for case_var in variables:                    _v = await self._var.trans(case_var.value)                    await self._var.add_vars({case_var.key: _v})                await Writer.write_vars_info(case_result=case_result, extract_method="INIT", step_name="INIT",                                             varsInfo=self._var())                await self._starter.send(f"ğŸ«³ğŸ«³ åˆå§‹åŒ–ç”¨ä¾‹å˜é‡ = {json.dumps(self._var(), ensure_ascii=False)}")        except Exception as e:            log.exception(e)            raise e    async def to_screenshot(self):        """        æˆªå›¾        :return:        """        try:            fileDate = GenerateTools.getTime(2)            fileName = f"{GenerateTools.uid()}.jpeg"            path = os.path.join(Config.ROOT, "play", "play_error_shot", fileDate, fileName)            await self.page.screenshot(                path=str(path),                full_page=True)            await self._starter.send("å®Œæˆå¤±è´¥æˆªå›¾âœ…")            return path        except Exception as e:            log.error(e)            await self._starter.send(f"æˆªå›¾å¤±è´¥âŒ {str(e)}")    @staticmethod    async def format_error_info(step_index: int, step: PlayStep,                                e: Exception) -> Dict[str, str]:        """        æ ¼å¼åŒ–é”™è¯¯æ‰§è¡Œä¿¡æ¯        :param step_index: æ­¥éª¤ç´¢å¼•        :param step: PlayStep        :param e:Exception        :return:        """        error_info = {            "ui_case_err_step": step_index,            "ui_case_err_step_title": step.name,            "ui_case_err_step_msg": str(e)        }        if isinstance(e, LocatorAssertions):            msg = str(e).split("Call log:")[0]            error_info[                "ui_case_err_step_msg"] = f"{e.__class__.__name__}âŒ: {msg} << "        elif isinstance(e, TimeoutError):            error_info[                "ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: Timeout waiting for locator \n"                                           f">> '{step.locator}' << ")        elif isinstance(e, AssertionError):            msg = str(e).split("Call log:")[0]            error_info["ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: method >> '{step.method}' << \n"                                                  f"{msg}")        elif isinstance(e, TargetClosedError):            error_info["ui_case_err_step_msg"] = f"ğŸš€ {e.__class__.__name__}âŒ: {str(e)}"        return error_info    async def cleanup_resources(self):        """Centralized resource cleanup"""        if self.browser_context:            await self.browser_context.close()            log.info("browser_context page success")        await asyncio.gather(            self._var.clear(),            self._starter.clear_logs(),            return_exceptions=True        )