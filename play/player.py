#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/8# @Author : cyq# @File : player# @Software: PyCharm# @Desc:import asyncioimport osfrom typing import List, Dict, Anyfrom playwright.async_api import Page, LocatorAssertionsfrom playwright._impl._errors import TimeoutError, TargetClosedErrorfrom app.exception import UIRuntimeErrorfrom app.mapper.ui.uiCaseMapper import UICaseStepApiMapper, UICaseStepSQLMapperfrom app.mapper.ui.uiCaseStepGroupMapper import UICaseStepGroupMapperfrom app.mapper.ui.uiCaseVariableMapper import UICaseVariableMapperfrom app.mapper.ui.uiEnvMapper import UIEnvMapperfrom app.mapper.ui.uiSubStepMapper import SubStepMapperfrom app.model.base import Userfrom app.model.ui import UICaseModel, UICaseStepsModel, UICaseTaskResultBaseModel, UIResultModel, \    UIStepAPIModel, UIEnvModel, UIStepSQLModel, UITaskModelfrom enums.CaseEnum import Statusfrom app.mapper.ui.uiCaseMapper import UICaseMapperfrom app.mapper.ui.uiTaskMapper import UITaskMapperfrom play.execCondition import ExecConditionfrom play.methods.api_on import APIOnfrom play.browser_content import get_browser_context, BrowserContextSingletonfrom play.methods.customize_method import CustomizeMethodsfrom play.exception import PlayAssertException, APIAssertExceptionfrom play.apiSender import APISenderfrom play.methods.expect_method import ExpectMethodfrom play.methods.keyboard_methods import KeyboardMethodsfrom play.methods.page_methods import PageMethodsfrom play.sqlSender import SqlSenderfrom utils import log, GenerateToolsfrom utils.io_sender import SocketSenderfrom utils.wrapper_ import lockfrom utils.report import Reportfrom play.methods.customize_method import CustomizeMethodfrom play.writer import Writerfrom play.logWriter import LogWriterfrom play.extract import ExtractManagerfrom config import Configimport jenkinsdef getAssertErrorMsg(e) -> str:    if isinstance(e, (AssertionError, LocatorAssertions)):        return ",".join(str(e).split("Call log:")[:1])async def format_error_info(step_index: int, step: UICaseStepsModel,                            e: Exception) -> Dict[str, str]:    """    æ ¼å¼åŒ–é”™è¯¯æ‰§è¡Œä¿¡æ¯    :param step_index: æ­¥éª¤ç´¢å¼•    :param step: UICaseStepsModel    :param e:Exception    :return:    """    error_info = {        "ui_case_err_step": step_index,        "ui_case_err_step_title": step.name,        "ui_case_err_step_msg": str(e)    }    if isinstance(e, LocatorAssertions):        msg = getAssertErrorMsg(e)        error_info[            "ui_case_err_step_msg"] = f"{e.__class__.__name__}âŒ: {msg} << "    elif isinstance(e, TimeoutError):        error_info[            "ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: Timeout waiting for locator \n"                                       f">> '{step.locator}' << ")    elif isinstance(e, PlayAssertException):        msg = getAssertErrorMsg(e)        error_info["ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: method >> '{step.method}' << \n"                                              f"{msg}")    elif isinstance(e, APIAssertException):        error_info["ui_case_err_step_msg"] = f"ğŸš€ {e.__class__.__name__}âŒ: {str(e)}"    elif isinstance(e, TargetClosedError):        error_info["ui_case_err_step_msg"] = f"ğŸš€ {e.__class__.__name__}âŒ: {str(e)}"    return error_infoasync def run_Tasks(taskIds: List[int], userId: int, jobName: str = None):    """    run for jenkins    :param taskIds:    :param userId:    :param jobName:    :return:    """    try:        tasks = [Player().run_task(task, userId) for task in taskIds]        await asyncio.gather(*tasks)    except Exception as e:        log.error(e)    finally:        if jobName:            log.info(f'=========={jobName}')            server = jenkins.Jenkins(url=Config.JENKINS_URL,                                     username=Config.JENKINS_USERNAME,                                     password=Config.JENKINS_PASSWORD)            log.info(f'build=========={jobName}')            server.build_job(jobName)class TaskChecker:    @staticmethod    async def check_cases(task: UITaskModel) -> List[UICaseModel]:        """        æ£€æŸ¥ç”¨ä¾‹        :param task:        :return:        """        task_cases: List[UICaseModel] = await UITaskMapper.query_cases_by_task_id(task.id)        # æ— å¾…æ‰§è¡Œç”¨ä¾‹ï¼Œç»“æŸ        number_of_pending_use_cases = len(task_cases)        if number_of_pending_use_cases == 0:            log.error(f'æ— å¾…æ‰§è¡Œç”¨ä¾‹ï¼Œç»“æŸã€‚')            raise UIRuntimeError("æ— å¾…æ‰§è¡Œç”¨ä¾‹ï¼Œç»“æŸã€‚")        return task_casesclass Player:    """    UIè‡ªåŠ¨åŒ– å¤„ç†ä¸æ‰§è¡Œ    """    io: SocketSender = None    page: Page    browser_context: BrowserContextSingleton    logger: LogWriter    em: ExtractManager    api: APISender    sql: SqlSender    env: UIEnvModel    def __init__(self, starter: User):        self.io = SocketSender(starter)    @lock("UI_TASK")    async def run_task(self, taskId: int, userId: int = None):        """        æ‰§è¡Œui TASK        :param taskId å¾…è¿è¡ŒTASK ID        :param userId æ‰§è¡Œäºº ID        """        # æŸ¥è¯¢ä»»åŠ¡        task = await UITaskMapper.get_by_id(taskId)        self.logger.taskId = task.uid        await self.io.send(f'æ‰§è¡Œui TASK:{task}')        # æŸ¥è¯¢ä»»åŠ¡ç”¨ä¾‹        task_cases: List[UICaseModel] = await TaskChecker.check_cases(task)        # æ›´æ–°ä»»åŠ¡çŠ¶æ€        await Writer.write_task_status(task, Status.RUNNING)        task_result = await Writer.init_task_base_result(            totalNumber=len(task_cases),            task=task,            userId=userId        )        # æ‰§è¡Œç”¨ä¾‹        await self.retry_case(task.retry, task_cases, userId, task_result)        await self.io.send(f'ui TASK:{task} æ‰§è¡Œå®Œæˆ')        # å†™å…¥ç»“æœ        try:            await Writer.write_base_result(task_result)        except Exception as e:            log.exception(e)            raise e        finally:            await Writer.write_task_status(task, Status.WAIT)            if task.isSend:                await Report().ui2weChat(task, task_result)    async def retry_case(self, retryNum: int, task_cases: List[UICaseModel], userId, task_result):        """        ä»»åŠ¡ ç”¨ä¾‹é‡è¯•æ‰§è¡Œæœºåˆ¶æ‰§è¡Œ        :param retryNum: é‡è¯•æ¬¡æ•°        :param task_cases: ä»»åŠ¡ç”¨ä¾‹        :param userId: æ‰§è¡Œäºº        :param task_result: åˆå§‹åŒ–çš„ä»»åŠ¡ç»“æœæ¨¡å‹        :return:        """        # éå†æ¯ä¸ªä»»åŠ¡ç”¨ä¾‹        for case in task_cases:            # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœ            init_case_result = await Writer.init_case_result(case, userId, task_result.id)            # è®¾ç½®æ—¥å¿—çš„ç”¨ä¾‹ID            self.logger.caseId = case.uid            try:                # æ‰§è¡Œç”¨ä¾‹ï¼Œå…è®¸é‡è¯•çš„æ¬¡æ•°ä¸º retryNum + 1                for i in range(retryNum + 1):                    # å‘é€å½“å‰ç”¨ä¾‹æ‰§è¡Œçš„ä¿¡æ¯å’Œæ¬¡æ•°                    await self.io.send(f'æ‰§è¡Œui case :{case} æ¬¡æ•°:{i}')                    # å¦‚æœé‡è¯•æ¬¡æ•°ä¸º0 æˆ–è€…æ˜¯æœ€ç»ˆæ‰§è¡Œ å¤±è´¥æ‰è¿›è¡Œæˆªå›¾å¤„ç†                    retry = retryNum == 0 or i == retryNum                    try:                        # æ‰§è¡Œç”¨ä¾‹å¹¶è·å–ç»“æœ                        flag = await self.__execute_case(case, init_case_result, task_result, retry)                    except Exception as e:                        # ç”¨ä¾‹æ‰§è¡Œå¤±è´¥ï¼Œå‘é€é”™è¯¯ä¿¡æ¯                        await self.io.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯: {str(e)}')                        # å¦‚æœå·²ç»è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå¢åŠ å¤±è´¥è®¡æ•°å¹¶æ¸…é™¤æ—¥å¿—ï¼Œç„¶åè·³å‡ºå¾ªç¯                        if i == retryNum:                            task_result.failNumber += 1                            await self.io.clear_logs()                            break                        # å¦åˆ™ï¼Œè¿›è¡Œé‡è¯•                        await self.io.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  è¿›è¡Œ{i + 1}é‡è¯•')                        continue                    # å¦‚æœç”¨ä¾‹æ‰§è¡ŒæˆåŠŸï¼Œä½†æœªé€šè¿‡ï¼ˆflagä¸ºFalseï¼‰                    if not flag:                        # å¦‚æœå·²ç»è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå‘é€å¤±è´¥ä¿¡æ¯ï¼Œå¢åŠ å¤±è´¥è®¡æ•°å¹¶æ¸…é™¤æ—¥å¿—ï¼Œç„¶åè·³å‡ºå¾ªç¯                        if i == retryNum:                            await self.io.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  é‡è¯•æ¬¡æ•°å·²ç”¨å®Œ')                            task_result.failNumber += 1                            await self.io.clear_logs()                            break                        # å¦åˆ™ï¼Œè¿›è¡Œé‡è¯•                        await self.io.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  è¿›è¡Œ{i + 1}é‡è¯•')                        continue                    else:                        # ç”¨ä¾‹æ‰§è¡ŒæˆåŠŸï¼Œå¢åŠ æˆåŠŸè®¡æ•°ï¼Œæ¸…é™¤è¯æ®å’Œæ—¥å¿—ï¼Œç„¶åè·³å‡ºå¾ªç¯                        task_result.successNumber += 1                        await self.em.clear()                        await self.io.clear_logs()                        break            finally:                # åœæ­¢å½“å‰ç”¨ä¾‹çš„æ‰§è¡Œ                await self.play.stop()    async def run_case(self, caseId: int):        """        æ ¹æ®ç”¨ä¾‹IDæŸ¥è¯¢ç”¨ä¾‹å¹¶å‡†å¤‡æ‰§è¡Œã€‚        è¯¥å‡½æ•°æ˜¯å¼‚æ­¥çš„ï¼Œå› ä¸ºå®ƒéœ€è¦ç­‰å¾…æŸäº›æ“ä½œå®Œæˆï¼Œæ¯”å¦‚ä»æ•°æ®åº“è·å–ç”¨ä¾‹ä¿¡æ¯æˆ–ä¸UIäº¤äº’ã€‚        :param caseId: éœ€è¦æ‰§è¡Œçš„ç”¨ä¾‹IDï¼Œç±»å‹ä¸ºintã€‚        :return: æ— è¿”å›å€¼ã€‚        """        # é€šè¿‡ç”¨ä¾‹IDè·å–ç”¨ä¾‹ä¿¡æ¯        case = await UICaseMapper.get_by_id(caseId)        # è®¾ç½®å½“å‰ç”¨ä¾‹çš„å‰ç¼€ï¼Œè¿™å¯èƒ½æ˜¯ä¸ºäº†åœ¨UIæˆ–å…¶ä»–åœ°æ–¹æ ‡è¯†å½“å‰ç”¨ä¾‹        await self.io.setCasePrefix(case.uid)        await self.io.send(f"å‡†å¤‡æ‰§è¡Œç”¨ä¾‹ :{case}")        # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœï¼Œ        init_case_result = await Writer.init_case_result(case=case, user=self.io.user)        # æ‰§è¡Œç”¨ä¾‹ï¼Œè¿™æ˜¯ç”¨ä¾‹è¿è¡Œçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œå¯èƒ½åŒ…æ‹¬ä¸€ç³»åˆ—æ“ä½œæ­¥éª¤çš„æ‰§è¡Œ        await self.__execute_case(case, init_case_result)        return "ok"    async def __execute_case(self,                             case: UICaseModel,                             case_result: UIResultModel,                             task_result: UICaseTaskResultBaseModel = None,                             retry: bool = True):        """        case æ‰§è¡Œ        :param case: å¾…æ‰§è¡Œç”¨ä¾‹        :param case_result: åˆå§‹åŒ–çš„ç”¨ä¾‹ç»“æœæ¨¡å‹        :param task_result: åˆå§‹åŒ–çš„æ‰¹é‡æ‰§è¡Œç»“æœæ¨¡å‹        :param retry: é‡è¯•é€»è¾‘        :return:        """        errorInfo = {}        _flag = True        # æ‰§è¡Œå‡†å¤‡        case_steps: List[UICaseStepsModel] = await UICaseMapper.query_steps_by_caseId(case.id)        await self.io.send(f"è·å–ç”¨ä¾‹æ­¥éª¤ :{len(case_steps)}")        if len(case_steps) == 0:            await self.io.send(f"æ— ç”¨ä¾‹æ­¥éª¤âš ï¸ è¿è¡Œç»“æŸ")            await Writer.write_case_result(case_result, self.io.logs)            return _flag        # åˆå§‹åŒ–å˜é‡        await self.__init_extracts(case)        # åˆå§‹åŒ–play        await self.__init_play()        # OPEN URL        env = await UIEnvMapper.get_by_id(case.env_id)        await CustomizeMethod.to_goto(self.page, env.domain,                                      self.io, self.em)        try:            # æ­¥éª¤æ‰§è¡Œ            for i, step in enumerate(case_steps, start=1):                try:                    await self.io.send(f'æ‰§è¡Œæ­¥éª¤ >> step[{i}] : {step}')                    #  æ¡ä»¶æ‰§è¡Œ                    await self.__condition_execute(step, case_result)                    # å­æ­¥éª¤ åˆ¤æ–­æ‰§è¡Œ                    await self.__execute_condition(step)                except Exception as e:                    log.exception(e)                    await self.io.send(f'some error : {str(e)}')                    await self.io.send(f"æ­¥éª¤æ‰§è¡Œå¤±è´¥ >> {step}")                    # is_ignore true å¿½ç•¥æœ¬æ¬¡å¤±è´¥ ã€ç»§ç»­                    if step.is_ignore:                        await self.io.send('step is ignore, continue...')                        continue                    _flag = False                    # æ˜¯å¦é‡è¯• ã€é‡è¯•æ¬¡æ•°ç”¨å®Œ                    if retry:                        errorInfo = await format_error_info(i, step, e)                        # é¡µé¢å…³é—­ã€ æ¥å£è¯·æ±‚å¤±è´¥ ã€ä¸æˆªå›¾                        if not isinstance(e, (TargetClosedError, APIAssertException)):                            errorPath = await self.to_screenshot()                            errorInfo['ui_case_err_step_pic_path'] = errorPath                    break        finally:            await self.io.send(f'æ‰§è¡Œå®Œæˆ >> {case},ç»“æœ:{_flag}')            return await self.run_finally(                _flag,                task_result,                case_result,                errorInfo            )    async def __execute_condition(self, step: UICaseStepsModel):        flag = await ExecCondition.invoke(step, self.io, self.em)        if flag:            subSteps = await SubStepMapper.query_by_stepId(step.id)            if len(subSteps) > 0:                await self.io.send(f'æ‰§è¡Œå­æ­¥éª¤ >> {step}')                await self.__execute_step(subSteps)            else:                await self.io.send("æ— å­æ­¥éª¤ ...")        else:            await self.io.send(f'æ¡ä»¶æ‰§è¡Œå¤±è´¥ >> {step.condition}')    async def run_finally(self, flag: bool,                          task_result: UICaseTaskResultBaseModel,                          case_result: UIResultModel,                          errorInfo):        # ç¡®ä¿æœ€ç»ˆæ‰§è¡Œå†™å…¥æ“ä½œ        try:            await Writer.write_case_result(case_result, self.io.logs, errorInfo)        except Exception as e:            log.error(e)        finally:            if task_result:                return flag            else:                pass    async def __condition_execute(self, step: UICaseStepsModel, case_result: UIResultModel):        """        æ ¹æ®æ¡ä»¶æ‰§è¡Œæµ‹è¯•æ­¥éª¤ã€‚æ­¤å‡½æ•°è´Ÿè´£æ ¹æ®æä¾›çš„æ­¥éª¤æ¨¡å‹å’Œæµ‹è¯•ç»“æœæ¨¡å‹ï¼Œæ‰§è¡Œç›¸å…³çš„APIæˆ–SQLå‰ç½®å’Œåç½®åŠ¨ä½œï¼Œ        å¹¶æ ¹æ®æ­¥éª¤ç±»å‹æ‰§è¡Œå•ä¸ªæ­¥éª¤æˆ–æ­¥éª¤ç»„ã€‚        :param step: UICaseStepsModelç±»å‹çš„å®ä¾‹ï¼Œä»£è¡¨å½“å‰è¦æ‰§è¡Œçš„æµ‹è¯•æ­¥éª¤ã€‚        :param case_result: UIResultModelç±»å‹çš„å®ä¾‹ï¼Œç”¨äºå­˜å‚¨æµ‹è¯•ç»“æœã€‚        :return: æ— è¿”å›å€¼ã€‚å¦‚æœåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ°å¼‚å¸¸ï¼Œå°†æŠ›å‡ºå¼‚å¸¸ã€‚        """        try:            # è·å–ä¸å½“å‰æ­¥éª¤å…³è”çš„APIå’ŒSQLä¿¡æ¯ï¼Œå¦‚æœå­˜åœ¨çš„è¯ã€‚            stepApi = await UICaseStepApiMapper.get_by(stepId=step.id)            stepSql = await UICaseStepSQLMapper.get_by(stepId=step.id)            async def execute_pre_actions():                """                æ‰§è¡Œå‰ç½®åŠ¨ä½œã€‚å¦‚æœæ­¥éª¤å…³è”çš„APIæˆ–SQLè¢«é…ç½®ä¸ºå‰ç½®åŠ¨ä½œï¼ˆb_or_aä¸ºTrueï¼‰ï¼Œ                åˆ™åˆ†åˆ«æ‰§è¡Œç›¸åº”çš„APIæˆ–SQLæ“ä½œã€‚                """                if stepApi and stepApi.b_or_a:                    await self.__execute_api(stepApi, step, case_result)                if stepSql and stepSql.b_or_a:                    await self.__execute_sql(stepSql)            async def execute_post_actions():                """                æ‰§è¡Œåç½®åŠ¨ä½œã€‚å¦‚æœæ­¥éª¤å…³è”çš„APIæˆ–SQLè¢«é…ç½®ä¸ºåç½®åŠ¨ä½œï¼ˆb_or_aä¸ºFalseï¼‰ï¼Œ                åˆ™åˆ†åˆ«æ‰§è¡Œç›¸åº”çš„APIæˆ–SQLæ“ä½œã€‚                """                if stepApi and not stepApi.b_or_a:                    await self.__execute_api(stepApi, step, case_result)                if stepSql and not stepSql.b_or_a:                    await self.__execute_sql(stepSql)            # å¦‚æœå½“å‰æ­¥éª¤æœ‰å…³è”çš„APIæˆ–SQLï¼Œåˆ™æ‰§è¡Œå‰ç½®åŠ¨ä½œã€æ­¥éª¤æœ¬èº«å’Œåç½®åŠ¨ä½œã€‚            if stepApi or stepSql:                await execute_pre_actions()                await self.__execute_step(step)                await execute_post_actions()            else:                # å¦‚æœæ²¡æœ‰å…³è”çš„APIæˆ–SQLï¼Œæ ¹æ®æ­¥éª¤æ˜¯å¦ä¸ºç»„ç±»å‹ï¼Œå†³å®šæ‰§è¡Œç»„æ­¥éª¤è¿˜æ˜¯å•ä¸ªæ­¥éª¤ã€‚                if step.is_group:                    await self.__execute_group_step(step)                else:                    await self.__execute_step(step)        except Exception as e:            # è®°å½•æ—¥å¿—æˆ–è¿›è¡Œå…¶ä»–å¼‚å¸¸å¤„ç†            log.error(f"Error in __condition_execute: {e}")            raise    async def __execute_group_step(self, step: UICaseStepsModel):        """        æ­¥éª¤ç»„æ‰§è¡Œ        :param step:        :return:        """        g_steps = await UICaseStepGroupMapper.query_steps_by_groupId(groupId=step.group_Id)        await self.io.send("===== å¼€å§‹æ‰§è¡Œæ­¥éª¤ç»„")        for i, step in enumerate(g_steps, start=1):            await self.__execute_step(step)        await self.io.send("===== æ‰§è¡Œæ­¥éª¤ç»„ç»“æŸ")    async def __execute_sql(self, stepSQl: UIStepSQLModel):        """        oracle æ‰§è¡Œ        :param stepSQl:        :return:        """        title = "å‰ç½®" if stepSQl.b_or_a else "åç½®"        await self.io.send(f'æ‰§è¡Œ{title}SQL >> {stepSQl.desc}')        newSql = await self.em.transform_target(stepSQl.sql_str)        await self.sql.send_sql(newSql)    async def __execute_api(self, stepApi: UIStepAPIModel,                            step: UICaseStepsModel,                            case_result: UIResultModel):        """        æ‰§è¡Œå‰åç½®APIè°ƒç”¨        :param stepApi:        :param step:        :param case_result:        :return:        """        title = "å‰ç½®" if stepApi.b_or_a else "åç½®"        await self.io.send(f'æ‰§è¡Œ{title}æ¥å£ >> {stepApi}')        domain = self.env.domain.split("service=")[-1].split("/base")[0]        # å…¼å®¹sit ç¯å¢ƒ        if not domain.startswith("https"):            domain = domain.replace("interface", "https")        # è¯·æ±‚        await self.api(env=domain, stepApi=stepApi)        # æå–å˜é‡        if stepApi.extracts:            await self.api.add_extracts(stepApi.extracts)        # æ–­è¨€        if stepApi.asserts:            await self.api.do_assert(stepApi=stepApi,                                     step=step,                                     case_result=case_result)    async def __execute_step(self,                             step: UICaseStepsModel):        """        æ‰§è¡Œå•æ­¥éª¤        :param step: åŒ…å«æ­¥éª¤ä¿¡æ¯çš„UICaseStepsModelå®ä¾‹        :return: None        """        # æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå®šä¹‰æ–¹æ³•        if step.method in CustomizeMethods:            return await self.__invoke_method(CustomizeMethod, step.method)        # ä½¿ç”¨å­—å…¸æ˜ å°„æ–¹æ³•å‰ç¼€åˆ°å¯¹åº”çš„å¤„ç†å‡½æ•°        method_map = {            "expect": ExpectMethod.invoke,  # æ–­è¨€            "on": APIOn.invoke,  # APIç›‘å¬            "keyboard": KeyboardMethods.invoke  # é”®ç›˜äº‹ä»¶        }        # æ ¹æ®æ–¹æ³•å‰ç¼€è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°        for prefix, handler in method_map.items():            if step.method.startswith(prefix):                return await handler(page=self.page, step=step, io=self.io, em=self.em)        # æ‰“å¼€æ–°é¡µé¢        if step.new_page:            self.page = await PageMethods.new_page(self.page,                                                   step)            return        # å¸¸è§„æ“ä½œ        return await PageMethods.play(            page=self.page,            step=step        )    async def __get_cookie(self):        """        è·å–cookie        :return:        """        cookies = await self.browser_context.context.cookies()        for c in cookies:            if c["name"] == "sid":                await self.io.send(f"è·å–åˆ°Cookie {c}")                await self.api.setCookie(c)    async def __init_play(self):        """        åˆå§‹åŒ–playwright        æŒ‡å®š            headless True            slow_mo 1s            devè¶…æ—¶5s            proè¶…æ—¶10s        :return:        """        try:            from playwright.async_api import async_playwright            self.playwright = await async_playwright().start()            self.browser = await self.playwright.chromium.launch(headless=Config.UI_Headless,                                                                 timeout=Config.UI_Timeout,                                                                 slow_mo=Config.UI_SLOW)            self.context = await self.browser.new_context()            # context.set_default_timeout(Config.UI_Timeout)            # self.browserext            self.page = await self.browser_context.get_page()        except Exception as e:            log.exception(e)            raise UIRuntimeError("åˆå§‹åŒ–æµè§ˆå™¨å¤±è´¥")    async def __init_extracts(self, case: UICaseModel):        """        åˆå§‹åŒ–å˜é‡        :param case: UICaseModel        :return:        """        # åˆå§‹åŒ–å˜é‡        self.em = ExtractManager(case.id)        variables = await UICaseVariableMapper.query_by(case_id=case.id)        await self.em.initBeforeVars(variables)        await self.io.send(f"åˆå§‹åŒ–å˜é‡ :{self.em.variables}")    def __invoke_method(self, method_class, method_name):        try:            method = getattr(method_class, method_name)            return method(page=self.page, step=self.step, io=self.io, em=self.em)        except AttributeError as e:            print(f"Method not found: {method_name}")            raise    async def to_screenshot(self) -> str:        """        æˆªå›¾        :return:        """        try:            fileDate = GenerateTools.getTime(2)            fileName = f"{GenerateTools.uid()}.jpeg"            path = os.path.join(Config.ROOT, "play_error_shot", fileDate, fileName)            await self.page.screenshot(                path=path,                full_page=True)            await self.io.send("å®Œæˆå¤±è´¥æˆªå›¾âœ…")            return path        except Exception as e:            log.error(e)            await self.io.send(f"æˆªå›¾å¤±è´¥âŒ {str(e)}")