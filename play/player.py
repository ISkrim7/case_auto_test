#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/8# @Author : cyq# @File : player# @Software: PyCharm# @Desc:import asyncioimport jsonimport osfrom typing import List, Dict, Sequencefrom playwright.async_api import Page, LocatorAssertions, BrowserContextfrom playwright._impl._errors import TimeoutError, TargetClosedErrorfrom app.exception import UIRuntimeErrorfrom app.mapper.interface import InterfaceMapperfrom app.mapper.play import PlayCaseMapper, PlayCaseResultMapper, PlayStepMapper, PlayCaseVariablesMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.model.interface import InterfaceModelfrom app.model.playUI import PlayCaseResult, PlayCase, PlayStepfrom interface.runner import InterFaceRunnerfrom play.browser import get_browser_contextfrom play.methods import CustomizeMethod, new_pagefrom play.exception import APIAssertExceptionfrom play._exec.execCondition import ExecConditionfrom utils import log, GenerateToolsfrom utils.execDBScript import ExecDBScriptfrom play.writer import Writerfrom play.starter import UIStarterfrom config import Configfrom utils.variableTrans import VariableTransclass Player:    """    UI自动化 处理与执行    """    page: Page    browser_context: BrowserContext    def __init__(self, starter: UIStarter):        self._starter = starter        self._api_runner = InterFaceRunner(starter)        self._var = VariableTrans()        self._condition = ExecCondition(self._var)    async def run_case(self, caseId: int):        """        根据用例ID查询用例并准备执行。        :param caseId: 需要执行的用例ID，类型为int。        :return: 无返回值。        """        # 通过用例ID获取用例信息        play_case = await PlayCaseMapper.get_by_id(caseId)        await self._starter.send(f"准备执行用例 :{play_case}")        # 初始化用例结果，        init_case_result: PlayCaseResult = await PlayCaseResultMapper.init_case_result(play_case=play_case,                                                                                       user=self._starter)        # 执行用例        await self.execute_case(play_case=play_case, play_case_result=init_case_result)    async def execute_case(self,                           play_case: PlayCase,                           play_case_result: PlayCaseResult) -> bool:        """        case 执行        :param play_case: 待执行用例        :param play_case_result: 初始化的用例结果模型        :return:        """        error_info = {}        success_flag = True        try:            # 执行准备            play_steps: Sequence[PlayStep] = await PlayStepMapper.query_steps_by_caseId(play_case.id)            await self._starter.send(f"获取用例步骤长度 :{len(play_steps)}")            if not play_steps:                await self._starter.send(f"无用例步骤⚠️ 运行结束")                await Writer.write_case_result(case_result=play_case_result,                                               starter=self._starter)                return success_flag            # 初始化变量            await self.init_case_variables(play_case, play_case_result)            # 初始化play            try:                await self.init_play()            except Exception as e:                success_flag = False                error_info = {                    "ui_case_err_step": -1,                    "ui_case_err_step_title": "-",                    "ui_case_err_step_msg": f"Service Error {str(e)}"                }                return success_flag            # 步骤执行            for i, step in enumerate(play_steps, start=1):                try:                    await self._starter.send(f'执行步骤 >> step[{i}] : {step} \n')                    if step.is_group:                        # 执行组                        await self.execute_group_step(step, play_case_result)                    else:                        # 单步骤条件执行                        await self.condition_execute(step, play_case_result)                except Exception as e:                    log.exception(e)                    await self._starter.send(f"步骤 \"{step}\" 执行失败 >> \"{e}\"")                    # is_ignore true 忽略本次失败 、继续                    if step.is_ignore:                        await self._starter.send('step is ignore, continue...')                        continue                    success_flag = False                    error_info = await self.format_error_info(i, step, e)                    log.error(f"步骤执行失败 >> {step} : {error_info}")                    # 页面关闭、 接口请求失败 、不截图                    if not isinstance(e, (TargetClosedError, APIAssertException)):                        errorPath = await self.to_screenshot()                        error_info['ui_case_err_step_pic_path'] = errorPath        finally:            # 最终尝试 清空资源            await self._starter.send(f'执行完成 >> {play_case}, 结果: {success_flag}')            await Writer.write_case_result(play_case_result, self._starter, error_info)            await self._starter.over(play_case_result.uid)            await self.cleanup_resources()            return success_flag    async def __execute_condition_sub(self, step: PlayStep):        """        条件执行        """        # 条件判断        flag = await self._condition.invoke(step, self._starter)        if flag:            subSteps: List[PlayStep] = await PlayStepMapper.query_condition(step.id)            if len(subSteps) > 0:                for subStep in subSteps:                    await self._starter.send(f'执行子步骤 >> {subStep}'),                    await self.__execute_step(subStep)            else:                await self._starter.send("无子步骤 ...")        else:            await self._starter.send(f'条件执行失败 >> {step.condition}')    async def condition_execute(self, play_step: PlayStep, case_result: PlayCaseResult):        """        根据条件执行测试步骤。此函数负责根据提供的步骤模型和测试结果模型，执行相关的API或SQL前置和后置动作，        并根据步骤类型执行单个步骤或步骤组。        :param play_step: UICaseStepsModel类型的实例，代表当前要执行的测试步骤。        :param case_result: UIResultModel类型的实例，用于存储测试结果。        :return: 无返回值。如果在执行过程中遇到异常，将抛出异常。        """        try:            async def execute_actions(is_pre: int):                """                前后置执行                """                if play_step.interface_a_or_b == is_pre and play_step.interface_id:                    step_api = await InterfaceMapper.get_by_id(ident=play_step.interface_id)                    await self.__execute_api(step_api, play_step, case_result)                if play_step.db_id and play_step.db_a_or_b == is_pre:                    await self.__execute_sql(play_step, case_result)            # 执行            if play_step.interface_id or play_step.db_id:                await execute_actions(is_pre=1)                await self.__execute_step(play_step, case_result)                await execute_actions(is_pre=0)            else:                await self.__execute_step(play_step, case_result)            # 子步骤 判断执行            if play_step.condition:                await self.__execute_condition_sub(play_step)        except Exception as e:            raise    async def __execute_sql(self, playStep: PlayStep, case_result: PlayCaseResult):        """        oracle 执行        :param playStep:        :return:        """        title = "前置" if playStep.db_a_or_b else "后置"        _db = await DbConfigMapper.get_by_id(playStep.db_id)        script = await self._var.trans(playStep.sql_script)        await self._starter.send(f'执行{title}SQL >> {script}')        db_script = ExecDBScript(self._starter, script)        _vars = await db_script.invoke(_db.db_type, **_db.config)        if _vars:            await self._starter.send(f"SQL 提取变量 >> {_vars}")            await self._var.add_vars(_vars)            await Writer.write_vars_info(case_result=case_result,                                         extract_method="SQL提取",                                         step_name=playStep.name,                                         varsInfo=_vars)        return    async def __execute_api(self,                            stepApi: InterfaceModel,                            step: PlayStep,                            case_result: PlayCaseResult):        """        执行前后置API调用        目前看 只用于调用获得变量或着使用。与断言终止        :param stepApi: 步骤API        :param step: UI步骤        :param case_result: 用例结果对象写入        :return:        """        title = "前置" if step.interface_a_or_b else "后置"        await self._starter.send(f'执行{title}接口 >> {stepApi}')        result_info, flag = await self._api_runner.execute_interface_by_ui(stepApi, self._var())        # 处理提取变量        if extracts := result_info.get('extracts', []):            _ex = GenerateTools.list2dict(extracts)            await self._starter.send(f"接口提取变量 >> {_ex}")            await self._var.add_vars(_ex)            await Writer.write_vars_info(case_result=case_result,                                         extract_method="API执行",                                         step_name=step.name,                                         varsInfo=_ex)        # 如果有断言写入断言        # 处理断言        if asserts := result_info.get("asserts", []):            await Writer.write_assert_info(case_result=case_result, assertsInfo=asserts)        # 如果接口断言失败了切不跳过 抛出异常        if not flag and step.interface_fail_stop == 1:            await self._starter.send(f"接口执行失败 >> {stepApi}")            await self._starter.over(reportId=case_result.id)            raise APIAssertException()    async def execute_group_step(self, step: PlayStep, case_result: PlayCaseResult):        """        步骤组执行        :param step:        :return:        """        g_steps = await PlayStepMapper.query_steps_by_groupId(groupId=step.id)        log.error(f"步骤组 >> {g_steps}")        if g_steps:            await self._starter.send(f"===== 开始执行步骤组 {step.name}")            for i, step in enumerate(g_steps, start=1):                log.info(f"步骤组 >> {g_steps}")                await self.condition_execute(step, case_result)            await self._starter.send(f"===== {step.name} 执行步骤组结束")        else:            await self._starter.send(f"步骤组 >> {step.name} 步骤组为空")    async def __execute_step(self,                             play_step: PlayStep,                             play_case_result: PlayCaseResult = None):        """        执行单步骤        :param play_step: PlayStep        :param play_case_result: PlayCaseResult        :return: None        """        log.info(f"执行步骤 >> {play_step}")        # 打开新页面特殊处理        if play_step.new_page:            self.page = await new_page(page=self.page, play_step=play_step, starter=self._starter, vt=self._var)            return        # 其他自定义步骤        else:            await CustomizeMethod.play(                page=self.page,                play_step=play_step,                starter=self._starter,                vt=self._var,                play_result=play_case_result            )            return    async def init_play(self):        """        初始化playwright        指定            headless True            slow_mo 1s            dev超时5s            pro超时10s        :return:        """        try:            self.browser_context = await get_browser_context()            self.page = await self.browser_context.new_page()            log.info(f"初始化浏览器成功 {self.browser_context} {self.page}")        except Exception as e:            log.exception(e)            raise UIRuntimeError("初始化浏览器失败")    async def init_case_variables(self, play_case: PlayCase, case_result: PlayCaseResult):        """        初始化变量        :param play_case: UICaseModel        :return:        """        try:            if variables := await PlayCaseVariablesMapper.query_by(play_case_id=play_case.id):                for case_var in variables:                    _v = await self._var.trans(case_var.value)                    await self._var.add_vars({case_var.key: _v})                await Writer.write_vars_info(case_result=case_result, extract_method="INIT", step_name="INIT",                                             varsInfo=self._var())                await self._starter.send(f"🫳🫳 初始化用例变量 = {json.dumps(self._var(), ensure_ascii=False)}")        except Exception as e:            log.exception(e)            raise e    async def to_screenshot(self):        """        截图        :return:        """        try:            # 确保截图目录存在            os.makedirs(Config.ERROR_SCREENSHOT_DIR, exist_ok=True)            filedate = GenerateTools.getTime(2)            filename = f"{GenerateTools.uid()}.jpeg"            path = os.path.join(Config.ERROR_SCREENSHOT_DIR, filedate,filename)            await self.page.screenshot(                path=str(path),                full_page=True)            await self._starter.send("完成失败截图✅")            return path        except Exception as e:            log.error(e)            await self._starter.send(f"截图失败❌ {str(e)}")    @staticmethod    async def format_error_info(step_index: int, step: PlayStep,                                e: Exception) -> Dict[str, str]:        """        格式化错误执行信息        :param step_index: 步骤索引        :param step: PlayStep        :param e:Exception        :return:        """        error_info = {            "ui_case_err_step": step_index,            "ui_case_err_step_title": step.name,            "ui_case_err_step_msg": str(e)        }        if isinstance(e, LocatorAssertions):            msg = str(e).split("Call log:")[0]            error_info[                "ui_case_err_step_msg"] = f"{e.__class__.__name__}❌: {msg} << "        elif isinstance(e, TimeoutError):            error_info[                "ui_case_err_step_msg"] = (f"{e.__class__.__name__}❌: Timeout waiting for locator \n"                                           f">> '{step.locator}' << ")        elif isinstance(e, AssertionError):            msg = str(e).split("Call log:")[0]            error_info["ui_case_err_step_msg"] = (f"{e.__class__.__name__}❌: method >> '{step.method}' << \n"                                                  f"{msg}")        elif isinstance(e, TargetClosedError):            error_info["ui_case_err_step_msg"] = f"🚀 {e.__class__.__name__}❌: {str(e)}"        return error_info    async def cleanup_resources(self):        """Centralized resource cleanup"""        if self.browser_context:            await self.browser_context.close()            log.info("browser_context page success")        await asyncio.gather(            self._var.clear(),            self._starter.clear_logs(),            return_exceptions=True        )