#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/8# @Author : cyq# @File : player# @Software: PyCharm# @Desc:import asynciofrom typing import List, Dict, NoReturnfrom playwright.async_api import async_playwright, Page, Playwright, BrowserContext, Browser, LocatorAssertionsfrom playwright._impl._errors import TimeoutError, TargetClosedErrorfrom app.exception.err_handle_func import UIRuntimeErrorfrom app.mapper.ui.uiCaseMapper import UICaseStepApiMapper, UICaseStepSQLMapperfrom app.mapper.ui.uiCaseStepGroupMapper import UICaseStepGroupMapperfrom app.mapper.ui.uiCaseVariableMapper import UICaseVariableMapperfrom app.mapper.ui.uiEnvMapper import UIEnvMapperfrom model.ui import UICaseModel, UICaseStepsModel, UICaseTaskResultBaseModel, UIResultModel, \    UIStepAPIModel, UIEnvModel, UIStepSQLModel, UITaskModelfrom enums.CaseEnum import Statusfrom app.mapper.ui.uiCaseMapper import UICaseMapperfrom app.mapper.ui.uiTaskMapper import UITaskMapperfrom play.exception import PlayAssertException, APIAssertException, CBSLoginFailfrom play.apiSender import APISenderfrom play.sqlSender import SqlSenderfrom utils import logfrom utils.wrapper_ import lockfrom utils.report import Reportfrom play.play import Play, CustomizeMethod, PlayKeyboardfrom play.writer import Writerfrom play.logWriter import LogWriterfrom play.extract import ExtractManagerfrom config import Configimport jenkinsdef getAssertErrorMsg(e) -> str:    if isinstance(e, (AssertionError, LocatorAssertions)):        return ",".join(str(e).split("Call log:")[:1])async def format_error_info(step_index: int, step: UICaseStepsModel,                            e: Exception) -> Dict[str, str]:    """    æ ¼å¼åŒ–é”™è¯¯æ‰§è¡Œä¿¡æ¯    :param step_index: æ­¥éª¤ç´¢å¼•    :param step: UICaseStepsModel    :param e:Exception    :return:    """    error_info = {        "ui_case_err_step": step_index,        "ui_case_err_step_title": step.name,        "ui_case_err_step_msg": str(e)    }    if isinstance(e, LocatorAssertions):        msg = getAssertErrorMsg(e)        error_info[            "ui_case_err_step_msg"] = f"{e.__class__.__name__}âŒ: {msg} << "    elif isinstance(e, TimeoutError):        error_info[            "ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: Timeout waiting for locator \n"                                       f">> '{step.locator}' << ")    elif isinstance(e, PlayAssertException):        msg = getAssertErrorMsg(e)        error_info["ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: method >> '{step.method}' << \n"                                              f"{msg}")    elif isinstance(e, APIAssertException):        error_info["ui_case_err_step_msg"] = f"ğŸš€ {e.__class__.__name__}âŒ: {str(e)}"    elif isinstance(e, TargetClosedError):        error_info["ui_case_err_step_msg"] = f"ğŸš€ {e.__class__.__name__}âŒ: {str(e)}"    return error_infoasync def run_Tasks(taskIds: List[int], userId: int, jobName: str = None):    """    run for jenkins    :param taskIds:    :param userId:    :param jobName:    :return:    """    try:        tasks = [Player().run_task(task, userId) for task in taskIds]        await asyncio.gather(*tasks)    except Exception as e:        log.error(e)    finally:        if jobName:            log.info(f'=========={jobName}')            server = jenkins.Jenkins(url=Config.JENKINS_URL,                                     username=Config.JENKINS_USERNAME,                                     password=Config.JENKINS_PASSWORD)            log.info(f'build=========={jobName}')            server.build_job(jobName)class AsyncPlay:    @classmethod    async def play(cls) -> Playwright:        return await async_playwright().start()class TaskChecker:    @staticmethod    async def check_cases(task: UITaskModel) -> List[UICaseModel]:        """        æ£€æŸ¥ç”¨ä¾‹        :param task:        :return:        """        task_cases: List[UICaseModel] = await UITaskMapper.query_cases_by_task_id(task.id)        # æ— å¾…æ‰§è¡Œç”¨ä¾‹ï¼Œç»“æŸ        number_of_pending_use_cases = len(task_cases)        if number_of_pending_use_cases == 0:            log.error(f'æ— å¾…æ‰§è¡Œç”¨ä¾‹ï¼Œç»“æŸã€‚')            raise UIRuntimeError("æ— å¾…æ‰§è¡Œç”¨ä¾‹ï¼Œç»“æŸã€‚")        return task_casesclass Player:    """    UIè‡ªåŠ¨åŒ– å¤„ç†ä¸æ‰§è¡Œ    """    play: Playwright    page: Page    browser: Browser    context: BrowserContext    logger: LogWriter    em: ExtractManager    api: APISender    sql: SqlSender    env: UIEnvModel    def __init__(self):        self.logger = LogWriter()    @lock("UI_TASK")    async def run_task(self, taskId: int, userId: int = None):        """        æ‰§è¡Œui TASK        :param taskId å¾…è¿è¡ŒTASK ID        :param userId æ‰§è¡Œäºº ID        """        # æŸ¥è¯¢ä»»åŠ¡        task = await UITaskMapper.get_by_id(taskId)        self.logger.taskId = task.uid        await self.logger.write_log(f'æ‰§è¡Œui TASK:{task}')        # æ¢æ´»        await TaskChecker.check_beat(task)        # æŸ¥è¯¢ä»»åŠ¡ç”¨ä¾‹        task_cases: List[UICaseModel] = await TaskChecker.check_cases(task)        # æ›´æ–°ä»»åŠ¡çŠ¶æ€        await Writer.write_task_status(task, Status.RUNNING)        task_result = await Writer.init_task_base_result(            totalNumber=len(task_cases),            task=task,            userId=userId        )        # æ‰§è¡Œç”¨ä¾‹        await self.retry_case(task.retry, task_cases, userId, task_result)        await self.logger.write_log(f'ui TASK:{task} æ‰§è¡Œå®Œæˆ')        # å†™å…¥ç»“æœ        try:            await Writer.write_base_result(task_result)        except Exception as e:            log.exception(e)            raise e        finally:            await Writer.write_task_status(task, Status.WAIT)            if task.isSend:                await Report().ui2weChat(task, task_result)    async def retry_case(self, retryNum: int, task_cases: List[UICaseModel], userId, task_result):        """        ä»»åŠ¡ ç”¨ä¾‹é‡è¯•æ‰§è¡Œæœºåˆ¶æ‰§è¡Œ        :param retryNum: é‡è¯•æ¬¡æ•°        :param task_cases: ä»»åŠ¡ç”¨ä¾‹        :param userId: æ‰§è¡Œäºº        :param task_result: åˆå§‹åŒ–çš„ä»»åŠ¡ç»“æœæ¨¡å‹        :return:        """        for case in task_cases:            init_case_result = await Writer.init_case_result(case, userId, task_result.id)            self.logger.caseId = case.uid            for i in range(retryNum + 1):                await self.logger.write_log(f'æ‰§è¡Œui case :{case} æ¬¡æ•°:{i}')                # å¦‚æœé‡è¯•æ¬¡æ•°ä¸º0 æˆ–è€…æ˜¯æœ€ç»ˆæ‰§è¡Œ å¤±è´¥æ‰è¿›è¡Œæˆªå›¾å¤„ç†                retry = retryNum == 0 or i == retryNum                flag = await self.__execute_case(case, init_case_result, task_result, retry)                # æ¯æ¬¡æ‰§è¡Œå®Œå…³é—­ playwright                await self.play.stop()                if not flag:                    if i == retryNum:                        await self.logger.write_log(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  é‡è¯•æ¬¡æ•°å·²ç”¨å®Œ')                        task_result.failNumber += 1                        await self.logger.clear()                        break                    await self.logger.write_log(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  è¿›è¡Œ{i + 1}é‡è¯•')                    continue                else:                    task_result.successNumber += 1                    await self.em.clear()                    await self.logger.clear()                    break    async def run_case(self, caseId: int, userId: int):        """        æŸ¥è¯¢ç”¨ä¾‹ å‡†å¤‡æ‰§è¡Œ        :param caseId: ä»£æ‰§è¡Œç”¨ä¾‹        :param userId: æ‰§è¡Œäºº        :return:        """        case = await UICaseMapper.get_by_id(caseId)        self.logger.caseId = case.uid        await self.logger.write_log(f"å‡†å¤‡æ‰§è¡Œç”¨ä¾‹ :{case}")        init_case_result = await Writer.init_case_result(case, userId)        await self.__execute_case(case, init_case_result)    async def __init_extracts(self, case: UICaseModel):        """        åˆå§‹åŒ–å˜é‡        :param case: UICaseModel        :return:        """        # åˆå§‹åŒ–å˜é‡        self.em = ExtractManager(case.id)        variables = await UICaseVariableMapper.query_by(caseId=case.id)        await self.em.initBeforeVars(variables)        await self.logger.write_log(f"åˆå§‹åŒ–å˜é‡ :{self.em.variables}")    async def __execute_case(self,                             case: UICaseModel,                             case_result: UIResultModel,                             task_result: UICaseTaskResultBaseModel = None,                             retry: bool = True):        """        case æ‰§è¡Œ        :param case: å¾…æ‰§è¡Œç”¨ä¾‹        :param case_result: åˆå§‹åŒ–çš„ç”¨ä¾‹ç»“æœæ¨¡å‹        :param task_result: åˆå§‹åŒ–çš„æ‰¹é‡æ‰§è¡Œç»“æœæ¨¡å‹        :param retry: é‡è¯•é€»è¾‘        :return:        """        errorInfo = {}        _flag = True        # æ‰§è¡Œå‡†å¤‡        case_steps: List[UICaseStepsModel] = await UICaseMapper.query_steps_by_caseId(case.id)        await self.logger.write_log(f"è·å–ç”¨ä¾‹æ­¥éª¤ :{len(case_steps)}")        if len(case_steps) == 0:            await self.logger.write_log(f"æ— ç”¨ä¾‹æ­¥éª¤âš ï¸ è¿è¡Œç»“æŸ")            await Writer.write_case_result(case_result, self.logger)            return _flag        # åˆå§‹åŒ–play        await self.__init_play()        # åˆå§‹åŒ–å˜é‡        await self.__init_extracts(case)        try:            # åˆå§‹åŒ–æµè§ˆå™¨ è¿›è¡Œç™»é™†            await self.__cbs_login(case, case_result, retry)        except Exception as e:            # ç™»å½•å¤±è´¥            log.error(e)            if task_result:                return False        try:            # æ­¥éª¤æ‰§è¡Œ            for i, step in enumerate(case_steps, start=1):                try:                    await self.__condition_execute(i, step, case_result)                except Exception as e:                    log.exception(e)                    await self.logger.write_log(f'some error : {str(e)}')                    await self.logger.write_log(f"æ­¥éª¤æ‰§è¡Œå¤±è´¥ >> {step}")                    # is_ignore true å¿½ç•¥æœ¬æ¬¡å¤±è´¥ ã€ç»§ç»­                    if step.is_ignore:                        await self.logger.write_log('step is ignore, continue...')                        continue                    _flag = False                    # æ˜¯å¦é‡è¯• ã€é‡è¯•æ¬¡æ•°ç”¨å®Œ                    if retry:                        errorInfo = await format_error_info(i, step, e)                        # é¡µé¢å…³é—­ã€ æ¥å£è¯·æ±‚å¤±è´¥ ã€ä¸æˆªå›¾                        if not isinstance(e, (TargetClosedError, APIAssertException)):                            errorPath = await CustomizeMethod.to_screenshot(self.page, self.logger)                            errorInfo['ui_case_err_step_pic_path'] = errorPath                    break        finally:            await self.logger.write_log(f'æ‰§è¡Œå®Œæˆ >> {case},ç»“æœ:{_flag}')            return await self.run_finally(                _flag,                task_result,                case_result,                errorInfo            )    async def run_finally(self, flag: bool,                          task_result: UICaseTaskResultBaseModel,                          case_result: UIResultModel,                          errorInfo):        # ç¡®ä¿æœ€ç»ˆæ‰§è¡Œå†™å…¥æ“ä½œ        try:            await Writer.write_case_result(case_result, self.logger, errorInfo)        except Exception as e:            log.error(e)        finally:            if task_result:                return flag            else:                await self.page.close()                await self.context.close()                await self.play.stop()    async def __condition_execute(self, i: int, step: UICaseStepsModel, case_result: UIResultModel):        """        æ¡ä»¶æ‰§è¡Œ        :param i:        :param step:        :param case_result:        :return:        """        stepApi: UIStepAPIModel = await UICaseStepApiMapper.get_by(stepId=step.id)        stepSql: UIStepSQLModel = await UICaseStepSQLMapper.get_by(stepId=step.id)        # å¦‚æœéƒ½æœ‰å‰ç½® API å’Œ SQL        if stepApi and stepSql:            if stepApi.b_or_a and stepSql.b_or_a:  # å‰ç½®                await self.__execute_api(stepApi, step, case_result)                await self.__execute_sql(stepSql)                await self.__execute_step(i, step)            elif stepApi.b_or_a or stepSql.b_or_a:  # å…¶ä¸­ä¸€ä¸ªå‰ç½®                if stepApi.b_or_a:  # API å‰ç½®                    await self.__execute_api(stepApi, step, case_result)                else:  # SQL å‰ç½®                    await self.__execute_sql(stepSql)                await self.__execute_step(i, step)                if not stepApi.b_or_a:  # API åç½®                    await self.__execute_api(stepApi, step, case_result)                if not stepSql.b_or_a:  # SQL åç½®                    await self.__execute_sql(stepSql)            else:  # éƒ½ä¸ºåç½®                await self.__execute_step(i, step)                if stepApi:  # æ‰§è¡Œ API                    await self.__execute_api(stepApi, step, case_result)                if stepSql:  # æ‰§è¡Œ SQL                    await self.__execute_sql(stepSql)        elif stepApi:  # ä»…æœ‰ API            if stepApi.b_or_a:  # å‰ç½®                await self.__execute_api(stepApi, step, case_result)                await self.__execute_step(i, step)            else:  # åç½®                await self.__execute_step(i, step)                await self.__execute_api(stepApi, step, case_result)        elif stepSql:  # ä»…æœ‰ SQL            if stepSql.b_or_a:  # å‰ç½®                await self.__execute_sql(stepSql)                await self.__execute_step(i, step)            else:  # åç½®                await self.__execute_step(i, step)                await self.__execute_sql(stepSql)        else:  # éƒ½æ²¡æœ‰            # åˆ¤æ–­æ˜¯å¦æ˜¯step group            if step.is_group:                await self.__execute_group_step(i, step)            else:                await self.__execute_step(i, step)    async def __execute_group_step(self, step_index: int, step: UICaseStepsModel):        """        æ­¥éª¤ç»„æ‰§è¡Œ        :param step_index        :param step:        :return:        """        g_steps = await UICaseStepGroupMapper.query_steps_by_groupId(groupId=step.group_Id)        await self.logger.write_log("===== å¼€å§‹æ‰§è¡Œæ­¥éª¤ç»„")        for i, step in enumerate(g_steps, start=1):            await self.__execute_step(step_index + i / 10, step)        await self.logger.write_log("===== æ‰§è¡Œæ­¥éª¤ç»„ç»“æŸ")    async def __execute_sql(self, stepSQl: UIStepSQLModel):        """        oracle æ‰§è¡Œ        :param stepSQl:        :return:        """        title = "å‰ç½®" if stepSQl.b_or_a else "åç½®"        await self.logger.write_log(f'æ‰§è¡Œ{title}SQL >> {stepSQl.desc}')        newSql = await self.em.transform_target(stepSQl.sql_str)        await self.sql.send_sql(newSql)    async def __execute_api(self, stepApi: UIStepAPIModel,                            step: UICaseStepsModel,                            case_result: UIResultModel):        """        æ‰§è¡Œå‰åç½®APIè°ƒç”¨        :param stepApi:        :param step:        :param case_result:        :return:        """        title = "å‰ç½®" if stepApi.b_or_a else "åç½®"        await self.logger.write_log(f'æ‰§è¡Œ{title}æ¥å£ >> {stepApi}')        domain = self.env.domain.split("service=")[-1].split("/base")[0]        # å…¼å®¹sit ç¯å¢ƒ        if not domain.startswith("https"):            domain = domain.replace("http", "https")        # è¯·æ±‚        await self.api(env=domain, stepApi=stepApi)        # æå–å˜é‡        if stepApi.extracts:            await self.api.add_extracts(stepApi.extracts)        # æ–­è¨€        if stepApi.asserts:            await self.api.do_assert(stepApi=stepApi,                                     step=step,                                     case_result=case_result)    async def __execute_step(self, step_index: int,                             step: UICaseStepsModel):        """        æ‰§è¡Œå•æ­¥éª¤        :param step_index:        :param step:        :return:        """        await self.logger.write_log(f'æ‰§è¡Œæ­¥éª¤ >> {step_index}:{step}')        # æ–­è¨€        if step.method.startswith("expect"):            return await Play.to_expect(                page=self.page,                step=step,                logger=self.logger,                em=self.em)        # event        if step.method.startswith("on"):            return await Play.api_on(                page=self.page,                step=step,                logger=self.logger,                em=self.em            )        if step.method.startswith("keyboard"):            return await PlayKeyboard.keyboard(page=self.page, step=step, logger=self.logger)        # æ‰“å¼€æ–°é¡µé¢        if step.new_page:            self.page = await Play.new_page(self.page, step)            return        # å¸¸è§„        return await Play.play(page=self.page,                               step=step,                               logger=self.logger,                               em=self.em)    async def __get_cookie(self):        """        è·å–cookie        :return:        """        cookies = await self.context.cookies()        for c in cookies:            if c["name"] == "sid":                await self.logger.write_log(f"è·å–åˆ°Cookie {c}")                await self.api.setCookie(c)    async def __cbs_login(self, case: UICaseModel, case_result, retry=True):        """        cbs ç™»å½•        set cookie        :param case: UICaseModel        :param case_result        :param retry        :return:        """        self.env: UIEnvModel = await UIEnvMapper.get_by_uid(case.envId)        try:            # åˆå§‹åŒ–API            self.api = APISender(logger=self.logger, em=self.em)            # åˆå§‹åŒ–SQL            self.sql = SqlSender(city=self.env.city,                                 logger=self.logger, em=self.em)            await self.logger.write_log(f"ç­‰å¾…ç™»é™† åœ°å€:{self.env.domain}")            await self.page.goto(self.env.domain, wait_until="commit")            await self.page.wait_for_load_state()            await self.page.fill("#username", case.username, timeout=1000)            await self.page.fill("#password", case.password, timeout=1000)            await self.page.click("#btn-submit", timeout=5000)            await self.page.wait_for_load_state()            await self.logger.write_log(f"CBS ç™»å½•æˆåŠŸ âœ… ")            # setCookie            await self.__get_cookie()        except Exception as e:            log.exception(e)            await self.logger.write_log(f"CBS ç™»å½•å¤±è´¥ => {e}")            _flag = False            if retry:                errorInfo = {                    "ui_case_err_step": -1,                    "ui_case_err_step_title": "CBS ç™»å½•",                    "ui_case_err_step_msg": str(e)                }                errorPath = await CustomizeMethod.to_screenshot(self.page, self.logger)                errorInfo['ui_case_err_step_pic_path'] = errorPath                await Writer.write_case_result(case_result, self.logger, errorInfo)                await self.page.close()            raise CBSLoginFail(f"CBS ç™»å½•å¤±è´¥ => {e}")    async def __init_play(self):        """        åˆå§‹åŒ–playwright        æŒ‡å®š            headless True            slow_mo 1s            devè¶…æ—¶5s            proè¶…æ—¶10s        :return:        """        try:            self.play = await AsyncPlay.play()            self.browser = await self.play.chromium.launch(headless=Config.UI_Headless,                                                           timeout=Config.UI_Timeout,                                                           slow_mo=Config.UI_SLOW)            self.context = await self.browser.new_context()            self.context.set_default_timeout(Config.UI_Timeout)            self.page = await self.context.new_page()            await self.logger.write_log(f"åˆå§‹åŒ–æµè§ˆå™¨æˆåŠŸ âœ…")            await self.logger.write_log(f"Timeout    {Config.UI_Timeout} âœ…")            await self.logger.write_log(f"Slow   {Config.UI_SLOW} âœ…")        except Exception as e:            log.exception(e)            raise UIRuntimeError("åˆå§‹åŒ–æµè§ˆå™¨å¤±è´¥")