#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/8# @Author : cyq# @File : player# @Software: PyCharm# @Desc:import asyncioimport osfrom typing import List, Dictfrom playwright.async_api import Page, LocatorAssertions, BrowserContextfrom playwright._impl._errors import TimeoutError, TargetClosedErrorfrom app.exception import UIRuntimeErrorfrom app.mapper.project.env import EnvMapperfrom app.mapper.project.pushMapper import PushMapperfrom app.mapper.ui.uiCaseMapper import UICaseStepApiMapper, UICaseStepSQLMapperfrom app.mapper.ui.uiCaseResultMapper import UICaseResultMapperfrom app.mapper.ui.uiCaseStepGroupMapper import UICaseStepGroupMapperfrom app.mapper.ui.uiCaseVariableMapper import UICaseVariableMapperfrom app.mapper.ui.uiEnvMapper import UIEnvMapperfrom app.mapper.ui.uiSubStepMapper import SubStepMapperfrom app.model.base import EnvModelfrom app.model.ui import UICaseModel, UICaseStepsModel, UICaseTaskResultBaseModel, UIResultModel, \    UIStepAPIModel, UIEnvModel, UIStepSQLModelfrom app.mapper.ui.uiCaseMapper import UICaseMapperfrom app.mapper.ui.uiTaskMapper import UITaskMapperfrom enums import StarterEnumfrom play.exception import APIAssertExceptionfrom play._exec.execCondition import ExecConditionfrom play.methods.api_on import APIOnfrom play.browser import get_browser_contextfrom play.methods.customize_method import CustomizeMethodsfrom play.apiSender import APISenderfrom play.methods.expect_method import ExpectMethodfrom play.methods.keyboard_methods import KeyboardMethodsfrom play.methods.page_methods import PageMethodsfrom play.sqlSender import SqlSenderfrom utils import log, GenerateToolsfrom utils.wrapper_ import lockfrom utils.report import ReportPushfrom play.methods.customize_method import CustomizeMethodfrom play.writer import Writerfrom play.extract import ExtractManagerfrom play.starter import UIStarterfrom config import Configimport jenkinsasync def format_error_info(step_index: int, step: UICaseStepsModel,                            e: Exception) -> Dict[str, str]:    """    æ ¼å¼åŒ–é”™è¯¯æ‰§è¡Œä¿¡æ¯    :param step_index: æ­¥éª¤ç´¢å¼•    :param step: UICaseStepsModel    :param e:Exception    :return:    """    error_info = {        "ui_case_err_step": step_index,        "ui_case_err_step_title": step.name,        "ui_case_err_step_msg": str(e)    }    log.error(type(e))    if isinstance(e, LocatorAssertions):        msg = str(e).split("Call log:")[0]        error_info[            "ui_case_err_step_msg"] = f"{e.__class__.__name__}âŒ: {msg} << "    elif isinstance(e, TimeoutError):        error_info[            "ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: Timeout waiting for locator \n"                                       f">> '{step.locator}' << ")    elif isinstance(e, AssertionError):        msg = str(e).split("Call log:")[0]        error_info["ui_case_err_step_msg"] = (f"{e.__class__.__name__}âŒ: method >> '{step.method}' << \n"                                              f"{msg}")    elif isinstance(e, TargetClosedError):        error_info["ui_case_err_step_msg"] = f"ğŸš€ {e.__class__.__name__}âŒ: {str(e)}"    return error_infoasync def run_Tasks(taskIds: List[int], userId: int, jobName: str = None):    """    run for jenkins    :param taskIds:    :param userId:    :param jobName:    :return:    """    try:        tasks = [Player(UIStarter(StarterEnum.Jenkins)).run_task(task, userId) for task in taskIds]        await asyncio.gather(*tasks)    except Exception as e:        log.error(e)    finally:        if jobName:            server = jenkins.Jenkins(url=Config.JENKINS_URL,                                     username=Config.JENKINS_USERNAME,                                     password=Config.JENKINS_PASSWORD)            log.info(f'build=========={jobName}')            server.build_job(jobName)class Player:    """    UIè‡ªåŠ¨åŒ– å¤„ç†ä¸æ‰§è¡Œ    """    page: Page    browser_context: BrowserContext    em: ExtractManager    sql: SqlSender    env: UIEnvModel    api: APISender    def __init__(self, starter: UIStarter):        self._starter = starter        self.em = ExtractManager()    @lock("UI_TASK")    async def run_task(self, taskId: int):        """        æ‰§è¡Œui TASK        :param taskId å¾…è¿è¡ŒTASK ID        """        # æŸ¥è¯¢ä»»åŠ¡        task = await UITaskMapper.get_by_id(taskId)        await self._starter.send(f'æ‰§è¡Œui TASK:{task}')        # åˆå§‹åŒ–ä»»åŠ¡ç»“æœ        task_base_result = await Writer.init_task_base_result(            task=task,            starter=self._starter        )        # æŸ¥è¯¢ä»»åŠ¡ç”¨ä¾‹        task_cases: List[UICaseModel] = await UITaskMapper.query_cases_by_task_id(task.id)        # é‡è¯•æ¬¡æ•°        retry_num = task.retry        # æ‰§è¡Œç”¨ä¾‹        await self.retry_case(retry_num, task_cases, task_base_result)        await self._starter.send(f'ui TASK:{task} æ‰§è¡Œå®Œæˆ')        # å†™å…¥ç»“æœ        try:            await Writer.write_base_result(task_base_result)        except Exception as e:            log.exception(e)            raise e        finally:            if task.push_id:                push = await PushMapper.get_by_id(task.push_id)                rp = ReportPush(push_type=push.push_type, push_value=push.push_value)                await rp.push(task, task_base_result)    async def retry_case(self, retry_num: int, task_cases: List[UICaseModel], task_result: UICaseTaskResultBaseModel):        """        ä»»åŠ¡ ç”¨ä¾‹é‡è¯•æ‰§è¡Œæœºåˆ¶æ‰§è¡Œ        :param retry_num: é‡è¯•æ¬¡æ•°        :param task_cases: ä»»åŠ¡ç”¨ä¾‹        :param task_result: åˆå§‹åŒ–çš„ä»»åŠ¡ç»“æœæ¨¡å‹        :return:        """        # éå†æ¯ä¸ªä»»åŠ¡ç”¨ä¾‹        for index, case in enumerate(task_cases, start=1):            # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœ            init_case_result = await Writer.init_case_result(case, self._starter, task_result.id)            try:                # æ‰§è¡Œç”¨ä¾‹ï¼Œå…è®¸é‡è¯•çš„æ¬¡æ•°ä¸º retryNum + 1                for i in range(retry_num + 1):                    # å‘é€å½“å‰ç”¨ä¾‹æ‰§è¡Œçš„ä¿¡æ¯å’Œæ¬¡æ•°                    await self._starter.send(f'æ‰§è¡Œui case :{case} æ¬¡æ•°:{i}')                    # å¦‚æœé‡è¯•æ¬¡æ•°ä¸º0 æˆ–è€…æ˜¯æœ€ç»ˆæ‰§è¡Œ å¤±è´¥æ‰è¿›è¡Œæˆªå›¾å¤„ç†                    retry = retry_num == 0 or i == retry_num                    try:                        # æ‰§è¡Œç”¨ä¾‹å¹¶è·å–ç»“æœ                        flag = await self.__execute_case(case, init_case_result, task_result, retry)                    except Exception as e:                        # ç”¨ä¾‹æ‰§è¡Œå¤±è´¥ï¼Œå‘é€é”™è¯¯ä¿¡æ¯                        await self._starter.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥ï¼Œé”™è¯¯ä¿¡æ¯: {str(e)}')                        # å¦‚æœå·²ç»è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå¢åŠ å¤±è´¥è®¡æ•°å¹¶æ¸…é™¤æ—¥å¿—ï¼Œç„¶åè·³å‡ºå¾ªç¯                        if i == retry_num:                            task_result.fail_number += 1                            await self._starter.clear_logs()                            break                        # å¦åˆ™ï¼Œè¿›è¡Œé‡è¯•                        await self._starter.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  è¿›è¡Œ{i + 1}é‡è¯•')                        continue                    # å¦‚æœç”¨ä¾‹æ‰§è¡ŒæˆåŠŸï¼Œä½†æœªé€šè¿‡ï¼ˆflagä¸ºFalseï¼‰                    if not flag:                        # å¦‚æœå·²ç»è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œå‘é€å¤±è´¥ä¿¡æ¯ï¼Œå¢åŠ å¤±è´¥è®¡æ•°å¹¶æ¸…é™¤æ—¥å¿—ï¼Œç„¶åè·³å‡ºå¾ªç¯                        if i == retry_num:                            await self._starter.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  é‡è¯•æ¬¡æ•°å·²ç”¨å®Œ')                            task_result.fail_number += 1                            await self._starter.clear_logs()                            break                        # å¦åˆ™ï¼Œè¿›è¡Œé‡è¯•                        await self._starter.send(f'ç”¨ä¾‹:{case} æ‰§è¡Œå¤±è´¥  è¿›è¡Œ{i + 1}é‡è¯•')                        continue                    else:                        # ç”¨ä¾‹æ‰§è¡ŒæˆåŠŸï¼Œå¢åŠ æˆåŠŸè®¡æ•°ï¼Œæ¸…é™¤è¯æ®å’Œæ—¥å¿—ï¼Œç„¶åè·³å‡ºå¾ªç¯                        task_result.success_number += 1                        await self.em.clear()                        await self._starter.clear_logs()                        break            finally:                # åœæ­¢å½“å‰ç”¨ä¾‹çš„æ‰§è¡Œ                pass    async def run_case(self, caseId: int):        """        æ ¹æ®ç”¨ä¾‹IDæŸ¥è¯¢ç”¨ä¾‹å¹¶å‡†å¤‡æ‰§è¡Œã€‚        :param caseId: éœ€è¦æ‰§è¡Œçš„ç”¨ä¾‹IDï¼Œç±»å‹ä¸ºintã€‚        :return: æ— è¿”å›å€¼ã€‚        """        # é€šè¿‡ç”¨ä¾‹IDè·å–ç”¨ä¾‹ä¿¡æ¯        case = await UICaseMapper.get_by_id(caseId)        await self._starter.send(f"å‡†å¤‡æ‰§è¡Œç”¨ä¾‹ :{case}")        # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœï¼Œ        init_case_result = await UICaseResultMapper.init_case_result_model(case, self._starter)        # æ‰§è¡Œç”¨ä¾‹        await self.__execute_case(case, init_case_result)    async def __execute_case(self,                             case: UICaseModel,                             case_result: UIResultModel,                             retry: bool = True):        """        case æ‰§è¡Œ        :param case: å¾…æ‰§è¡Œç”¨ä¾‹        :param case_result: åˆå§‹åŒ–çš„ç”¨ä¾‹ç»“æœæ¨¡å‹        :param retry: é‡è¯•é€»è¾‘        :return:        """        error_info = {}        success_flag = True        try:            # æ‰§è¡Œå‡†å¤‡            case_steps: List[UICaseStepsModel] = await UICaseMapper.query_steps_by_caseId(case.id)            await self._starter.send(f"è·å–ç”¨ä¾‹æ­¥éª¤ :{len(case_steps)}")            if not case_steps:                await self._starter.send(f"æ— ç”¨ä¾‹æ­¥éª¤âš ï¸ è¿è¡Œç»“æŸ")                await Writer.write_case_result(case_result, self._starter)                return success_flag            # åˆå§‹åŒ–å˜é‡            await self.__init_extracts(case)            # åˆå§‹åŒ–play            try:                await self.__init_play()            except Exception as e:                success_flag = False                error_info = {                    "ui_case_err_step": -1,                    "ui_case_err_step_title": "-",                    "ui_case_err_step_msg": f"Service Error {str(e)}"                }                return success_flag            # OPEN URL            env = await UIEnvMapper.get_by_id(case.env_id)            try:                await CustomizeMethod.to_goto(self.page, env.domain, self._starter, self.em)            except Exception as e:                await self._starter.send(f"æ‰“å¼€URLå¤±è´¥: {str(e)}")                success_flag = False                error_info = {                    "ui_case_err_step": -1,                    "ui_case_err_step_title": "-",                    "ui_case_err_step_msg": f"Open URL Error {str(e)}"                }                return success_flag            # æ­¥éª¤æ‰§è¡Œ            for i, step in enumerate(case_steps, start=1):                try:                    await self._starter.send(f'æ‰§è¡Œæ­¥éª¤ >> step[{i}] : {step}')                    #  æ¡ä»¶æ‰§è¡Œ                    await self.__condition_execute(step, case_result)                    # å­æ­¥éª¤ åˆ¤æ–­æ‰§è¡Œ                    if step.has_condition:                        await self.__execute_condition(step)                except Exception as e:                    log.exception(e)                    await self._starter.send(f'some error : {str(e)}')                    await self._starter.send(f"æ­¥éª¤æ‰§è¡Œå¤±è´¥ >> {step}")                    # is_ignore true å¿½ç•¥æœ¬æ¬¡å¤±è´¥ ã€ç»§ç»­                    if step.is_ignore:                        await self._starter.send('step is ignore, continue...')                        continue                    success_flag = False                    # æ˜¯å¦é‡è¯• ã€é‡è¯•æ¬¡æ•°ç”¨å®Œ                    if retry:                        error_info = await format_error_info(i, step, e)                        # é¡µé¢å…³é—­ã€ æ¥å£è¯·æ±‚å¤±è´¥ ã€ä¸æˆªå›¾                        if not isinstance(e, (TargetClosedError, APIAssertException)):                            errorPath = await self.to_screenshot()                            error_info['ui_case_err_step_pic_path'] = errorPath                    break        finally:            log.debug(error_info)            await self._starter.send(f'æ‰§è¡Œå®Œæˆ >> {case}, ç»“æœ: {success_flag}')            await Writer.write_case_result(case_result, self._starter, error_info)            await self.page.close()            await self.browser_context.close()            return success_flag    async def __execute_condition(self, step: UICaseStepsModel):        flag = await ExecCondition.invoke(step, self._starter, self.em)        if flag:            subSteps = await SubStepMapper.query_by_stepId(step.id)            if len(subSteps) > 0:                for subStep in subSteps:                    await self._starter.send(f'æ‰§è¡Œå­æ­¥éª¤ >> {subStep}'),                    await self.__execute_step(subStep)            else:                await self._starter.send("æ— å­æ­¥éª¤ ...")        else:            await self._starter.send(f'æ¡ä»¶æ‰§è¡Œå¤±è´¥ >> {step.condition}')    async def __condition_execute(self, step: UICaseStepsModel, case_result: UIResultModel):        """        æ ¹æ®æ¡ä»¶æ‰§è¡Œæµ‹è¯•æ­¥éª¤ã€‚æ­¤å‡½æ•°è´Ÿè´£æ ¹æ®æä¾›çš„æ­¥éª¤æ¨¡å‹å’Œæµ‹è¯•ç»“æœæ¨¡å‹ï¼Œæ‰§è¡Œç›¸å…³çš„APIæˆ–SQLå‰ç½®å’Œåç½®åŠ¨ä½œï¼Œ        å¹¶æ ¹æ®æ­¥éª¤ç±»å‹æ‰§è¡Œå•ä¸ªæ­¥éª¤æˆ–æ­¥éª¤ç»„ã€‚        :param step: UICaseStepsModelç±»å‹çš„å®ä¾‹ï¼Œä»£è¡¨å½“å‰è¦æ‰§è¡Œçš„æµ‹è¯•æ­¥éª¤ã€‚        :param case_result: UIResultModelç±»å‹çš„å®ä¾‹ï¼Œç”¨äºå­˜å‚¨æµ‹è¯•ç»“æœã€‚        :return: æ— è¿”å›å€¼ã€‚å¦‚æœåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­é‡åˆ°å¼‚å¸¸ï¼Œå°†æŠ›å‡ºå¼‚å¸¸ã€‚        """        try:            # è·å–ä¸å½“å‰æ­¥éª¤å…³è”çš„APIå’ŒSQLä¿¡æ¯ï¼Œå¦‚æœå­˜åœ¨çš„è¯ã€‚            stepApi = await UICaseStepApiMapper.get_by(stepId=step.id)            stepSql = await UICaseStepSQLMapper.get_by(stepId=step.id)            async def execute_pre_actions():                """                æ‰§è¡Œå‰ç½®åŠ¨ä½œã€‚å¦‚æœæ­¥éª¤å…³è”çš„APIæˆ–SQLè¢«é…ç½®ä¸ºå‰ç½®åŠ¨ä½œï¼ˆb_or_aä¸ºTrueï¼‰ï¼Œ                åˆ™åˆ†åˆ«æ‰§è¡Œç›¸åº”çš„APIæˆ–SQLæ“ä½œã€‚                """                if stepApi and stepApi.b_or_a:                    await self.__execute_api(stepApi, step, case_result)                if stepSql and stepSql.b_or_a:                    await self.__execute_sql(stepSql)            async def execute_post_actions():                """                æ‰§è¡Œåç½®åŠ¨ä½œã€‚å¦‚æœæ­¥éª¤å…³è”çš„APIæˆ–SQLè¢«é…ç½®ä¸ºåç½®åŠ¨ä½œï¼ˆb_or_aä¸ºFalseï¼‰ï¼Œ                åˆ™åˆ†åˆ«æ‰§è¡Œç›¸åº”çš„APIæˆ–SQLæ“ä½œã€‚                """                if stepApi and not stepApi.b_or_a:                    await self.__execute_api(stepApi, step, case_result)                if stepSql and not stepSql.b_or_a:                    await self.__execute_sql(stepSql)            # å¦‚æœå½“å‰æ­¥éª¤æœ‰å…³è”çš„APIæˆ–SQLï¼Œåˆ™æ‰§è¡Œå‰ç½®åŠ¨ä½œã€æ­¥éª¤æœ¬èº«å’Œåç½®åŠ¨ä½œã€‚            if stepApi or stepSql:                await execute_pre_actions()                await self.__execute_step(step, case_result)                await execute_post_actions()            else:                # å¦‚æœæ²¡æœ‰å…³è”çš„APIæˆ–SQLï¼Œæ ¹æ®æ­¥éª¤æ˜¯å¦ä¸ºç»„ç±»å‹ï¼Œå†³å®šæ‰§è¡Œç»„æ­¥éª¤è¿˜æ˜¯å•ä¸ªæ­¥éª¤ã€‚                if step.is_group:                    await self.__execute_group_step(step)                else:                    await self.__execute_step(step, case_result)        except Exception as e:            # è®°å½•æ—¥å¿—æˆ–è¿›è¡Œå…¶ä»–å¼‚å¸¸å¤„ç†            log.error(f"Error in __condition_execute: {e}")            raise    async def __execute_group_step(self, step: UICaseStepsModel):        """        æ­¥éª¤ç»„æ‰§è¡Œ        :param step:        :return:        """        g_steps = await UICaseStepGroupMapper.query_steps_by_groupId(groupId=step.group_Id)        await self._starter.send("===== å¼€å§‹æ‰§è¡Œæ­¥éª¤ç»„")        for i, step in enumerate(g_steps, start=1):            await self.__execute_step(step)        await self._starter.send("===== æ‰§è¡Œæ­¥éª¤ç»„ç»“æŸ")    async def __execute_sql(self, stepSQl: UIStepSQLModel):        """        oracle æ‰§è¡Œ        :param stepSQl:        :return:        """        title = "å‰ç½®" if stepSQl.b_or_a else "åç½®"        await self._starter.send(f'æ‰§è¡Œ{title}SQL >> {stepSQl.description}')        newSql = await self.em.transform_target(stepSQl.sql_str)        # await self.sql.send_sql(newSql)    async def __execute_api(self, stepApi: UIStepAPIModel,                            step: UICaseStepsModel,                            case_result: UIResultModel):        """        æ‰§è¡Œå‰åç½®APIè°ƒç”¨        :param stepApi:        :param step:        :param case_result:        :return:        """        api = APISender(self._starter, self.em)        title = "å‰ç½®" if stepApi.b_or_a else "åç½®"        await self._starter.send(f'æ‰§è¡Œ{title}æ¥å£ >> {stepApi}')        env: EnvModel = await EnvMapper.get_by_id(stepApi.env_id, desc="è·å–ç¯å¢ƒå¤±è´¥")        # è¯·æ±‚        await api.send(env=env.url, stepApi=stepApi)        # æå–å˜é‡        if stepApi.extracts:            await api.add_extracts(stepApi.extracts)        # æ–­è¨€        if stepApi.asserts:            await api.do_assert(stepApi=stepApi,                                step=step,                                case_result=case_result)    async def __execute_step(self,                             step: UICaseStepsModel,                             case_result: UIResultModel = None):        """        æ‰§è¡Œå•æ­¥éª¤        :param step: åŒ…å«æ­¥éª¤ä¿¡æ¯çš„UICaseStepsModelå®ä¾‹        :param case_result: UIResultModel        :return: None        """        log.info(f"æ‰§è¡Œæ­¥éª¤ >> {step}")        # æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå®šä¹‰æ–¹æ³•        # ['get_attr', 'get_text', 'invoke', 'to_evaluate', 'to_fill', 'to_goto', 'to_reload', 'to_wait', 'upload_file', 'wait']        if step.method in CustomizeMethods:            return await CustomizeMethod.invoke(self.page, step, self._starter, self.em)        # å®šä¹‰æ–¹æ³•å‰ç¼€åˆ°å¤„ç†å‡½æ•°çš„æ˜ å°„        method_map = {            "expect": lambda: ExpectMethod.invoke(                page=self.page,                step=step,                starter=self._starter,                em=self.em,                case_result=case_result            ),            "on": lambda: APIOn.invoke(                page=self.page,                step=step,                starter=self._starter,                em=self.em            ),            "keyboard": lambda: KeyboardMethods.invoke(                step=step,                starter=self._starter,            )        }        # æ ¹æ®æ–¹æ³•å‰ç¼€è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°        for prefix, handler in method_map.items():            if step.method.startswith(prefix):                return await handler()        # æ‰“å¼€æ–°é¡µé¢        if step.new_page:            self.page = await PageMethods.new_page(self.page,                                                   step)            return        # å¸¸è§„æ“ä½œ        return await PageMethods.play(            page=self.page,            step=step        )    async def __init_play(self):        """        åˆå§‹åŒ–playwright        æŒ‡å®š            headless True            slow_mo 1s            devè¶…æ—¶5s            proè¶…æ—¶10s        :return:        """        try:            self.browser_context = await get_browser_context()            self.page = await self.browser_context.new_page()        except Exception as e:            log.exception(e)            raise UIRuntimeError("åˆå§‹åŒ–æµè§ˆå™¨å¤±è´¥")    async def __init_extracts(self, case: UICaseModel):        """        åˆå§‹åŒ–å˜é‡        :param case: UICaseModel        :return:        """        # åˆå§‹åŒ–å˜é‡        variables = await UICaseVariableMapper.query_by(case_id=case.id)        await self.em.initBeforeVars(variables)        await self._starter.send(f"åˆå§‹åŒ–å˜é‡ :{self.em.variables}")    async def to_screenshot(self):        """        æˆªå›¾        :return:        """        try:            fileDate = GenerateTools.getTime(2)            fileName = f"{GenerateTools.uid()}.jpeg"            path = os.path.join(Config.ROOT, "play", "play_error_shot", fileDate, fileName)            await self.page.screenshot(                path=str(path),                full_page=True)            await self._starter.send("å®Œæˆå¤±è´¥æˆªå›¾âœ…")            return path        except Exception as e:            log.error(e)            await self._starter.send(f"æˆªå›¾å¤±è´¥âŒ {str(e)}")