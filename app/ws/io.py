#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/8/15# @Author : cyq# @File : __init__.py# @Software: PyCharm# @Desc:import timefrom typing import Dict, Anyfrom urllib.parse import parse_qsfrom utils import logfrom socketio import AsyncServer, ASGIAppSOCKETIO_PATH = 'socket.io'class IoASGIApp(ASGIApp):    def __init__(self):        super().__init__(            socketio_server=async_io,            socketio_path=SOCKETIO_PATH        )class AsyncIOServerManager(AsyncServer):    clientIds: Dict[str, str] = {}    def __init__(self):        super().__init__(            cors_allowed_origins="*",            async_mode='asgi',            logger=False,            transports=['websocket', "polling"],        )    async def emit(self, event: str, data: Any = None, uid: str = None, **kwargs):        """        发送事件到指定用户所在的房间。        参数:        - event (str): 事件名称。        - data (Any): 事件数据，默认为 None。        - uid (str): 用户唯一标识符，默认为 None。        - **kwargs: 其他可选参数。        注意:        - 如果 uid 对应的 room 不存在，则不会发送事件。        """        try:            user = self.clientIds.get(uid, None)            if user:                return await super().emit(event, data, to=user, **kwargs)            else:                return await super().emit(event, data, **kwargs)        except Exception as e:            log.error(e)            raise e    def push_emit(self, data: Any, uid: str):        try:            room = self.clientIds.get(uid, None)            if room:                return self.emit("push_message", data, room=room, namespace="/ws")        except Exception as e:            log.error(e)            raise e    async def data_emit(self, data: Any, uid: str):        try:            room = self.clientIds.get(uid, None)            if room:                return await self.emit('data_message', data, room=room, namespace="/ws")        except Exception as e:            log.error(e)            raise e    async def log_emit(self, data: str, uid: str):        try:            room = self.clientIds.get(uid, None)            if room:                return await self.emit('message', {"code": 0, 'data': f"{data}"}, room=room, namespace="/ws")        except Exception as e:            log.error(e)            raise e    async def log_emit_over(self, uid: str, **kwargs):        try:            room = self.clientIds.get(uid, None)            if room:                await self.emit('message', {"code": 1, 'data': {**kwargs}}, room=room, namespace="/ws")                # await self.disconnect(sid=room, namespace="/ws")        except Exception as e:            raise easync_io = AsyncIOServerManager()asgi_app = IoASGIApp()@async_io.on("connect", namespace="/api_namespace")async def api_namespace_connect(sid, env):    params = parse_qs(env.get("QUERY_STRING", ""))  # 解析查询字符串    # 获取 clientId 参数    clientId = params.get('clientId', [None])[0]  # 如果没有 clientId，返回 None    if clientId:        async_io.clientIds[clientId] = sid@async_io.on("connect", namespace="/ui_namespace")async def api_namespace_connect(sid, env):    params = parse_qs(env.get("QUERY_STRING", ""))  # 解析查询字符串    # 获取 clientId 参数    clientId = params.get('clientId', [None])[0]  # 如果没有 clientId，返回 None    if clientId:        async_io.clientIds[clientId] = sid@async_io.on("connect", namespace="/api_perf_ns")async def api_perf_ns_connect(sid, env):    params = parse_qs(env.get("QUERY_STRING", ""))  # 解析查询字符串    # 获取 clientId 参数    clientId = params.get('clientId', [None])[0]  # 如果没有 clientId，返回 None    if clientId:        async_io.clientIds[clientId] = sid@async_io.on("disconnect", namespace="/ui_namespace")async def ui_namespace_disconnect(sid):    log.info(f"{sid}  ui_namespace disconnect disconnect")@async_io.on("disconnect", namespace="/api_namespace")async def api_namespace_disconnect(sid):    log.info(f"{sid}  api_namespace disconnect")@async_io.on("disconnect", namespace="/api_perf_ns")async def api_perf_ns_disconnect(sid):    log.info(f"{sid} api_perf_ns disconnect")@async_io.on("connect")async def connect(sid, env):    log.info(f"namespace / connect {sid};{env.get('QUERY_STRING')}")    params = parse_qs(env.get("QUERY_STRING", ""))  # 解析查询字符串    # 获取 clientId 参数    clientId = params.get('clientId', [None])[0]  # 如果没有 clientId，返回 None    if clientId:        async_io.clientIds[clientId] = sid        log.debug(f"SID={sid} , ClientId={clientId} connect ")@async_io.on("disconnect", )async def disconnect(sid):    log.info(f"{sid} disconnect")@async_io.on("message")async def message(sid, data, callback=None):    # 1. 记录消息    log.info(f"Message from {sid}: {data}")    # 2. 给发送者单独回复    await async_io.emit("message", {"ts": time.time()}, to=sid)    # 3. 如果有回调函数    if callback:        await callback({"status": "processed"})