#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/4/3# @Author : cyq# @File : schedulerManager# @Software: PyCharm# @Desc:from typing import Optional, Any, Listfrom apscheduler.job import Jobfrom apscheduler.schedulers.asyncio import AsyncIOSchedulerfrom apscheduler.triggers.base import BaseTriggerfrom app.scheduler.aps.tasks import run_heartbeatfrom common.redisClient import RedisClientfrom utils import MyLogurufrom config import Configlog = MyLoguru().get_logger()def master_required(func):    async def wrapper(self, *args, **kwargs):        if not await self.is_master():            raise PermissionError("Master node required")        return await func(self, *args, **kwargs)    return wrapperclass BaseScheduler:    """è°ƒåº¦å™¨åŸºç±»ï¼ˆç”Ÿäº§çº§å®ç°ï¼‰"""    def __init__(self, redis_client: 'RedisClient'):        self.redis = redis_client        self.scheduler = AsyncIOScheduler()        self.scheduler._logger.setLevel("WARNING")  # è®¾ç½®APScheduleræ—¥å¿—çº§åˆ«ä¸ºWARNING        self.lock_key = "scheduler:master_lock"    async def try_become_master(self) -> bool:        """        å°è¯•æˆä¸ºä¸»èŠ‚ç‚¹ã€‚        è¯¥æ–¹æ³•é€šè¿‡ Redis çš„åˆ†å¸ƒå¼é”æœºåˆ¶ï¼Œå°è¯•è·å–ä¸»èŠ‚ç‚¹çš„æ§åˆ¶æƒã€‚å¦‚æœæˆåŠŸè·å–é”ï¼Œåˆ™å¯åŠ¨è°ƒåº¦å™¨å¹¶é…ç½®ç›¸å…³ä»»åŠ¡ã€‚        è¿”å›å€¼:            bool: å¦‚æœæˆåŠŸè·å–é”å¹¶æˆä¸ºä¸»èŠ‚ç‚¹ï¼Œè¿”å› Trueï¼›å¦åˆ™è¿”å› Falseã€‚        """        # å¯åŠ¨æ—¶å¼ºåˆ¶æ¸…é™¤å½“å‰å®ä¾‹æŒæœ‰çš„æ—§é”ï¼ˆå¦‚æœå­˜åœ¨ï¼‰        if self.redis.r:            await self.redis.r.delete(self.lock_key)            log.debug("â™»ï¸ [Master] Cleared previous lock if existed")        # å°è¯•åœ¨ Redis ä¸­è®¾ç½®ä¸€ä¸ªåˆ†å¸ƒå¼é”ï¼Œé”çš„é”®ä¸º self.lock_keyï¼Œå€¼ä¸º "1"ï¼Œé”çš„æœ‰æ•ˆæœŸä¸º 60 ç§’        acquired = await self.redis.r.set(            self.lock_key,            "1",            nx=True,            ex=60  # é”60ç§’è¿‡æœŸ        )        # å¦‚æœæˆåŠŸè·å–é”ï¼Œåˆ™é…ç½®è°ƒåº¦å™¨å¹¶å¯åŠ¨å®ƒï¼ŒåŒæ—¶è®¾ç½®ç›¸å…³ä»»åŠ¡        if acquired:            log.debug("ğŸ”‘ [Master] Acquired master lock (60s)")            self.scheduler.configure(jobstores=Config.APSJobStores)            self.scheduler.start()            self._setup_jobs()            log.debug("?? [Master] Scheduler started successfully")        else:            log.debug("â³ [Master] Failed to acquire master lock (another node is master)")        # è¿”å›æ˜¯å¦æˆåŠŸè·å–é”çš„ç»“æœ        return bool(acquired)    def _setup_jobs(self):        """        ä¸»èŠ‚ç‚¹æ‰è®¾ç½®çš„ä»»åŠ¡        è¯¥æ–¹æ³•ç”¨äºåœ¨ä¸»èŠ‚ç‚¹ä¸Šè®¾ç½®å®šæ—¶ä»»åŠ¡ï¼Œä¸»è¦åŒ…æ‹¬å¿ƒè·³ä»»åŠ¡ã€‚å¿ƒè·³ä»»åŠ¡ç”¨äºå®šæœŸç»­æœŸé”ï¼Œç¡®ä¿ä¸»èŠ‚ç‚¹çš„æŒç»­è¿è¡Œã€‚        """        # å¿ƒè·³ä»»åŠ¡ï¼ˆæ¯60ç§’ç»­æœŸé”ï¼‰        try:            # æ·»åŠ å¿ƒè·³ä»»åŠ¡åˆ°è°ƒåº¦å™¨ï¼Œæ¯60ç§’æ‰§è¡Œä¸€æ¬¡run_heartbeatå‡½æ•°            self.scheduler.add_job(                run_heartbeat,                "interval",                seconds=60,                id="heartbeat",                replace_existing=True,                executor="default",  # æ˜ç¡®æŒ‡å®šæ‰§è¡Œå™¨                misfire_grace_time=60  # å…è®¸60ç§’å†…çš„å»¶è¿Ÿ            )            log.debug("[Heartbeat] Configured heartbeat job (interval: 60s)")        except Exception as e:            # å¦‚æœæ·»åŠ å¿ƒè·³ä»»åŠ¡å¤±è´¥ï¼Œè®°å½•é”™è¯¯æ—¥å¿—            log.error("âŒ [Heartbeat] Failed to configure heartbeat job")            log.error(f"Configuration details: interval=60s, misfire_grace_time=60s")            log.exception(e)    # @master_required    async def add_job(            self,            func: callable,            job_id: str,            trigger: BaseTrigger,            *args: Any,            **kwargs: Any    ) -> Optional[Job]:        """æ·»åŠ å®šæ—¶ä»»åŠ¡ï¼ˆéœ€åœ¨ä¸»èŠ‚ç‚¹æ‰§è¡Œï¼‰"""        return self.scheduler.add_job(            func=func,            id=job_id,            trigger=trigger,            misfire_grace_time=3600,  # å…è®¸1å°æ—¶å†…çš„å»¶è¿Ÿ            max_instances=1,  # ç¡®ä¿ä¸ä¼šå¹¶å‘æ‰§è¡Œ            replace_existing=True,            coalesce=True,  # ç¡®ä¿å³ä½¿é”™è¿‡å¤šæ¬¡è¿è¡Œæ—¶é—´ï¼Œä¹Ÿåªè¿è¡Œä¸€æ¬¡            *args,            **kwargs        )    async def remove_job(self, job_id: str) -> None:        """ç§»é™¤å®šæ—¶ä»»åŠ¡"""        if self.scheduler.get_job(job_id):            self.scheduler.remove_job(job_id)            log.info(f"Removed job: {job_id}")    async def get_job(self, job_id: str) -> Optional[Job]:        """è·å–ä»»åŠ¡è¯¦æƒ…"""        return self.scheduler.get_job(job_id) if self.scheduler else None    async def get_all_jobs(self, prefix: str = None) -> List[Job]:        """è·å–æ‰€æœ‰ä»»åŠ¡ï¼ˆå¯é€‰å‰ç¼€è¿‡æ»¤ï¼‰"""        if not self.scheduler:            return []        jobs = self.scheduler.get_jobs()        return [job for job in jobs if not prefix or job.id.startswith(prefix)]    async def pause(self, taskId: str):        """        æš‚åœä»»åŠ¡        :param taskId:        :return:        """        log.info(f"pause Task {taskId}")        if self.scheduler.get_job(taskId):            self.scheduler.pause_job(taskId)        else:            log.warning(f"no Task {taskId} pause")    async def job_next_run_time(self, jobId: str):        job = self.scheduler.get_job(job_id=jobId)        log.info(f"job {job}")        if job is None:            return "è¯·å…ˆé…ç½®å®šæ—¶ä»»åŠ¡"        log.debug(f"next_run_time {job.next_run_time}")        t = job.next_run_time        if t:            return job.next_run_time        else:            return "è¯·å…ˆå¯åŠ¨ä»»åŠ¡"    async def set_switch(self, jobId: str, switch: bool):        job = self.scheduler.get_job(job_id=jobId)        if job:            if switch:                job.resume()            else:                job.pause()        return    async def shutdown(self):        if self.scheduler:            self.scheduler.shutdown()