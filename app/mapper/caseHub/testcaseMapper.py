#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/8/27# @Author : cyq# @File : testcaseMapper# @Software: PyCharm# @Desc:from typing import List, Dict, Any, Optional, Sequencefrom sqlalchemy import select, insert, update, and_, case, deletefrom sqlalchemy.ext.asyncio import AsyncSessionfrom app.mapper.caseHub.requirementMapper import RequirementMapperfrom app.mapper import Mapper, set_creatorfrom app.model import async_sessionfrom app.model.base import Userfrom app.model.caseHub.caseHUB import TestCase, TestCaseStep, CaseStepDynamicfrom app.model.caseHub.association import RequirementCaseAssociationfrom utils import logasync def transStepValue(action: str = None, expected_result: str = None) -> List[Dict[str, Optional[str]]]:    """    数据转换    'action': '1、输入用户名123\n2、输入密码123\n3、点击登录',    'expected_result': '1、登录成功',    """    if action is None and expected_result is None:        return [{"action": None, "expected_result": None}]    _act = None if action is None else action.strip().split("\n")    _exp = None if expected_result is None else expected_result.strip().split("\n")    _act_length = len(_act) if _act else 0    _exp_length = len(_exp) if _exp else 0    max_step = max(_act_length, _exp_length)    steps = []    for i in range(max_step):        steps.append(            {                "action": _act[i] if _act is not None and i < len(_act) else None,                "expected_result": _exp[i] if _exp is not None and i < len(_exp) else None,            }        )    return stepsasync def get_last_index(session: AsyncSession, requirementId: int) -> int:    try:        sql = (            select(RequirementCaseAssociation.order).where(                RequirementCaseAssociation.requirement_id == requirementId,            ).order_by(RequirementCaseAssociation.order.desc()).limit(1)        )        result = await session.execute(sql)        last_step_order = result.scalar()        return last_step_order or 0    except Exception as e:        raise easync def get_case_index(session: AsyncSession, requirementId: int, caseId: int) -> int:    try:        sql = (            select(RequirementCaseAssociation.order).where(                and_(                    RequirementCaseAssociation.requirement_id == requirementId,                    RequirementCaseAssociation.case_id == caseId,                )            )        )        result = await session.execute(sql)        order = result.scalar()        return order    except Exception as e:        raise easync def insert_requirement_case(session: AsyncSession, requirementId: int, caseId: int):    last_step_index = await get_last_index(session, requirementId)    await session.execute((insert(RequirementCaseAssociation).values(        dict(            requirement_id=requirementId,            case_id=caseId,            order=last_step_index + 1        )    )))    req = await RequirementMapper.get_by_id(ident=requirementId, session=session)    req.case_number += 1class TestCaseMapper(Mapper):    __model__ = TestCase    @classmethod    async def update_cases_common(cls, caseIds: List[int], project_id: int, module_id: int):        """        批量更新用例至用例库        set case_status = 1        """        try:            async with async_session() as session:                async with session.begin():                    await session.execute(                        update(cls.__model__).where(                            cls.__model__.id.in_(caseIds)                        ).values(                            is_common=True,                            project_id=project_id,                            module_id=module_id,                            case_status=0,                            is_review=True,                        )                    )        except Exception as e:            log.error(e)            raise e    @classmethod    async def update_cases_status(cls, caseIds: List[int], status: int, user: User):        """        批量更新用例状态        """        try:            async with async_session() as session:                async with session.begin():                    for case_id in caseIds:                        _case: TestCase = await cls.get_by_id(ident=case_id, session=session)                        await CaseDynamicMapper.update_dynamic(                            case_id=case_id,                            old_case={"case_status": _case.case_status},                            new_case={"case_status": status},                            session=session,                            cr=user                        )                    await session.execute(                        update(cls.__model__).where(                            cls.__model__.id.in_(caseIds)                        ).values(                            case_status=status                        )                    )        except Exception as e:            raise e    @classmethod    async def insert_upload_case(cls, cases: List[Dict[str, Any]], project_id: int, module_id: int,                                 user: User,                                 requirementId: int = None,                                 ):        """        附件用例插入数据库        1、 插入用例        2、 解析steps 插入步骤        3、 如果关联需求 插入中间表        4、 如果关联需求 case_number  += n        5、 用例动态 -        """        if not cases:            return        log.info(f"开始插入用例 {cases}")        try:            async with async_session() as session:                async with session.begin():                    case_objects = []                    all_steps = []                    requirement_case_associations = []                    last_step_order = 0                    if requirementId:                        last_step_order = await get_last_index(session, requirementId)                    for case_index, _case in enumerate(cases):                        action = _case.pop("action", None)                        expected_result = _case.pop("expected_result", None)                        # 用例                        _case.update({                            "project_id": project_id,                            "module_id": module_id,                            "case_type": 2,                            "case_status": 0,                            "creator": user.id,                            "creatorName": user.username,                        })                        # 创建用例对象但不立即插入                        case_obj = cls.__model__(**_case)                        case_objects.append(case_obj)                        # 子步骤                        steps = await transStepValue(action, expected_result)                        for step_index, _step in enumerate(steps):                            _step.update({                                "test_case_index": case_index,  # 用于后续关联                                "order": step_index,                                "creator": user.id,                                "creatorName": user.username,                            })                            all_steps.append(_step)                        if requirementId:                            # 准备需求用例关联                            last_step_order += 1                            requirement_case_associations.append(RequirementCaseAssociation                                (                                requirement_id=requirementId,                                case_id=case_index,                                order=last_step_order                            ))                    # 批量插入用例                    session.add_all(case_objects)                    await session.flush()  # 获取生成的ID                    # 关联步骤与用例ID                    case_id_map = {i: case_obj.id for i, case_obj in enumerate(case_objects)}                    # 批量插入步骤                    step_objects = []                    for step_data in all_steps:                        case_index = step_data.pop("test_case_index")                        step_data["test_case_id"] = case_id_map[case_index]                        step_objects.append(TestCaseStepMapper.__model__(**step_data))                    session.add_all(step_objects)                    if requirement_case_associations:                        rca = []                        for r in requirement_case_associations:                            r.case_id = case_id_map[r.case_id]                            rca.append(r)                        session.add_all(rca)                    if requirementId:                        req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                        req.case_number += len(case_objects)        except Exception as e:            raise e    @classmethod    async def remove_case(cls, caseId: int, requirementId: Optional[int]):        """        删除用例        删除与需求关联 && 删除用例库        requirementId ？ requirementId.cas_number -=1        """        try:            async with async_session() as session:                test_case: TestCase = await cls.get_by_id(ident=caseId, session=session)                if test_case.is_common:                    if requirementId:                        req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                        if req.case_number > 0:                            req.case_number -= 1                        delete(RequirementCaseAssociation).where(                            and_(                                RequirementCaseAssociation.requirement_id == requirementId,                                RequirementCaseAssociation.case_id == caseId                            )                        )                else:                    await session.execute(                        delete(cls.__model__).where(cls.__model__.id == caseId)                    )                await session.commit()        except Exception as e:            raise e    @classmethod    async def query_by_req(cls, requirementId: int):        """        需求查询用例        """        try:            async with async_session() as session:                cases = await session.scalars(select(TestCase).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ).order_by(RequirementCaseAssociation.order))                return cases.all()        except Exception as e:            raise e    @classmethod    async def query_case_by_field(cls, requirementId: int, **kwargs):        """        过滤用例        """        try:            async with async_session() as session:                conditions = await cls.search_conditions(**kwargs)                cases = await session.scalars(select(TestCase).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ).where(                    and_(                        *conditions                    )                ).order_by(RequirementCaseAssociation.order))                return cases.all()        except Exception as e:            raise e    @classmethod    async def query_tags(cls, requirementId: int):        try:            async with async_session() as session:                tags = await session.scalars(select(TestCase.case_tag).join(                    RequirementCaseAssociation,                    RequirementCaseAssociation.case_id == TestCase.id                ).where(                    RequirementCaseAssociation.requirement_id == requirementId                ))                result = tags.all()                return set(result)        except Exception as e:            raise e    @classmethod    async def save_case(cls, cr: User, requirementId: int = None, **kwargs):        """        存用例 & 用例步骤        写日志        关联需求判断        """        case_sub_steps = kwargs.pop("case_sub_steps", [])        kwargs = await set_creator(cr, **kwargs)        try:            async with async_session() as session:                async with session.begin():                    case: TestCase = await cls.save_no_session(session, **kwargs)                    if case_sub_steps:                        await TestCaseStepMapper.save_steps(caseId=case.id, steps=case_sub_steps,                                                            user=cr,                                                            session=session)                    if requirementId:                        await  insert_requirement_case(                            requirementId=requirementId,                            caseId=case.id,                            session=session                        )                    await CaseDynamicMapper.new_dynamic(                        cr=cr,                        case=case,                        session=session                    )                    return case        except Exception as e:            raise e    @classmethod    async def update_case(cls, ur: User, **kwargs):        """        用鳄梨更新        """        log.info(f"kwargs = {kwargs}")        try:            async with async_session() as session:                async with session.begin():                    case = await cls.get_by_id(ident=kwargs.get("id"), session=session)                    old_case = case.map                    new_case = await cls.update_cls(case, session, **kwargs)                    await CaseDynamicMapper.update_dynamic(                        cr=ur,                        case_id=case.id,                        old_case=old_case,                        new_case=new_case.map,                        session=session                    )        except Exception as e:            raise e    @classmethod    async def query_sub_steps(cls, case_id: int):        try:            async with async_session() as session:                steps = await session.scalars(select(TestCaseStep).where(                    TestCaseStep.test_case_id == case_id                ).order_by(TestCaseStep.order))                return steps.all()        except Exception as e:            raise e    @classmethod    async def reorder_case(cls, requirementId: int, caseIds: List[int]):        """        需求下case 重新排序        """        try:            async with async_session() as session:                whens = {step_id: index for index, step_id in enumerate(caseIds, start=0)}                await session.execute(update(RequirementCaseAssociation).where(                    and_(                        RequirementCaseAssociation.requirement_id == requirementId,                        RequirementCaseAssociation.case_id.in_(caseIds)                    )                ).values(                    order=case(whens, value=RequirementCaseAssociation.case_id)                ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def copy_case(cls, caseId: int, user: User, requirementId: Optional[int]):        """        复制用例        """        try:            async with async_session() as session:                async with session.begin():                    target_case: TestCase = await cls.get_by_id(ident=caseId, session=session)                    target_case_steps: Sequence[TestCaseStep] = await TestCaseStepMapper.query_steps_by_case_id(                        case_id=target_case.id,                        session=session)                    new_case = target_case.copy_map                    new_case['case_name'] = new_case['case_name'] + " - 副本"                    new_case['case_status'] = 0  # 重制为待执行                    new_case['creator'] = user.id                    new_case['creatorName'] = user.username                    new_case_obj = await cls.save_no_session(session=session, **new_case)                    for step in target_case_steps:                        new_step = step.copy_map                        new_step['test_case_id'] = new_case_obj.id                        new_step['creator'] = user.id                        new_step['creatorName'] = user.username                        await TestCaseStepMapper.save_no_session(session=session, **new_step)                    if requirementId:                        # 关联需求与排序。 order = target order + 1  后面的用例继续顺序排序                        req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                        req.case_number += 1                        case_index = await get_case_index(session, requirementId, target_case.id)                        log.debug(f"target case order  {case_index}")                        await session.execute(update(RequirementCaseAssociation).where(                            RequirementCaseAssociation.order > case_index                        ).values(order=RequirementCaseAssociation.order + 1))                        await session.execute((insert(RequirementCaseAssociation).values(                            dict(                                requirement_id=requirementId,                                case_id=new_case_obj.id,                                order=case_index + 1                            )                        )))                    await CaseDynamicMapper.new_dynamic(                        cr=user,                        case=new_case_obj,                        session=session                    )        except Exception as e:            raise e    @classmethod    async def add_default_case(cls, requirementId: int, user: User):        try:            async with async_session() as session:                async with session.begin():                    req = await RequirementMapper.get_by_id(ident=requirementId, session=session)                    req.case_number += 1                    tc = TestCase()                    await tc.set_default(user)                    tc.module_id = req.module_id                    tc.project_id = req.project_id                    await cls.add_flush_expunge(session=session, model=tc)                    last_step_index = await get_last_index(session, requirementId)                    await session.execute((insert(RequirementCaseAssociation).values(                        dict(                            requirement_id=requirementId,                            case_id=tc.id,                            order=last_step_index + 1                        )                    )))        except Exception as e:            raise eclass TestCaseStepMapper(Mapper):    __model__ = TestCaseStep    @classmethod    async def update_step(cls, user: User, id: int, **kwargs):        try:            async with async_session() as session:                async with session.begin():                    step: TestCaseStep = await cls.get_by_id(ident=id, session=session)                    before_info = {                        "action": step.action,                        "expected_result": step.expected_result                    }                    new_step = await cls.update_cls(step, session, **kwargs)                    after_info = {                        "action": new_step.action,                        "expected_result": new_step.expected_result                    }                    await CaseDynamicMapper.update_dynamic(                        cr=user,                        case_id=new_step.test_case_id,                        old_case=before_info,                        new_case=after_info,                        session=session                    )        except Exception as e:            raise    @classmethod    async def reorder_steps(cls, stepIds: List[int]):        """        用例下步骤重新排序        """        try:            async with async_session() as session:                for index, stepId in enumerate(stepIds, start=1):                    await session.execute(update(TestCaseStep).where(                        TestCaseStep.id == stepId                    ).values(                        order=index                    ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def copy_step(cls, stepId: int, user: User):        """        复制 步骤        order 1 复制  新order  + 1        :param stepId:        :param user:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    step: TestCaseStep = await cls.get_by_id(ident=stepId, session=session)                    # 后续步骤顺序排序                    await session.execute(                        update(TestCaseStep).where(                            and_(                                TestCaseStep.test_case_id == step.test_case_id,                                TestCaseStep.order > step.order                            )                        ).values(                            order=TestCaseStep.order + 1                        )                    )                    new_step = step.copy_map                    new_step['creator'] = user.id                    new_step['creatorName'] = user.username                    new_step["order"] = step.order + 1                    await cls.save_no_session(session=session, **new_step)        except Exception as e:            raise e    @classmethod    async def add_default_step(cls, caseId: int, user: User):        try:            async with async_session() as session:                last_order = await cls.get_last_order(caseId=caseId, session=session)                session.add(cls.__model__(                    test_case_id=caseId,                    # expected_result="请输入预期结果",                    # action="请输入操作步骤",                    order=last_order + 1,                    creator=user.id,                    creatorName=user.username                ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def save_steps(cls, caseId: int, steps: List[Dict[str, Any]], session: AsyncSession, user: User):        try:            for index, step in enumerate(steps):                step["test_case_id"] = caseId                step["order"] = index                step['creator'] = user.id                step['creatorName'] = user.username                await cls.save_no_session(session=session, **step)        except Exception as e:            raise e    @classmethod    async def query_steps_by_case_id(cls, case_id: int, session: AsyncSession) -> Sequence[TestCaseStep]:        try:            steps = await session.scalars(select(TestCaseStep).where(                TestCaseStep.test_case_id == case_id            ).order_by(TestCaseStep.order))            return steps.all()        except Exception as e:            raise e    @staticmethod    async def get_last_order(caseId: int, session: AsyncSession):        try:            stmt = await session.execute(select(TestCaseStep.order).where(                TestCaseStep.test_case_id == caseId            ).order_by(TestCaseStep.order.desc()).limit(1))            last_step_order = stmt.scalar()            return last_step_order or 0        except Exception as e:            raise eclass CaseDynamicMapper(Mapper):    __model__ = CaseStepDynamic    @classmethod    async def query_dynamic(cls, caseId: int):        """        获取用例动态        """        try:            async with async_session() as session:                dynamic = await session.scalars(select(CaseStepDynamic).where(                    CaseStepDynamic.test_case_id == caseId                ).order_by(CaseStepDynamic.create_time.asc()))                return dynamic.all()        except Exception as e:            raise e    @classmethod    async def new_dynamic(cls, cr: User, case: TestCase, session: AsyncSession):        """        首次创建动态写入        """        dynamicInfo = dict(            description=f"{cr.username} 创建了测试用例。 {case.case_name}",            test_case_id=case.id,            creator=cr.id,            creatorName=cr.username        )        await cls.save_no_session(session=session, **dynamicInfo)    @classmethod    async def update_dynamic(cls, cr: User, case_id: int, old_case: Dict[str, Any], new_case: Dict[str, Any],                             session: AsyncSession):        """        更新用例        """        diff_info = diff_dict(old_case, new_case)        if not diff_info:            return        updateInfo = f"{cr.username} 更新了测试用例 :{diff_info} "        dynamic_obj = CaseStepDynamic(            description=updateInfo,            test_case_id=case_id,            creator=cr.id,            creatorName=cr.username        )        session.add(dynamic_obj)        await session.flush()def diff_dict(old_case: Dict[str, Any], new_case: Dict[str, Any]) -> Optional[str]:    """比较两个字典的差异，生成变更描述列表"""    # 配置常量    IGNORE_KEYS = {"id", "uid", "create_time", "update_time", "creator", "creatorName", "updater", "updaterName"}    KEY_MAP = {        "action": "操作步骤",        "expected_result": "预期结果",        "case_name": "用例名称",        "case_level": "用例等级",        "case_type": "用例类型",        "case_tag": "用例标签",        "case_setup": "前置条件",        "case_status": "用例状态",        "case_mark": "用例描述",        "is_review": "是否审核",    }    diff_args = []    # 检查所有可能变更的键    all_keys = set(old_case.keys()) | set(new_case.keys())    relevant_keys = all_keys - IGNORE_KEYS    for key in relevant_keys:        old_value = old_case.get(key)        new_value = new_case.get(key)        # 跳过未变化的字段        if old_value == new_value:            continue        # 获取字段显示名称        field_name = KEY_MAP.get(key, key)        # 转换值显示        old_display = _transform_value(key, old_value)        new_display = _transform_value(key, new_value)        # 生成变更描述        if old_value is None:            diff_args.append(f"{field_name} 新增 {new_display}")        elif new_value is None:            diff_args.append(f"{field_name} 从 {old_display} 变更为 空")        elif new_value == old_value:            return None        else:            diff_args.append(f"{field_name} 从 {old_display} 变更为 {new_display}")    return "\n".join(diff_args)def _transform_value(field_key: str, value: Any) -> str:    """根据字段类型转换值的显示格式"""    if value is None:        return "空"    # 特定字段的值映射    VALUE_MAPPINGS = {        "case_type": {            1: "冒烟",            2: "普通"        },        "case_status": {            1: "成功",            2: "失败",            0: "待执行"        },        "is_review": {            True: "已评审",            False: "未评审"        }    }    # 应用值映射    if field_key in VALUE_MAPPINGS and value in VALUE_MAPPINGS[field_key]:        return VALUE_MAPPINGS[field_key][value]    # 处理列表类型（如标签）    if isinstance(value, list):        return "、".join(str(v) for v in value) if value else "空"    # 处理布尔值    if isinstance(value, bool):        return "是" if value else "否"    return str(value)