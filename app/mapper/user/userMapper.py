#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/6/6# @Author : cyq# @File : userMapper# @Software: PyCharm# @Desc:import timefrom typing import Listimport jwtfrom jwt.exceptions import ExpiredSignatureErrorfrom sqlalchemy import select, updatefrom app.exception import AuthErrorfrom config import Configfrom werkzeug.security import generate_password_hash, check_password_hashfrom app.mapper import Mapperfrom app.model import async_sessionfrom app.model.base import Userfrom enums import GenderEnumfrom utils import MyLogurufrom utils.fileManager import FileManagerlog = MyLoguru().get_logger()class UserMapper(Mapper):    __model__ = User    @classmethod    async def set_pwd(cls, old_password: str, new_password: str, user: User):        """        更新        """        try:            async with async_session() as session:                async with session.begin():                    if await cls.check_password(user.password, old_password):                        user.password = await cls.set_password(new_password)                    else:                        raise AuthError("密码错误")        except Exception as e:            raise e    @classmethod    async def set_avatar(cls, path: str, user: User):        """        写入头像地址        :param path:        :param user:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    await session.execute(                        update(User).where(User.id == user.id).values(avatar=path)                    )        except Exception as e:            raise e    @classmethod    async def get_avatar(cls, uid: str):        try:            async with async_session() as session:                user = cls.get_by_uid(uid, session)                return user.avatar        except Exception as e:            raise e    @classmethod    async def filter_user_by_username(cls, username: str) -> List[User]:        try:            async with async_session() as session:                sql = select(User).where(User.username.like(f"{username}%"))                exec = await session.execute(sql)                data = exec.scalars().all()                return data        except Exception as e:            raise e    @classmethod    async def register(cls,                       username: str,                       gender: GenderEnum,                       phone: str,                       isAdmin: bool = False,                       tagName: str = None):        """        管理注册用户        :param username:        :param gender:        :param phone:        :param isAdmin:        :param tagName:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    email = username + "@hub.com"                    user = await cls.get_by(session=session, email=email, phone=phone)                    if user:                        raise AuthError(f"用户 {username} 已存在")                    pwd_hash = await cls.set_password(username)                    session.add(User(username=username,                                     password=pwd_hash,                                     email=email,                                     phone=phone,                                     gender=gender,                                     isAdmin=isAdmin,                                     tagName=tagName,                                     # departmentName=depart.name,                                     # departmentID=depart.id                                     ))        except Exception as e:            raise e    @classmethod    async def public_register(cls,                             username: str,                             password: str,                             gender: GenderEnum,                             phone: str):        """        公开注册接口        :param username: 用户名        :param password: 密码        :param gender: 性别        :param phone: 手机号        :return: 用户ID        """        try:            async with async_session() as session:                async with session.begin():                    email = username + "@hub.com"                    if await cls.get_by(session=session, email=email):                        raise AuthError("账号已被注册")                    if await cls.get_by(session=session, phone=phone):                        raise AuthError("手机号已被注册")                    pwd_hash = await cls.set_password(password)                    user = User(                        username=username,                        password=pwd_hash,                        email=email,                        phone=phone,                        gender=gender,                        isAdmin=False                    )                    session.add(user)                    return user.id        except Exception as e:            raise e    @classmethod    async def register_admin(cls,                             username: str, phone="99999999999"):        """        注册ADMIN        :param username:        :param phone:        :return:        """        try:            async with async_session() as session:                _pwd_hash = await cls.set_password(username)                admin = User(username=username,                             email=username + "@hub.com",                             password=_pwd_hash,                             phone=phone,                             gender=GenderEnum.MALE,                             isAdmin=True,                             tagName="ADMIN",                             )                session.add(admin)                await session.commit()                return admin.id        except Exception as e:            raise e    @classmethod    async def login(cls, username: str, password: str):        """        用户登陆        :param username:        :param password:        :return:        """        try:            async with async_session() as session:                user = await cls.get_by(session=session, username=username)                if user:                    if await cls.check_password(user.password, password):                        return await cls.generate_token(user)                    else:                        raise AuthError("密码错误")                else:                    raise AuthError("用户不存在")        except Exception as e:            raise e    @staticmethod    async def set_password(password: str) -> str:        """hash 密码"""        return generate_password_hash(password)    @staticmethod    async def check_password(password_hash: str, password: str) -> bool:        """校验密码"""        return check_password_hash(password_hash, password)    @staticmethod    async def generate_token(user: User, expires_time: int = 3600 * 24 * 2) -> str:        """        生成token        param user 当前用户        param expires_time 超时时间        """        token = {"id": user.id,                 "isAdmin": user.isAdmin,                 "expires_time": time.time() + expires_time}        try:            return jwt.encode(token, Config.SECRET_KEY, algorithm="HS256")        except Exception:            raise AuthError("登录状态校验失败, 请重新登录")    @staticmethod    async def parse_token(token: str) -> dict:        """        解析token        :param token:        :return:        """        try:            return jwt.decode(token, Config.SECRET_KEY, algorithms=["HS256"])        except Exception:            raise AuthError("请重新登陆")