#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/7/2# @Author : cyq# @File : playCaseMapper# @Software: PyCharm# @Desc:import asynciofrom datetime import datetimefrom typing import List, Dict, Any, Typefrom app.mapper import Mapper, Tfrom app.model import async_sessionfrom app.model.base import Userfrom app.model.playUI import PlayCase, PlayCaseVariables, PlayCaseStepAssociation, PlayCaseResult, PlayStepfrom sqlalchemy.ext.asyncio import AsyncSessionfrom sqlalchemy import select, and_, update, delete, case, existsfrom app.mapper.play.playStepMapper import PlayStepMapperfrom enums.CaseEnum import Result, Statusfrom play.starter import UIStarterfrom utils import logfrom .common import get_case_step_last_index, insert_play_case_step_association__all__ = ["PlayCaseMapper",           "PlayCaseVariablesMapper",           "PlayCaseResultMapper"]from ..file import FileMapperfrom ...exception import NotFindclass PlayCaseMapper(Mapper):    __model__ = PlayCase    @classmethod    async def insert_choices_group_step(cls, caseId: int, choice_steps: List[int], cr: User = None):        """        插入组        """        return await cls.insert_choices_common_step(caseId, choice_steps, cr, True)    @classmethod    async def insert_choices_common_step(cls, caseId: int, choice_steps: List[int], cr: User = None,                                         quote: bool = False):        """        插入选择的公共 step        :param cr        :param choice_steps        :param caseId        :param quote 是否引用添加 否则复制添加        """        try:            async with async_session() as session:                async with session.begin():                    # 查询case                    play_case: PlayCase = await cls.get_by_id(ident=caseId, session=session)                    last_step_index = await get_case_step_last_index(session, caseId)                    if not quote:  # 复制添加                        for index, _step_id in enumerate(choice_steps, start=last_step_index + 1):                            step = await PlayStepMapper.copy_step(stepId=_step_id, cr=cr, copy_step_name=True,                                                                  is_common=False, session=session)                            if await insert_play_case_step_association(session, caseId, step.id, index):                                play_case.step_num += 1                    else:                        # 引用添加                        for index, stepId in enumerate(choice_steps, start=last_step_index + 1):                            if await insert_play_case_step_association(session, caseId, stepId, index):                                play_case.step_num += 1        except Exception as e:            raise e    @classmethod    async def insert_step(cls, caseId: int, cr: User, **kwargs):        """        case 插入 step        :param caseId:目标用例        :param cr:创建人        :param kwargs:step info        """        kwargs.update({            "creator": cr.id,            "creatorName": cr.username        })        try:            async with async_session() as session:                async with session.begin():                    play_case: PlayCase = await cls.get_by_id(ident=caseId, session=session)                    play_step: PlayStep = await PlayStepMapper.save_no_session(session=session, **kwargs)                    last_step_order = await get_case_step_last_index(session, caseId)                    flag = await insert_play_case_step_association(session, caseId, play_step.id, last_step_order + 1)                    if flag:                        play_case.step_num += 1        except Exception as e:            raise e    @classmethod    async def remove_step(cls, stepId: int, caseId: int = None):        """        caseId 为空 则是删除common step        caseId 不为空        判断是否 是公共        如果公共 查询所有中间表关联的CASE step-num -1        :param stepId:        :param caseId:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    # 查询步骤                    step: PlayStep = await PlayStepMapper.get_by_id(ident=stepId, session=session)                    if caseId:                        # 如果case id 传递 、则意味着删除关联、                        play_case: PlayCase = await cls.get_by_id(ident=caseId, session=session)                        if play_case.step_num > 0:  # 防止负数                            play_case.step_num -= 1                        # 删除关联表                        await session.execute(                            delete(PlayCaseStepAssociation).where(                                and_(                                    PlayCaseStepAssociation.play_step_id == stepId,                                    PlayCaseStepAssociation.play_case_id == caseId                                )                            )                        )                        # 如果step 不是公共步骤 、则删除步骤                        if not step.is_common_step:                            # 删除步骤                            await session.delete(step)                    else:                        # 查询关联                        cases: List[PlayCase] = await PlayStepMapper.query_case_by_step_id(                            stepId=stepId,                            session=session,                            need_order=False                        )                        if cases:                            for _case in cases:                                _case.step_num -= 1                        # 直接删除步骤                        await session.delete(step)        except Exception as e:            raise e    @classmethod    async def copy_case(cls, caseId: int, cr: User):        """        复制用例        复制 step        复制 vars        """        try:            async with async_session() as session:                async with session.begin():                    target_case: PlayCase = await cls.get_by_id(ident=caseId, session=session)                    target_steps: List[PlayStep] = await PlayStepMapper.query_steps_by_caseId(caseId=caseId,                                                                                              session=session)                    new_case = target_case.copy_map                    new_case['creator'] = cr.id                    new_case['creatorName'] = cr.username                    new_case_obj: PlayCase = await cls.save_no_session(session, **new_case)                    # 复制step                    copy_jobs = []                    for index, step in enumerate(target_steps, start=1):                        copy_jobs.append(                            cls._copy_step_and_association(play_step=step, play_case=new_case_obj, cr=cr, index=index,                                                           session=session)                        )                    await asyncio.gather(*copy_jobs)                    # 复制vars                    await PlayCaseVariablesMapper.copy_vars(target_caseId=caseId, new_caseId=new_case_obj.id, cr=cr,                                                            session=session)                    return new_case_obj        except Exception as e:            raise e    @classmethod    async def reorder_step(cls, caseId: int, stepIds: [int]):        """        根据steps 重新排序        """        try:            async with async_session() as session:                whens = {step_id: index for index, step_id in enumerate(stepIds, start=1)}                await session.execute(update(PlayCaseStepAssociation)                .where(                    and_(                        PlayCaseStepAssociation.play_step_id.in_(stepIds),                        PlayCaseStepAssociation.play_case_id == caseId                    )                )                .values(                    step_order=case(whens, value=PlayCaseStepAssociation.play_step_id)                ))                await session.commit()        except Exception as e:            raise e    @classmethod    async def copy_step(cls, caseId: int, stepId: int, cr: User):        """        复制步骤到底部        """        try:            async with async_session() as session:                play_case: PlayCase = await cls.get_by_id(ident=caseId, session=session)                new_step: PlayStep = await PlayStepMapper.copy_step(stepId=stepId, cr=cr, copy_step_name=False,                                                                    session=session)                last_step_order = await get_case_step_last_index(session, caseId)                flag = await insert_play_case_step_association(session, caseId, new_step.id, last_step_order + 1)                if flag:                    play_case.step_num += 1                await session.commit()        except Exception as e:            raise e    @classmethod    async def _copy_step_and_association(cls, play_step: PlayStep, play_case: PlayCase, cr: User, index: int,                                         session: AsyncSession):        """        复制step 建立 关联        """        new_step = await PlayStepMapper.copy_step(            stepId=play_step.id,            cr=cr,            copy_step_name=False,            session=session        )        await insert_play_case_step_association(            session=session,            caseId=play_case.id,            stepId=new_step.id,            step_order=index        )class PlayCaseVariablesMapper(Mapper):    __model__ = PlayCaseVariables    @classmethod    async def copy_vars(cls, target_caseId: int, new_caseId: int, session: AsyncSession, cr: User):        """        复制        :param target_caseId        :param new_caseId        :param session        :param cr        :return null        """        try:            exe = await session.execute(select(cls.__model__).where(                cls.__model__.play_case_id == target_caseId            ))            case_vars = exe.scalars().all()            if case_vars:                for var in case_vars:                    v = var.copy_map                    v['play_case_id'] = new_caseId                    v['creator'] = cr.id                    v['creatorName'] = cr.username                    await cls.save_no_session(session=session, **v)        except Exception as e:            raise e    @classmethod    async def insert(cls: Type[T], user: User, **kwargs) -> T:        """        插入数据        同一个case 校验 key 唯一        :param user        :param kwargs:        :return:        """        key = kwargs.get("key")        caseId = kwargs.get("play_case_id")        try:            async with async_session() as session:                await PlayCaseVariablesMapper._check_key(key, caseId, session)                await cls.save_no_session(session=session, **kwargs)                await session.commit()        except Exception as e:            raise e    @classmethod    async def update_by_id(cls: Type[T], updateUser: User = None, **kwargs):        """        更新        """        caseId = kwargs.get("play_case_id")        key = kwargs.get("key")        if not key:            return await super().update_by_id(updateUser=updateUser, **kwargs)        try:            async with async_session() as session:                await PlayCaseVariablesMapper._check_key(key, caseId, session)                return await super().update_by_id(updateUser=updateUser, session=session, **kwargs)        except Exception as e:            raise    @staticmethod    async def _check_key(key: str, caseId: int, session: AsyncSession):        key_exists = await session.execute(            select(PlayCaseVariables).where(and_(                PlayCaseVariables.key == key,                PlayCaseVariables.play_case_id == caseId            ))        )        if key_exists.scalar():            raise NotFind("key 已存在 请检查")        return Trueclass PlayCaseResultMapper(Mapper):    __model__ = PlayCaseResult    @classmethod    async def clear_case_result(cls, caseId: int):        """        清空case执行历史        """        try:            async with async_session() as session:                async with session.begin():                    # 查找失败结果 删除本地附件                    search_sql = select(cls.__model__.ui_case_err_step_pic_path).where(                        and_(                            cls.__model__.result == Result.FAIL,                            cls.__model__.ui_case_Id == caseId,                            cls.__model__.task_result_id is None                        )                    )                    data = await session.scalars(search_sql)                    datas = data.all()                    file_ids = [i.split("uid=")[-1] for i in datas if i]                    for i in file_ids:                        await FileMapper.remove_file(i, session)                    delete_sql = delete(cls.__model__).filter_by(ui_case_Id=caseId,                                                                 task_result_id=None)                    await session.execute(delete_sql)        except Exception as e:            session.rollback()            log.error(e)            raise e    @classmethod    async def init_case_result(cls,                               play_case: PlayCase,                               user: UIStarter,                               task_result_id: int = None) -> PlayCaseResult:        """        初始化用例结果模型        :param play_case: 运行case        :param user: 运行人        :param task_result_id:        :return:        """        try:            async with async_session() as session:                async with session.begin():                    result = PlayCaseResult(                        ui_case_Id=play_case.id,                        ui_case_name=play_case.title,                        ui_case_description=play_case.description,                        ui_case_step_num=play_case.step_num,                        starter_id=user.userId,                        starter_name=user.username,                        start_time=datetime.now(),                        task_result_id=task_result_id,                        status=Status.RUNNING,                        vars_info=[],                        asserts_info=[],                    )                    await cls.add_flush_expunge(session, result)                    return result        except Exception as e:            log.error(e)            raise e    @classmethod    async def set_case_result(cls, result: PlayCaseResult):        try:            async with async_session() as session:                async with session.begin():                    await cls.add_flush_expunge(session, result)                    return result        except Exception as e:            log.error(e)            raise e    @classmethod    async def set_case_result_assertInfo(cls, crId: int, assertsInfo: List[Dict[str, Any]]):        try:            async with async_session() as session:                update_sql = update(PlayCaseResult).where(PlayCaseResult.id == crId).values(                    asserts_info=assertsInfo)                await session.execute(update_sql)                await session.commit()        except Exception as e:            raise e    @classmethod    async def set_case_result_varsInfo(cls, crId: int, varsInfo: List[Dict[str, Any]]):        try:            async with async_session() as session:                update_sql = update(PlayCaseResult).where(PlayCaseResult.id == crId).values(                    vars_info=varsInfo)                await session.execute(update_sql)                await session.commit()        except Exception as e:            raise e