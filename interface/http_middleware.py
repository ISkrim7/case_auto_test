#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : sender# @Software: PyCharm# @Desc:import asyncioimport jsonimport osfrom typing import Any, Dict, TypeVar, Tuple, Optionalfrom httpx import Responsefrom app.mapper.interface import InterfaceGlobalHeaderMapperfrom app.model.interface import InterfaceModelfrom enums import InterfaceRequestTBodyTypeEnum, InterfaceRequestMethodEnumfrom utils import GenerateTools, MyLoguru, logfrom common.httpxClient import HttpxClientfrom utils.variableTrans import VariableTransfrom .starter import APIStarterimport mimetypesLOG = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)class HttpxMiddleware(HttpxClient):    def __init__(self, variables: VariableTrans, starter: APIStarter):        self.vr = variables        self.starter = starter        super().__init__(logger=self.starter.send)    async def __call__(self, url: str, interface: Interface, **kwargs) -> Response:        """执行HTTP请求"""        _request_data = await self.set_req_info(interface)        url = await self.vr.trans(url)        await self.starter.send(f"Request INFO : {json.dumps(_request_data, ensure_ascii=False, default=str)}")        return await super().__call__(method=interface.method.lower(), url=url, **_request_data)    async def set_req_info(self, interface: Interface) -> Dict[str, Any]:        """构建请求信息字典"""        _request_data = {            InterfaceRequestTBodyTypeEnum.HEADERS: {},            'follow_redirects': bool(interface.follow_redirects),            'read': interface.response_timeout,            'connect': interface.connect_timeout        }        # 处理headers        await self._process_headers(_request_data, interface)        # 根据请求方法处理参数或请求体        if interface.method == InterfaceRequestMethodEnum.GET:            await self._process_get_params(_request_data, interface)        else:            await self._process_request_body(_request_data, interface)        # 深度转换整个请求数据        _request_data = await self._deep_transform_data(_request_data)        # 规范化Headers        headers = _request_data[InterfaceRequestTBodyTypeEnum.HEADERS]        _request_data[InterfaceRequestTBodyTypeEnum.HEADERS] = self._normalize_headers(headers)        return _request_data    async def _deep_transform_data(self, data: Any) -> Any:        """递归地将变量转换委托给VariableTrans"""        if isinstance(data, dict):            return {k: await self._deep_transform_data(v) for k, v in data.items()}        elif isinstance(data, list):            return [await self._deep_transform_data(item) for item in data]        elif isinstance(data, tuple):            return tuple(await self._deep_transform_data(item) for item in data)        else:            return await self.vr.trans(data)    async def _process_headers(self, request_data: Dict[str, Any], interface: Interface) -> None:        """处理请求头信息"""        headers_lower = {}        # 获取全局headers        global_headers = await InterfaceGlobalHeaderMapper.query_all()        if global_headers:            for header in global_headers:                for key, value in header.map.items():                    headers_lower[key.lower()] = value        # 添加自定义headers        if interface.headers:            custom_headers = GenerateTools.list2dict(interface.headers)            for key, value in custom_headers.items():                headers_lower[key.lower()] = value        request_data[InterfaceRequestTBodyTypeEnum.HEADERS] = headers_lower        self._ensure_single_content_type(request_data[InterfaceRequestTBodyTypeEnum.HEADERS])    @staticmethod    async def _process_get_params(request_data: Dict[str, Any], interface: Interface) -> None:        """处理GET请求参数"""        if interface.params:            request_data[InterfaceRequestTBodyTypeEnum.PARAMS] = GenerateTools.list2dict(                interface.params            )    async def _process_request_body(self, request_data: Dict[str, Any], interface: Interface) -> None:        """处理非GET请求的请求体"""        content_type = request_data.get(InterfaceRequestTBodyTypeEnum.HEADERS, {}).get("content-type", "").lower()        # 特殊处理表单编码类型        if "application/x-www-form-urlencoded" in content_type and interface.body_type == 0 and interface.params:            form_data = await self.vr.trans(GenerateTools.list2dict(interface.params))            request_data.update({InterfaceRequestTBodyTypeEnum.FORM_DATA: form_data})            return        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null or interface.body is None:            return        result = await self._filter_request_body(interface)        if result is None or not isinstance(result, tuple) or len(result) != 2:            log.error("无效的请求体配置")            return        body_data, content_type = result        if content_type:            request_data[InterfaceRequestTBodyTypeEnum.HEADERS]["content-type"] = content_type        if body_data:            request_data.update(**body_data)    async def _filter_request_body(self, interface: Interface) -> Tuple[Dict[str, Any] | None, str | None]:        """根据接口请求体类型处理请求体数据"""        log.info(f"request body = {interface.body}")        log.info(f"request body_type = {interface.body_type}")        log.info(f"request raw_type = {interface.raw_type}")        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null or interface.body is None:            return None, None        match interface.body_type:            case InterfaceRequestTBodyTypeEnum.Raw:                if interface.raw_type == "json":                    if interface.body == {}:                        return (                            {InterfaceRequestTBodyTypeEnum.JSON: {}},                            "application/json"                        )                    transformed_body = await self.vr.trans(interface.body)                    if isinstance(transformed_body, (dict, list)):                        json_str = json.dumps(transformed_body, ensure_ascii=False, indent=None)                        return (                            {InterfaceRequestTBodyTypeEnum.Content: json_str},                            "application/json"                        )                    elif isinstance(transformed_body, str):                        return (                            {InterfaceRequestTBodyTypeEnum.Content: transformed_body},                            "application/json"                        )                    else:                        return (                            {InterfaceRequestTBodyTypeEnum.JSON: transformed_body},                            "application/json"                        )                elif interface.raw_type == "text":                    text_body = await self.vr.trans(interface.body)                    return (                        {InterfaceRequestTBodyTypeEnum.Content: text_body},                        "text/plain"                    )                else:                    log.warning(f"Unsupported raw type: {interface.raw_type}, defaulting to text")                    text_body = await self.vr.trans(interface.body)                    return (                        {InterfaceRequestTBodyTypeEnum.Content: str(text_body)},                        "text/plain"                    )            case InterfaceRequestTBodyTypeEnum.UrlEncoded:                form_data = await self.vr.trans(GenerateTools.list2dict(interface.data))                return (                    {InterfaceRequestTBodyTypeEnum.FORM_DATA: form_data},                    "application/x-www-form-urlencoded"                )            case InterfaceRequestTBodyTypeEnum.Data:                files = {}                datas = {}                data = GenerateTools.list2dict(interface.data)                for k, v in data.items():                    if str(v).startswith(str(interface.uid)):                        from utils.fileManager import API_DATA                        filepath = os.path.join(API_DATA, v)                        log.debug(f"filepath = {filepath}")                        try:                            if not os.path.exists(filepath):                                log.error(f"文件不存在: {filepath}")                                continue                            if not os.access(filepath, os.R_OK):                                log.error(f"文件不可读: {filepath}")                                continue                            mime_type, _ = mimetypes.guess_type(str(filepath))                            mime_type = mime_type or 'application/octet-stream'                            fileName = os.path.basename(filepath).split("_")[-1]                            with open(filepath, 'rb', encoding="utf-8") as f:                                if f:                                    files[k] = (k, f, mime_type)                                    log.debug(f"文件 {fileName} 已添加到上传列表，MIME类型 = {mime_type}")                                else:                                    log.error(f"无法打开文件 {filepath}")                                    continue                        except Exception as e:                            log.exception(f"处理文件 {filepath} 时出错: {str(e)}")                            continue                    else:                        datas[k] = await self.vr.trans(v)                return (                    {InterfaceRequestTBodyTypeEnum.FORM_FILES: files,                     InterfaceRequestTBodyTypeEnum.FORM_DATA: datas},                    None                )            case _:                log.warning(f"Unsupported body type: {interface.body_type}")                return None, None    def _normalize_headers(self, headers: Dict[str, Any]) -> Dict[str, Any]:        """规范化header键名，统一为小写"""        normalized = {}        for key, value in headers.items():            normalized[key.lower()] = value        content_type_keys = [k for k in normalized.keys() if k.lower() == "content-type"]        if content_type_keys:            final_value = normalized[content_type_keys[-1]]            for key in content_type_keys:                del normalized[key]            normalized["content-type"] = final_value        return normalized    def _ensure_single_content_type(self, headers: Dict[str, Any]) -> None:        """确保只有一个content-type头"""        if "content-type" in headers:            keys_to_remove = [k for k in headers.keys()                              if k.lower() == "content-type" and k != "content-type"]            for key in keys_to_remove:                del headers[key]