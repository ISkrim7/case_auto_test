#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : sender# @Software: PyCharm# @Desc:import asyncioimport ioimport jsonimport osfrom typing import Any, Dict, List, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface import InterfaceGlobalHeaderMapperfrom app.model.interface import InterfaceModelfrom enums import InterfaceRequestTBodyTypeEnum, InterfaceRequestMethodEnumfrom utils import GenerateTools, MyLoguru, logfrom common.fakerClient import FakerClientfrom common.httpxClient import HttpxClientfrom .starter import APIStarterfrom .mock import get_mock_managerimport reimport mimetypesLOG = MyLoguru().get_logger()f = FakerClient()Interface = TypeVar('Interface', bound=InterfaceModel)class HttpxMiddleware(HttpxClient):    def __init__(self, variables: Dict[str, Any], starter: APIStarter):        self.variables = variables        self.starter = starter        super().__init__(log=self.starter.send)    async def __call__(self, url: str, interface: Interface, **kwargs) -> Response:        """        :param interface        :return:        """        # 记录原始URL        #await self.starter.send(f"Original request URL: {url}")        _request_data = await self.set_req_info(interface)        # 仅转换非URL参数        # transformed_data = {        #     k: await self.transform_target(v) if not (k == 'url' and isinstance(v, str)) else v        #     for k, v in _request_data.items()        # }        #await self.starter.send(f"Request INFO : {json.dumps(transformed_data, ensure_ascii=False)}")        url = await self.transform_target(target=url)        await self.starter.send(f"Request INFO : {json.dumps(_request_data, ensure_ascii=False)}")        return await super().__call__(method=interface.method.lower(),                                      url=url,                                      **_request_data)        # 检查mock规则 - 使用原始URL        # mock_manager = await get_mock_manager(self.starter.userId)        # mock_resp = await mock_manager.mock_response(        #     url,        #     interface.method,        #     self.starter.userId,        #     mock_manager._session  # 使用mock_manager内部的session        # )        # if mock_resp:        #     await self.starter.send(f"Using mock response for {interface.method} {url}")        #     await self.starter.send(f"Mock rule applied for interface ID: {interface.id}")        #     return mock_resp        # # 转发请求 - 使用原始URL        # await self.starter.send(f"Forwarding request to: {url}")        # return await super().__call__(method=interface.method.lower(),        #                             url=url,        #                             **transformed_data)    async def transform_target(self, target: Any):        """        参数转换        数据转换        URL字符串不进行变量替换        """        # 如果是URL字符串，直接返回        # if isinstance(target, str) and (target.startswith('http://') or target.startswith('https://')):        #     return target        # 如果单纯字符串        if isinstance(target, str):            return await self._transformStr(target)        # 如果是字典        if isinstance(target, dict):            return await self._transFormObj(target)        # 如果是列表        if isinstance(target, list):            return await self._transFormList(target)        if isinstance(target, tuple):            return await self._transFormTuple(target)        if isinstance(target, (int, float, bool)):  # 保留原始数值类型            return target        if hasattr(target, 'read') and callable(target.read):  # 文件类型            return target        if hasattr(target, '__iter__'):  # 其他可迭代对象            return [await self.transform_target(item) for item in target]        else:            return target    async def _transformStr(self, target: str) -> str:        """结合两者优点的增强版"""        #print(f"_transformStr转换前: {target}")        # 优先处理 Faker 变量        if target.startswith("{{$") and target.endswith("}}"):            faker_key = target[3:-2].strip()            return FakerClient().value(faker_key)        # 严格模式替换        strict_pattern = r"\{\{\s*([a-zA-Z_$][\w$]*)\s*\}\}"        strict_replaced = re.sub(            strict_pattern,            lambda m: str(self.variables.get(m.group(1).strip(), m.group(0))),            target        )        # 宽松模式兜底        if strict_replaced == target:            return re.sub(                r"{{(.*?)}}",                lambda m: str(self.variables.get(m.group(1).strip(), m.group(0))),                target            )        print(f"转换后: {strict_replaced}")  # 调试日志        return strict_replaced    async def _transFormObj(self, target: Dict[str, Any]) -> Dict[str, Any]:        """        字典替换        :param target        """        return {key: await self.transform_target(value) for key, value in target.items()}    async def _transFormList(self, target: List[Any]) -> List[Any]:        """        列表替换        """        return [await self.transform_target(item) for item in target]    async def _transFormTuple(self, target: Tuple[Any, ...]) -> Tuple[Any, ...]:        """        元组替换        如果是附件 跳过        """        transformed_items = []        for item in target:            if isinstance(item, io.BufferedReader):                transformed_items.append(item)                continue            transformed = await self.transform_target(item)            transformed_items.append(transformed)        return tuple(transformed_items)    async def set_req_info(self, interface: Interface):        """        处理并构建HTTP请求信息        Args:            interface: 接口对象，包含请求方法、头信息、参数等        Returns:            包含完整请求信息的字典，可用于httpx等HTTP客户端        """        # 初始化请求数据字典        _request_data = {            InterfaceRequestTBodyTypeEnum.HEADERS: {},            'follow_redirects': bool(interface.follow_redirects),            'read': interface.response_timeout,            'connect': interface.connect_timeout        }        # 处理headers - 全局headers和自定义headers合并        await self._process_headers(_request_data, interface)        # 根据请求方法处理参数或请求体        if interface.method == InterfaceRequestMethodEnum.GET:            await self._process_get_params(_request_data, interface)        else:            await self._process_request_body(_request_data, interface)        # 并行转换请求数据中的变量        await self._transform_request_data(_request_data)        log.info("_request_data:",_request_data)        return _request_data    @staticmethod    async def _process_headers(request_data: Dict[str, Any], interface: Interface) -> None:        """处理请求头信息"""        # 获取全局headers        global_headers = await InterfaceGlobalHeaderMapper.query_all()        if global_headers:            for header in global_headers:                request_data[InterfaceRequestTBodyTypeEnum.HEADERS].update(header.map)        # 添加自定义headers        if interface.headers:            request_data[InterfaceRequestTBodyTypeEnum.HEADERS].update(                GenerateTools.list2dict(interface.headers)            )    @staticmethod    async def _process_get_params(request_data: Dict[str, Any], interface: Interface) -> None:        """处理GET请求参数"""        if interface.params:            request_data[InterfaceRequestTBodyTypeEnum.PARAMS] = GenerateTools.list2dict(                interface.params            )    async def _process_request_body(self, request_data: Dict[str, Any], interface: Interface) -> None:        """处理非GET请求的请求体"""        # ========== 新增特殊处理开始 ==========        # 获取Content-Type值（不区分大小写）        content_type = request_data.get(InterfaceRequestTBodyTypeEnum.HEADERS, {}).get("Content-Type", "").lower()        # 当Content-Type是表单编码但body_type=0时特殊处理        if "application/x-www-form-urlencoded" in content_type and interface.body_type == 0 and interface.params:            # 转换并处理params参数            form_data = await self.transform_target(                GenerateTools.list2dict(interface.params)            )            # 添加到FORM_DATA中            request_data.update({InterfaceRequestTBodyTypeEnum.FORM_DATA: form_data})            return        # 原有逻辑保持不变        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null or interface.body is None:            return None, None        #body_data, content_type = await self._filter_request_body(interface)        result = await self._filter_request_body(interface)        # 检查是否返回有效结果        if result is None or not isinstance(result, tuple) or len(result) != 2:            log.error("无效的请求体配置")            return        body_data, content_type = result        if content_type:            request_data[InterfaceRequestTBodyTypeEnum.HEADERS]["Content-Type"] = content_type        if body_data:            request_data.update(**body_data)    """要正确处理多级嵌套参数（如 'projectName': '{{ts}}{{currentDay}}'），必须使用实例方法方案，    才能通过 self.transform_target 实现递归式变量替换。静态方法方案因无法访问实例的转换方法，    会导致变量替换失败。    """    #@staticmethod    async def _filter_request_body(self, interface: Interface) -> Tuple[Dict[str, Any] | None, str | None]:    #async def _filter_request_body(self, interface: Interface) -> Tuple[Dict, str]:    #async def _filter_request_body(interface: Interface) -> Tuple[Dict[str, Any] | None, str | None]:        """根据接口请求体类型处理请求体数据        Args:            interface: 接口对象，包含请求体相关数据        Returns:            Tuple[处理后的请求体字典, Content-Type字符串]            如果不需要请求体则返回 (None, None)        """        # 确保记录 raw_type 用于调试        log.info(f"request body = {interface.body}")        log.info(f"request body_type = {interface.body_type}")        log.info(f"request raw_type = {interface.raw_type}")        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null or interface.body is None:            return None, None        match interface.body_type:            case InterfaceRequestTBodyTypeEnum.Raw:                if interface.raw_type == "json":                    # 空对象特殊处理                    if interface.body == {}:                        return (                            {InterfaceRequestTBodyTypeEnum.JSON: {}},                            "application/json"                        )                    transformed_body = await self.transform_target(interface.body)                    # 自动处理不同类型                    if isinstance(transformed_body, (dict, list)):                        return (                            {InterfaceRequestTBodyTypeEnum.JSON: transformed_body},                            "application/json"                        )                    # 如果是字典类型，直接作为json参数                    if isinstance(transformed_body, dict):                        return (                            {InterfaceRequestTBodyTypeEnum.JSON: transformed_body},                            "application/json"                        )                    # 如果是字符串类型，作为content参数                    elif isinstance(transformed_body, str):                        return (                            {InterfaceRequestTBodyTypeEnum.Content: transformed_body},                            "application/json"                        )                    # 其他类型转换为JSON字符串                    else:                        return (                            #{InterfaceRequestTBodyTypeEnum.JSON: interface.body},                            #{InterfaceRequestTBodyTypeEnum.JSON: transformed_body},                            {InterfaceRequestTBodyTypeEnum.JSON: json.dumps(transformed_body)},                            "application/json"                        )                elif interface.raw_type == "text":                    text_body = await self.transform_target(interface.body)                    return (                        #{InterfaceRequestTBodyTypeEnum.Content: json.dumps(interface.body)},                        {InterfaceRequestTBodyTypeEnum.Content: text_body},                        "text/plain"                    )                else:                    log.warning(f"Unsupported raw type: {interface.raw_type}, defaulting to text")                    text_body = await self.transform_target(interface.body)                    return (                        {InterfaceRequestTBodyTypeEnum.Content: str(text_body)},                        "text/plain"                    )            case InterfaceRequestTBodyTypeEnum.UrlEncoded:                log.info("...InterfaceRequestTBodyTypeEnum.UrlEncoded....")                form_data = await self.transform_target(                    GenerateTools.list2dict(interface.data)                )                return (                    #{InterfaceRequestTBodyTypeEnum.FORM_DATA: GenerateTools.list2dict(interface.data)},                    {InterfaceRequestTBodyTypeEnum.FORM_DATA: form_data},                    "application/x-www-form-urlencoded"                )            case InterfaceRequestTBodyTypeEnum.Data:                ## todo file类型                files = {}                datas = {}                data = GenerateTools.list2dict(interface.data)                for k, v in data.items():                    # 附件类型                    if str(v).startswith(str(interface.uid)):                        from utils.fileManager import API_DATA                        filepath = os.path.join(API_DATA, v)                        log.debug(f"filepath = {filepath}")                        try:                            # 确保文件存在并可读                            if not os.path.exists(filepath):                                log.error(f"文件不存在: {filepath}")                                continue                            if not os.access(filepath, os.R_OK):                                log.error(f"文件不可读: {filepath}")                                continue                            # 获取文件的 MIME 类型                            mime_type, _ = mimetypes.guess_type(str(filepath))                            mime_type = mime_type or 'application/octet-stream'  # 默认类型                            fileName = os.path.basename(filepath).split("_")[-1]                            with open(filepath, 'rb', encoding="utf-8") as f:                                if f:                                    files[k] = (k, f, mime_type)                                    log.debug(f"文件 {fileName} 已添加到上传列表，MIME类型 = {mime_type}")                                else:                                    log.error(f"无法打开文件 {filepath}")                                    continue                        except Exception as e:                            log.exception(f"处理文件 {filepath} 时出错: {str(e)}")                            continue                    else:                        #datas[k] = v                        datas[k] = await self.transform_target(v)  # 转换非文件字段                return (                    {InterfaceRequestTBodyTypeEnum.FORM_FILES: files,                     InterfaceRequestTBodyTypeEnum.FORM_DATA: datas},                    None  # Content-Type将由httpx自动设置                )            case _:                log.warning(f"Unsupported body type: {interface.body_type}")                return None, None    async def _transform_request_data(self, request_data: Dict[str, Any]) -> None:        """深度递归转换所有请求数据"""        transform_queue = asyncio.Queue()        for key, value in request_data.items():            await transform_queue.put((request_data, key, value))        while not transform_queue.empty():            parent, key, value = await transform_queue.get()            transformed = await self.transform_target(value)            if isinstance(transformed, dict):                for k, v in transformed.items():                    await transform_queue.put((transformed, k, v))            elif isinstance(transformed, list):                for i, item in enumerate(transformed):                    await transform_queue.put((transformed, i, item))            parent[key] = transformed