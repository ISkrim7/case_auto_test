#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : sender# @Software: PyCharm# @Desc:import asyncioimport jsonimport osfrom typing import Any, Dict, TypeVar, Tuple, Optionalfrom app.mapper.interface import InterfaceGlobalHeaderMapperfrom app.model.interface import InterfaceModelfrom enums import InterfaceRequestTBodyTypeEnum, InterfaceRequestMethodEnumfrom utils import GenerateTools, MyLoguru, logfrom common.httpxClient import HttpxClientfrom utils.variableTrans import VariableTransfrom .starter import APIStarterimport mimetypesLOG = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)class HttpxMiddleware(HttpxClient):    """    httpx 处理请求信息    替换变量    """    def __init__(self, variables: VariableTrans, starter: APIStarter):        self.vr = variables        self.starter = starter        super().__init__(logger=self.starter.send)    async def set_req_info(self, interface: Interface):        """        处理并构建HTTP请求信息        Args:            interface: 接口对象，包含请求方法、头信息、参数等        Returns:            包含完整请求信息的字典，可用于httpx等HTTP客户端        """        # 初始化请求数据字典        _request_data = {            'read': interface.response_timeout,            'connect': interface.connect_timeout,            'follow_redirects': bool(interface.follow_redirects),            InterfaceRequestTBodyTypeEnum.HEADERS: await self._prepare_headers(interface),  # 处理请求头        }        # 根据请求方法处理参数或请求体        if interface.method == InterfaceRequestMethodEnum.GET:  # GET            await self._process_get_params(_request_data, interface)        else:            await self._process_request_body(_request_data, interface)        # 并行转换请求数据中的变量        await self._transform_request_data(_request_data)        return _request_data    @staticmethod    async def _prepare_headers(interface: Interface) -> Dict[str, str]:        """准备请求头（合并全局和接口特定头）"""        headers = {}        # 添加全局头        global_headers = await InterfaceGlobalHeaderMapper.query_all()        for header in global_headers:            headers.update(header.map)        # 添加接口特定头        if interface.headers:            headers.update(GenerateTools.list2dict(interface.headers))        return headers    @staticmethod    async def _process_get_params(_request_data: Dict[str, Any], interface: Interface) -> None:        """处理GET请求参数"""        if interface.params:            _request_data[InterfaceRequestTBodyTypeEnum.PARAMS] = GenerateTools.list2dict(interface.params)    async def _process_request_body(self, request_data: Dict[str, Any], interface: Interface) -> None:        """处理非GET请求的请求体"""        if not interface.body_type or interface.body_type == InterfaceRequestTBodyTypeEnum.Null:            return        body_data, content_type = await self._filter_request_body(interface)        if content_type:            request_data[InterfaceRequestTBodyTypeEnum.HEADERS]["Content-Type"] = content_type        if body_data:            request_data.update(**body_data)    async def _filter_request_body(self, interface: Interface) -> Tuple[Dict[str, Any] | None, str | None]:        """根据接口请求体类型处理请求体数据        Args:            interface: 接口对象，包含请求体相关数据        Returns:            Tuple[处理后的请求体字典, Content-Type字符串]            如果不需要请求体则返回 (None, None)        """        log.info(f"request body = {interface.body}")        log.info(f"request body_type = {interface.body_type}")        match interface.body_type:            case InterfaceRequestTBodyTypeEnum.Raw:                return await self._prepare_raw_body(interface)            case InterfaceRequestTBodyTypeEnum.UrlEncoded:                return await self._prepare_form_urlencoded(interface)            case InterfaceRequestTBodyTypeEnum.Data:                return await self._prepare_form_data(interface)            case _:                log.warning(f"Unsupported body type: {interface.body_type}")                return None, None    async def _transform_request_data(self, request_data: Dict[str, Any]) -> None:        """并行转换请求数据中的变量"""        transform_tasks = [            self.vr.trans(value)            for value in request_data.values()            if value is not None        ]        transformed_values = await asyncio.gather(*transform_tasks)        for key, value in zip(request_data.keys(), transformed_values):            if value is not None:                request_data[key] = value    @staticmethod    async def _prepare_raw_body(interface: Interface) -> Tuple[Dict[str, Any], str]:        """准备原始请求体（JSON/Text）"""        if interface.raw_type == "json":            return (                {InterfaceRequestTBodyTypeEnum.JSON: interface.body},                "application/json"            )        else:  # text            return (                {InterfaceRequestTBodyTypeEnum.Content: json.dumps(interface.body)},                "text/plain"            )    @staticmethod    async def _prepare_form_urlencoded(interface: Interface) -> Tuple[Dict[str, Any], str]:        """准备URL编码表单数据"""        form_data = GenerateTools.list2dict(interface.data)        return (            {InterfaceRequestTBodyTypeEnum.FORM_DATA: GenerateTools.list2dict(interface.data)},            "application/x-www-form-urlencoded"        )    async def _prepare_form_data(self, interface: Interface) -> Tuple[Dict[str, Any], Optional[str]]:        """准备多部分表单数据（支持文件上传）"""        files = {}        data = {}        form_data = GenerateTools.list2dict(interface.data)        for key, value in form_data.items():            # 附件类型            if str(value).startswith(str(interface.uid)):                file_info = await self._prepare_file_upload(key, value)                if file_info:                    files[key] = file_info            else:                data[key] = value        return (            {InterfaceRequestTBodyTypeEnum.FORM_FILES: files,             InterfaceRequestTBodyTypeEnum.FORM_DATA: data},            None  # Content-Type将由httpx自动设置        )    @staticmethod    async def _prepare_file_upload(key: str, value: Any) -> Optional[Tuple]:        """准备文件上传数据"""        from utils.fileManager import API_DATA        files = {}        filepath = os.path.join(API_DATA, value)        log.debug(f"filepath = {filepath}")        try:            # 确保文件存在并可读            if not os.path.exists(filepath):                log.error(f"文件不存在: {filepath}")                return            if not os.access(filepath, os.R_OK):                log.error(f"文件不可读: {filepath}")                return            # 获取文件的 MIME 类型            mime_type, _ = mimetypes.guess_type(str(filepath))            mime_type = mime_type or 'application/octet-stream'  # 默认类型            fileName = os.path.basename(filepath).split("_")[-1]            with open(filepath, 'rb', encoding="utf-8") as f:                if f:                    files[key] = (key, f, mime_type)                    log.debug(f"文件 {fileName} 已添加到上传列表，MIME类型 = {mime_type}")                else:                    log.error(f"无法打开文件 {filepath}")                    return None        except Exception as e:            log.exception(f"处理文件 {filepath} 时出错: {str(e)}")            return None