#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : execFunc# @Software: PyCharm# @Desc:import asyncioimport textwrapfrom typing import List, Mapping, Any, Dictimport timefrom datetime import datetime, timedeltafrom faker import Fakerfrom httpx import Responsefrom utils import MyLoguru, GenerateToolsdef get_vars(content: str) -> List[str]:    """    获取变量    """    import re    pattern = r'(\w+)\s*='    matches = re.findall(pattern, content)    variables = [match.strip() for match in matches]    return variablesclass TargetOPT:    Before = "4"    After = "3"class ExecScriptForInterface:    _faker = Faker(locale="zh_CN")    _script: str    def __init__(self,                 response: Response = None,                 log: Any = None):        self.response = response        self.variables = {}        if log is None:            self.log = MyLoguru().get_logger()        else:            self.log = log        self.local_vars = {"log": self.log.info,                           "response": self.response,                           "timestamp": self.__timeStamp,                           "faker": self._faker,                           "getVar": self.get_var,                           "date": self.__calculate_date}    def exec_script(self, script: str) -> Dict[str, Any]:        """        执行前置方法        :param script        """        self._script = script        self.log.info(f" 🚩🚩🚩🚩 开始执行前置方法 🚩🚩🚩🚩")        _vars = get_vars(script)        self._exec(_vars)        self.log.info(f"前置方法执行完成 ✅✅✅✅\n")        return self.variables    def get_var(self, key):        for k, v in self.variables.items():            if k == key:                return v        return None    def _exec(self, varList):        try:            print(self.local_vars['log'])            exec(self._script, self.local_vars)        except Exception as e:            self.log.exception(e)            self.log.info(f"执行方法报错 <{str(e)}>")        for variable_name, variable_value in self.local_vars.items():            if variable_name in varList and isinstance(variable_value, (int, str, dict, tuple, set, bool)):                obj = {variable_name: variable_value}                self.log.info(f"方法 变量 👉👉👉👉: {obj}")                self.variables.update(obj)                self.log.info(self.variables)    @staticmethod    def __timeStamp(t: str = None) -> int | None:        """        返回对应时间戳（秒级）        ：param t +1s 秒  +1m 分 +1h小时        """        if t is None:            return int(time.time())  # 修改为返回秒级        ts = int(t[1:-1])        unit = t[-1]        base_time = datetime.now().timestamp()        if t.startswith("+"):            match unit:                case "s":                    return int(base_time) + ts                case "m":                    return int(base_time + ts * 60)                case "h":                    return int(base_time + ts * 3600)        elif t.startswith("-"):            match unit:                case "s":                    return int(base_time) - ts                case "m":                    return int(base_time - ts * 60)                case "h":                    return int(base_time - ts * 3600)        else:            return None    @staticmethod    def __calculate_date(t: str = None) -> str | None:        current_date = datetime.today().strftime("%Y-%m-%d")        if not t:            return current_date        ts = int(t[1:-1])        if t.startswith("+"):            delta = {"d": timedelta(days=ts),                     "m": timedelta(weeks=ts * 4),                     "y": timedelta(days=ts * 365)}            return (datetime.today() + delta[t[-1]]).strftime("%Y-%m-%d")        elif t.startswith("-"):            delta = {"d": timedelta(days=ts),                     "m": timedelta(weeks=ts * 4),                     "y": timedelta(days=ts * 365)}            return (datetime.today() - delta[t[-1]]).strftime("%Y-%m-%d")        else:            return None