#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : execFunc# @Software: PyCharm# @Desc:import asyncioimport textwrapfrom typing import List, Mapping, Any, Dictimport timefrom datetime import datetime, timedeltafrom faker import Fakerfrom httpx import Responsefrom utils import MyLoguru, GenerateToolsdef get_vars(content: str) -> List[str]:    """    è·å–å˜é‡    """    import re    pattern = r'(\w+)\s*='    matches = re.findall(pattern, content)    variables = [match.strip() for match in matches]    return variablesclass TargetOPT:    Before = "4"    After = "3"class ExecScriptForInterface:    _faker = Faker(locale="zh_CN")    _script: str    def __init__(self,                 response: Response = None,                 log: Any = None):        self.response = response        self.variables = {}        if log is None:            self.log = MyLoguru().get_logger()        else:            self.log = log        self.local_vars = {"log": self.log.info,                           "response": self.response,                           "timestamp": self.__timeStamp,                           "faker": self._faker,                           "getVar": self.get_var,                           "date": self.__calculate_date}    def exec_script(self, script: str) -> Dict[str, Any]:        """        æ‰§è¡Œå‰ç½®æ–¹æ³•        :param script        """        self._script = script        self.log.info(f" ğŸš©ğŸš©ğŸš©ğŸš© å¼€å§‹æ‰§è¡Œå‰ç½®æ–¹æ³• ğŸš©ğŸš©ğŸš©ğŸš©")        _vars = get_vars(script)        self._exec(_vars)        self.log.info(f"å‰ç½®æ–¹æ³•æ‰§è¡Œå®Œæˆ âœ…âœ…âœ…âœ…\n")        return self.variables    def get_var(self, key):        for k, v in self.variables.items():            if k == key:                return v        return None    def _exec(self, varList):        try:            print(self.local_vars['log'])            exec(self._script, self.local_vars)        except Exception as e:            self.log.exception(e)            self.log.info(f"æ‰§è¡Œæ–¹æ³•æŠ¥é”™ <{str(e)}>")        for variable_name, variable_value in self.local_vars.items():            if variable_name in varList and isinstance(variable_value, (int, str, dict, tuple, set, bool)):                obj = {variable_name: variable_value}                self.log.info(f"æ–¹æ³• å˜é‡ ğŸ‘‰ğŸ‘‰ğŸ‘‰ğŸ‘‰: {obj}")                self.variables.update(obj)                self.log.info(self.variables)    @staticmethod    def __timeStamp(t: str = None) -> int | None:        """        è¿”å›å¯¹åº”æ—¶é—´æˆ³        ï¼šparam t +1s ç§’  +1m åˆ† +1håˆ†é’Ÿ        """        if t is None:            return int(time.time() * 1000)        ts = int(t[1:-1])        unit = t[-1]        if t.startswith("+"):            match unit:                case "s":                    return int(time.time()) + int(ts[:-1])                case "m":                    return int((datetime.now() + timedelta(minutes=int(ts[:-1]))).timestamp())                case "h":                    return int((datetime.now() + timedelta(hours=int(ts[:-1]))).timestamp())        elif t.startswith("-"):            match unit:                case "s":                    return int(time.time()) - int(ts[:-1])                case "m":                    return int((datetime.now() - timedelta(minutes=int(ts[:-1]))).timestamp())                case "h":                    return int((datetime.now() - timedelta(hours=int(ts[:-1]))).timestamp())        else:            return None    @staticmethod    def __calculate_date(t: str = None) -> str | None:        current_date = datetime.today().strftime("%Y-%m-%d")        if not t:            return current_date        ts = int(t[1:-1])        if t.startswith("+"):            delta = {"d": timedelta(days=ts),                     "m": timedelta(weeks=ts * 4),                     "y": timedelta(days=ts * 365)}            return (datetime.today() + delta[t[-1]]).strftime("%Y-%m-%d")        elif t.startswith("-"):            delta = {"d": timedelta(days=ts),                     "m": timedelta(weeks=ts * 4),                     "y": timedelta(days=ts * 365)}            return (datetime.today() - delta[t[-1]]).strftime("%Y-%m-%d")        else:            return None