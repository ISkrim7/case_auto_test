#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : execAssert# @Software: PyCharm# @Desc:from jmespath.exceptions import LexerErrorfrom app.schema.interface.interfaceApiSchema import IAssertfrom enums.CaseEnum import ExtraEnum, AssertTargetEnumfrom utils import MyLoguru, JsonExtractfrom utils.assertsUtil import MyAssertsfrom utils.transform import Transformfrom httpx import Responsefrom typing import List, Mapping, Any, Dictimport refrom json import JSONDecodeErrorlog = MyLoguru().get_logger()class ExecAsserts:    """    执行断言    """    err = {        "actual": None,        "result": False    }    def __init__(self, response: Response = None, variables: Dict = None):        log.info(f"var = {variables}")        self.variables = variables        self.response = response    async def __call__(self, asserts_info: List[Mapping[str, Any]]):        """        """        if not asserts_info:            return []        asserts_result = []        for assertion in asserts_info:            _assert = IAssert(**assertion)            log.info(_assert.model_dump())            if _assert.assert_switch is False:                continue            _assert_result = await self.invoke(_assert)            asserts_result.append({**_assert.model_dump(), **_assert_result})        return asserts_result    async def invoke(self, assertInfo: IAssert):        """        断言执行        :param assertInfo 断言目标        """        # 变量转换        expect_value = await self.set_expect_value(assertInfo.assert_value)        assertInfo.assert_value = expect_value        match assertInfo.assert_target:            case AssertTargetEnum.StatusCode:  # 状态码断言                return await self.assert_status_code(assertInfo)            case AssertTargetEnum.ResponseText:  # 文本断言                return await self.assert_response_text(assertInfo)            case AssertTargetEnum.ResponseBody:  # body断言                return await self.assert_response_json(assertInfo)            case AssertTargetEnum.ResponseHeader:  # header断言                return await self.assert_response_header(assertInfo)    async def assert_status_code(self, assertInfo: IAssert):        """        响应吗 断言        """        return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, self.response.status_code)    async def assert_response_text(self, assertInfo: IAssert):        """        响应 文本断言        assertInfo 只支持re 正则        """        if assertInfo.assert_extract != ExtraEnum.RE or not assertInfo.assert_text:            log.error(f"断言方法 {assertInfo.assert_extract} 不能对响应文本进行断言 或 断言语法为空！")            return        target = self.response.text        match = re.search(assertInfo.assert_text, target)        actual = match.group(1) if match else None        return self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)    async def assert_response_json(self, assertInfo: IAssert):        """        响应 Json断言        assertInfo jsonpath jmespath        """        if assertInfo.assert_extract not in [ExtraEnum.JMESPATH, ExtraEnum.JSONPATH] or not assertInfo.assert_text:            log.error(f"断言方法 {assertInfo.assert_extract} 不能对响应Json进行断言 或 断言语法为空！")            return self.err        try:            target = self.response.json()            actual = await self.__json_extract(target, assertInfo.assert_text, assertInfo.assert_extract)            return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)        except Exception as e:            log.error(e)            return self.err    async def assert_response_header(self, assertInfo: IAssert):        """        响应 Header断言        参数提取只支持 jsonpath jmespath        """        if assertInfo.assert_extract != ExtraEnum.JSONPATH or assertInfo.assert_extract != ExtraEnum.JMESPATH or not assert_text:            log.error(f"断言方法 {assertInfo.assert_extract} 不能对响应Json进行断言 或 断言语法为空！")        try:            target = self.response.headers            actual = await self.__json_extract(target, assertInfo.assert_text, assertInfo.assert_extract)            return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)        except JSONDecodeError:            log.warning(f"响应 {self.response.text} 非JSON 、无法提取")            target = None            return    @staticmethod    async def __assert(assert_opt: str, expect: Any, actual: Any):        _ = {            "actual": actual,            "result": False        }        try:            MyAsserts.option(assert_opt, expect, actual)            _['result'] = True            return _        except AssertionError as e:            log.error(e)            return _    @staticmethod    async def __json_extract(target: Any, assert_text: str, assert_extract: str):        actual = None        jp = JsonExtract(target, assert_text)        match assert_extract:            case ExtraEnum.JSONPATH:                try:                    actual = await jp.value()                    log.debug(f"JSONPATH 提取结果: {actual}")                except JSONDecodeError:                    log.warning(f"JSONPATH 提取失败")                    actual = None            case ExtraEnum.JMESPATH:                try:                    actual = jp.search()                    log.debug(f"JMESPATH 提取结果: {actual}")                except LexerError as e:                    log.warning(f"JMESPATH 提取失败")                    actual = "非法JMESPATH语法 或提取变量失败"        return actual    async def set_expect_value(self, assert_value: str):        t = Transform(self.variables)        return await t.transform_target(assert_value)