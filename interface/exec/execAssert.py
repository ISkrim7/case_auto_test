#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/22# @Author : cyq# @File : execAssert# @Software: PyCharm# @Desc:from jmespath.exceptions import LexerErrorfrom app.schema.interface.interfaceApiSchema import IAssertfrom enums.CaseEnum import ExtraEnum, AssertTargetEnumfrom utils import MyLoguru, JsonExtractfrom utils.assertsUtil import MyAssertsfrom utils.transform import Transformfrom httpx import Responsefrom typing import List, Mapping, Any, Dictimport refrom json import JSONDecodeErrorlog = MyLoguru().get_logger()class ExecAsserts:    """    执行断言    """    err = {        "actual": None,        "result": False    }    def __init__(self, response: Response = None, variables: Dict = None):        log.info(f"var = {variables}")        self.variables = variables        self.response = response    async def __call__(self, asserts_info: List[Mapping[str, Any]]):        """        """        if not asserts_info:            return []        asserts_result = []        for assertion in asserts_info:            _assert = IAssert(**assertion)            log.info(_assert.model_dump())            if _assert.assert_switch is False:                continue            _assert_result = await self.invoke(_assert)            if isinstance(_assert_result, dict):                asserts_result.append({**_assert.model_dump(), **_assert_result})            else:                log.error(f"断言结果类型错误: {type(_assert_result)}")                asserts_result.append({**_assert.model_dump(), "actual": None, "result": False})        return asserts_result    async def invoke(self, assertInfo: IAssert):        """        断言执行        :param assertInfo 断言目标        """        # 变量转换        expect_value = await self.set_expect_value(assertInfo.assert_value)        assertInfo.assert_value = expect_value        match assertInfo.assert_target:            case AssertTargetEnum.StatusCode:  # 状态码断言                return await self.assert_status_code(assertInfo)            case AssertTargetEnum.ResponseText:  # 文本断言                return await self.assert_response_text(assertInfo)            case AssertTargetEnum.ResponseBody:  # body断言                return await self.assert_response_json(assertInfo)            case AssertTargetEnum.ResponseHeader:  # header断言                return await self.assert_response_header(assertInfo)    async def assert_status_code(self, assertInfo: IAssert):        """        响应吗 断言        """        return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, self.response.status_code)    async def assert_response_text1(self, assertInfo: IAssert):        """        响应 文本断言        assertInfo 只支持re 正则        """        if assertInfo.assert_extract != ExtraEnum.RE or not assertInfo.assert_text:            log.error(f"断言方法 {assertInfo.assert_extract} 不能对响应文本进行断言 或 断言语法为空！")            return self.err        target = self.response.text        match = re.search(assertInfo.assert_text, target)        actual = match.group(1) if match else None        return self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)    async def assert_response_text(self, assertInfo: IAssert):        """        响应 文本断言        assertInfo 只支持re 正则        """        if assertInfo.assert_extract != ExtraEnum.RE or not assertInfo.assert_text:            log.error(f"断言方法 {assertInfo.assert_extract} 无效或表达式为空")            return self.err        target = self.response.text        actual = None        try:            # ===== 动态正则增强处理 =====            # 正则表达式增强处理逻辑优化（修改部分标注★）            enhanced_pattern = (                assertInfo.assert_text                # 关键增强点：精确匹配目标字段层级 ★                .replace('code":', r'"code"\s*:')  # 强制匹配完整键名                # 优化字符集限制 ★                .replace('(.*?)', r'([^,}{]+)')    # 限定匹配非结构字符                # 保留原始增强逻辑                .replace('": "', r'"\s*:\s*"')                .replace('":"', r'"\s*:\s*"')                .replace('"', r'\"?')            )            # 新增正则优先级策略 ★            if "code" in enhanced_pattern:                enhanced_pattern = enhanced_pattern.replace(                    r'([^,}{]+)',                    r'(\d+)', 1  # 针对code字段限定数字匹配                )            # 自动优化通用匹配模式            if "(.*?)" in enhanced_pattern:                #enhanced_pattern = enhanced_pattern.replace("(.*?)", r"([\w-]+)")  # 改用安全字符集                enhanced_pattern = enhanced_pattern.replace(                    "(.*?)",                    r"([\s\S]*?)"  # 匹配包括换行在内的任意字符                )            # 编译带增强功能的表达式            pattern = re.compile(                enhanced_pattern,                re.IGNORECASE | re.DOTALL            )            # ===== 增强处理结束 =====            match = pattern.search(target)            if match:                # 智能分组处理                if pattern.groups >= 1:                    actual = match.group(1)                else:                    actual = match.group()                log.debug(f"动态匹配成功 | 原始表达式: {assertInfo.assert_text} | 增强后: {enhanced_pattern} | 结果: {actual}")            else:                log.error(f"【匹配失败分析】\n原始表达式: {assertInfo.assert_text}\n增强后表达式: {enhanced_pattern}\n目标文本起始: {target[:200]}...")        except re.error as e:            log.error(f"正则表达式错误 | 原始表达式: {assertInfo.assert_text} | 错误详情: {str(e)}")            return {"actual": "REGEX_ERROR", "result": False}        except IndexError as e:            log.error(f"分组提取失败 | 表达式分组数: {pattern.groups} | 错误: {str(e)}")            return {"actual": "GROUP_ERROR", "result": False}        return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)    async def assert_response_json(self, assertInfo: IAssert):        """        响应 Json断言        assertInfo jsonpath jmespath        """        if assertInfo.assert_extract not in [ExtraEnum.JMESPATH, ExtraEnum.JSONPATH] or not assertInfo.assert_text:            log.error(f"assert_response_json {assertInfo.assert_extract} 不能对响应Json进行断言 或 断言语法为空！")            return self.err        try:            target = self.response.json()            actual = await self.__json_extract(target, assertInfo.assert_text, assertInfo.assert_extract)            return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)        except Exception as e:            log.error(e)            return self.err    async def assert_response_header(self, assertInfo: IAssert):        """        响应 Header断言        参数提取只支持 jsonpath jmespath        """        if assertInfo.assert_extract not in [ExtraEnum.JMESPATH, ExtraEnum.JSONPATH] or not assertInfo.assert_text:            log.error(f"assert_response_header {assertInfo.assert_extract} 不能对响应。Json进行断言 或 断言语法为空！")            return self.err        try:            target = dict(self.response.headers)            log.info(f"assert_response_header= {target}")            actual = await self.__json_extract(target, assertInfo.assert_text, assertInfo.assert_extract)            return await self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)        except JSONDecodeError:            log.warning(f"响应 {self.response.text} 非JSON 、无法提取")            return self.err    @staticmethod    async def __assert(assert_opt: str, expect: Any, actual: Any):        _ = {            "actual": actual,            "result": False        }        try:            MyAsserts.option(assert_opt, expect, actual)            _['result'] = True            return _        except AssertionError as e:            log.error(e)            return _    @staticmethod    async def __json_extract(target: Any, assert_text: str, assert_extract: str):        actual = None        log.info(f"__json_extract target {target}")        jp = JsonExtract(target, assert_text)        match assert_extract:            case ExtraEnum.JSONPATH:                try:                    actual = await jp.value()                except JSONDecodeError:                    log.warning(f"JSONPATH 提取失败")                    actual = None            case ExtraEnum.JMESPATH:                try:                    actual = jp.search()                except LexerError as e:                    log.warning(f"JMESPATH 提取失败")                    actual = "非法JMESPATH语法 或提取变量失败"        return actual    async def set_expect_value(self, assert_value: str):        t = Transform(self.variables)        return await t.transform_target(assert_value)