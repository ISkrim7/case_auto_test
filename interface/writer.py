#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/26# @Author : cyq# @File : writer# @Software: PyCharm# @Desc:from typing import Mapping, Any, List, Tuple, Optionalimport jsonfrom httpx import Responsefrom app.mapper.interface import InterfaceResultMapper, InterfaceTaskResultMapper, InterfaceCaseResultMapperfrom app.model.interface import InterfaceModel, InterFaceCaseModel, InterfaceCaseResultModel, InterfaceTask, \    InterfaceTaskResultModelfrom enums import InterfaceAPIResultEnum, InterfaceAPIStatusEnumfrom interface.starter import APIStarterfrom utils import MyLogurufrom datetime import datetimelog = MyLoguru().get_logger()def calculate_time_difference(a: str):    # 将字符串格式的时间转换为 datetime 对象    time_a = datetime.strptime(a, '%Y-%m-%d %H:%M:%S')    # 获取当前时间    time_b = datetime.now()    # 计算时间差    time_diff = time_b - time_a    # 获取小时、分钟、秒和微秒    seconds = time_diff.total_seconds()    hours = int(seconds // 3600)    minutes = int((seconds % 3600) // 60)    seconds = seconds % 60    # 格式化秒数到小数点后 2 位    formatted_time = f"{hours:02}:{minutes:02}:{seconds:05.2f}"    return formatted_timeclass InterfaceAPIWriter:    @staticmethod    async def init_interface_case_result(starter: APIStarter,                                         interfaceCase: InterFaceCaseModel,                                         taskId: int = None) -> InterfaceCaseResultModel:        """        初始化        :param taskId:  run by task        :param starter:        :param interfaceCase:        :return:        """        init_info = dict(            interfaceCaseID=interfaceCase.id,            interfaceCaseName=interfaceCase.title,            interfaceCaseUid=interfaceCase.uid,            interfaceCaseDesc=interfaceCase.desc,            interfaceCaseProjectId=interfaceCase.project_id,            interfaceCaseModuleId=interfaceCase.module_id,            total_num=interfaceCase.apiNum,            starterId=starter.userId,            starterName=starter.username,            status=InterfaceAPIStatusEnum.RUNNING        )        if taskId:            init_info['interface_task_result_Id'] = taskId        return await InterfaceCaseResultMapper.init(**init_info)    @staticmethod    async def init_interface_task(interfaceTask: InterfaceTask, starter: APIStarter) -> InterfaceTaskResultModel:        """        初始化接口测试任务。        该异步静态方法用于初始化一个接口测试任务，并将任务相关信息以及启动者信息        组织成一个字典，最后通过 `InterfaceTaskResultMapper.init()` 方法初始化并返回        接口测试任务结果模型。        参数:        - interfaceTask: InterfaceTask 类型的对象，包含了接口测试任务的相关信息。        - starter: Starter 类型的对象，包含了启动任务的用户的相关信息。        返回:        返回一个 InterfaceTaskResultModel 类型的对象，该对象是根据传入的任务信息和        启动者信息初始化得到的接口测试任务结果模型。        """        # 创建一个字典来存储初始化任务所需的信息        init_task = dict(            taskId=interfaceTask.id,            taskUid=interfaceTask.uid,            taskName=interfaceTask.title,            interfaceProjectId=interfaceTask.project_id,            interfaceModuleId=interfaceTask.module_id        )        # 将启动者的相关信息添加到任务字典中        init_task['startBy'] = starter.startBy        init_task['starterName'] = starter.username        init_task['starterId'] = starter.userId        # 使用组织好的任务字典来初始化并返回接口测试任务结果模型        return await InterfaceTaskResultMapper.init(**init_task)    @staticmethod    async def write_process(caseResult: InterfaceCaseResultModel):        """写进度"""        return await InterfaceCaseResultMapper.set_result_field(caseResult)    @staticmethod    async def set_interface_result_info(            startTime: str,            starter: APIStarter,            interface: InterfaceModel,            response: Response | str = None,            asserts: List[Mapping[str, Any]] = None,            caseResult: InterfaceCaseResultModel = None,            variables: List[Mapping[str, Any]] = None,            after_sql_result: Optional[str] = None,  # 新增            after_vars: Optional[dict] = None,        # 新增            taskResult: InterfaceTaskResultModel = None) -> Tuple[Mapping[str, Any], bool]:        """        写结果        :param starter： 执行人        :param startTime： 请求时间记录        :param interface: 接口实体        :param response: 响应结果对象        :param variables: 变量        :param asserts:断言信息        :param taskResult: 任务结果实例        :param caseResult: 用例结果实例        """        flag = True        # 确保startTime是有效的datetime字符串        from datetime import datetime        if not startTime or startTime.strip() == '':            startTime = datetime.now().strftime("%Y-%m-%d %H:%M:%S")        _interfaceBaseInfo = dict(            startTime=startTime,            interfaceID=interface.id,            interfaceName=interface.name,            interfaceUid=interface.uid,            #interfaceDesc=interface.desc,            interfaceDesc=interface.description,  # ✅ 直接取完整描述            starterId=starter.userId,            starterName=starter.username,            interfaceProjectId=interface.project_id,            interfaceModuleId=interface.module_id,            interfaceEnvId=interface.env_id        )        if taskResult:            _interfaceBaseInfo['interface_task_result_Id'] = taskResult.id        if caseResult:            _interfaceBaseInfo['interface_case_result_Id'] = caseResult.id        _response = {            'extracts': variables or [],            'asserts': asserts or [],            'result': InterfaceAPIResultEnum.SUCCESS,            #'after_sql_result': json.dumps(after_sql_result) if after_sql_result else None,            #'after_vars': json.dumps(after_vars) if after_vars else None,            #"after_sql_result": after_sql_result,  # 直接存储Python对象            #"after_vars": after_vars,               # 无需json.dumps            'after_sql_result': json.dumps(                after_sql_result,                default=str,          # 处理datetime等无法序列化的对象                ensure_ascii=False    # 允许非ASCII字符            ) if after_sql_result else None,            'after_vars': json.dumps(                after_vars,                default=str,                ensure_ascii=False            ) if after_vars else None,            'request_method': interface.method.upper()        }        if isinstance(response, str):            _response['response_status'] = 500            _response['response_txt'] = response            _response['result'] = InterfaceAPIResultEnum.ERROR            flag = False        elif isinstance(response, Response):            _response[                'result'] = InterfaceAPIResultEnum.SUCCESS if response.status_code == 200 else InterfaceAPIResultEnum.ERROR            _response['response_status'] = response.status_code            _response['response_txt'] = response.text            _response['response_head'] = dict(response.headers)            _response['request_head'] = dict(response.request.headers)            # 记录请求URL和请求体            request_url = str(response.request.url)            request_txt_parts = [f"Request URL: {request_url}"]            # 重构请求信息记录逻辑            request_info = []            # 新增请求体处理逻辑            try:                # 获取原始请求体字节并解码                #request_content = response.request.content                # 确保始终包含请求URL                request_url = str(response.request.url)                request_info.append(f"Method: {interface.method.upper()}")                request_info.append(f"URL: {request_url}")                # 处理请求头                #request_headers = "\n".join([f"{k}: {v}" for k, v in response.request.headers.items()])                #request_info.append(f"Headers:\n{request_headers}")                # 处理请求体                try:                    if response.request.content:                        try:                            request_body = response.request.content.decode('utf-8', errors='replace')                            request_info.append(f"Body:\n{request_body}")                        except UnicodeDecodeError:                            binary_info = f"[Binary Content {len(response.request.content)} bytes]"                            request_info.append(binary_info)                except AttributeError:                    pass  # GET请求没有content属性                _response['request_txt'] = "\n\n".join(request_info)                #_response['request_txt'] = request_content.decode('utf-8', errors='replace')            except AttributeError:                # 处理没有请求体的情况（如GET请求）                _response['request_txt'] = ""            #except UnicodeDecodeError:                # 处理非文本内容（如图片等二进制数据）                #_response['request_txt'] = f"[Binary Content {len(request_content)} bytes]"            except Exception as e:                log.error(f"请求信息记录失败: {str(e)}")                _response['request_txt'] = f"Error: {str(e)}"            _response['useTime'] = response.elapsed.total_seconds()            flag = response.status_code == 200        if asserts:            for i in asserts:                if i['result'] is False:                    flag = False                    _response['result'] = InterfaceAPIResultEnum.ERROR                    break        if asserts and not all(item.get('result') for item in asserts):            flag = False            _response['result'] = InterfaceAPIResultEnum.ERROR        return {**_interfaceBaseInfo, **_response}, flag    @staticmethod    async def write_interface_result(**kwargs):        """写入api结果"""        return await InterfaceResultMapper.set_result(**kwargs)    @staticmethod    async def write_interface_case_result1(caseResult: InterfaceCaseResultModel):        """写结果"""        if caseResult.fail_num == 0:            caseResult.result = InterfaceAPIResultEnum.SUCCESS        caseResult.useTime = calculate_time_difference(caseResult.map['startTime'])        caseResult.status = InterfaceAPIStatusEnum.OVER        return await InterfaceCaseResultMapper.set_result_field(caseResult)    @staticmethod    async def write_interface_case_result(caseResult: InterfaceCaseResultModel):        """写结果（最终修正版）"""        # 结果判断保持原逻辑        if caseResult.fail_num == 0:            caseResult.result = InterfaceAPIResultEnum.SUCCESS        else:            caseResult.result = InterfaceAPIResultEnum.ERROR        # 强制状态设置        caseResult.status = InterfaceAPIStatusEnum.OVER        caseResult.useTime = calculate_time_difference(caseResult.map['startTime'])        # 精准日志截断（解决多字节问题）        if caseResult.interfaceLog:            max_bytes = 65535 - 50  # 预留50字节给截断标记            byte_content = caseResult.interfaceLog.encode('utf-8')            # 精确字节级截断            if len(byte_content) > max_bytes:                # 保留有效UTF8字节                safe_bytes = byte_content[:max_bytes]                while len(safe_bytes) > 0:                    try:                        # 尝试解码验证有效性                        safe_bytes.decode('utf-8')                        break                    except UnicodeDecodeError:                        # 去除最后一个无效字节                        safe_bytes = safe_bytes[:-1]                # 重构日志内容                caseResult.interfaceLog = safe_bytes.decode('utf-8', 'ignore') + "\n[超过%d字节已截断]" % len(byte_content)        # 保持原有存储方式        return await InterfaceCaseResultMapper.set_result_field(caseResult)    @staticmethod    async def write_interface_task_result(taskResult: InterfaceTaskResultModel):        """写任务最终结果"""        taskResult.progress = 100        taskResult.totalUseTime = calculate_time_difference(taskResult.map['start_time'])        taskResult.status = InterfaceAPIStatusEnum.OVER        taskResult.end_time = datetime.now()        return await InterfaceTaskResultMapper.set_result_field(taskResult)    @staticmethod    async def write_task_process(task_result: InterfaceTaskResultModel):        """写任务进度"""        return await InterfaceTaskResultMapper.set_result_field(task_result)