import asyncioimport jsonfrom typing import List, Dict, Any, Mapping, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.interface.interfaceVarsMapper import InterfaceVarsMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.mapper.project.env import EnvMapperfrom app.model.interface import InterfaceModel, InterfaceCaseResultModel, InterFaceCaseModel, InterfaceTaskResultModel, \    InterfaceVariablesfrom app.model.interface.InterfaceCaseStepContent import InterfaceCaseStepContent, InterfaceConditionfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnum, \    InterfaceCaseErrorStepfrom enums.CaseEnum import CaseStepContentTypefrom play.starter import UIStarterfrom utils import MyLoguru, GenerateToolsfrom app.mapper.interface import InterfaceMapper, InterfaceConditionMapper, InterfaceGroupResultMapper, \    InterfaceConditionResultMapperfrom app.mapper.interface.interfaceCaseMapper import InterfaceCaseMapperfrom utils.execDBScript import ExecDBScriptfrom interface.exec import *from utils.variableTrans import VariableTransfrom .middleware import HttpxMiddlewarefrom .starter import APIStarterfrom .writer import InterfaceAPIWriterlog = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)InterfaceCase = TypeVar('InterfaceCase', bound=InterFaceCaseModel)Interfaces = List[Interface]InterFaceCases = List[InterfaceCaseStepContent]class InterFaceRunner:    response: Response | str = None    def __init__(self, starter: APIStarter | UIStarter):        self.starter = starter        self.vars = VariableTrans()        self.sender = HttpxMiddleware(self.vars, self.starter)    async def execute_interface_by_ui(self, interface: Interface, ui_vars: Dict[str, Any] | None = None):        """        ui ä¾§æ‰§è¡Œæ¥å£        :param interfaceï¼šæ¥å£å¯¹è±¡        :param ui_vars: ui å˜é‡        """        if ui_vars:            await self.vars.add_vars(ui_vars)        result, _ = await self.__execute_interface(interface)        return result, _    async def try_interface(self, interface: int) -> Mapping[str, Any]:        """        æ‰§è¡Œå•ä¸ªæ¥å£è¯·æ±‚è°ƒè¯•        æ— å˜é‡ã€æœ‰å‰ç½®æ–¹æ³•ã€        éœ€è¦è¿”å›response        """        interface = await InterfaceMapper.get_by_id(ident=interface)        result, _ = await self.__execute_interface(interface)        return result    async def get_interface(self, interfaceId: int, use_var: bool = False):        """è·å–æ¥å£ä¿¡æ¯"""        interface: Interface = await InterfaceMapper.get_by_id(ident=interfaceId)        # è‡ªå®šä¹‰ç¯å¢ƒ        if interface.env_id == -1:            from utils import Tools            parse = Tools.parse_url(interface.url)            url = parse.path            host = f"{parse.scheme}://{parse.netloc}"        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            host = env.host            url = interface.url            if env.port:                host += f":{env.port}"        if use_var:            # 1ã€å‰ç½®å˜é‡å‚æ•°            await self.__exec_before_params(interface.before_params)            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            await self.__exec_script(interface.before_script)            # 3.å‰ç½®sql            await self.__exec_before_sql(interface)            url = await self.vars.trans(target=url)        info = await self.sender.set_req_info(interface)        info.pop("follow_redirects")        info.pop("read")        info.pop("connect")        return {            "name": interface.name,            "method": interface.method.lower(),            "url": url,            "host": host,            "asserts": interface.asserts,            **info        }    async def try_group(self, groupId: int):        """        æ‰§è¡Œæ¥å£ç»„        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=groupId)        results = []        for interface in interfaces:            await self.starter.send(f"âœï¸âœï¸  Execute    {interface}")            result, _ = await self.__execute_interface(interface)            results.append(result)        return results    async def run_interface_by_task(self, interface: Interface, taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œapi"""        result, _ = await self.__execute_interface(interface=interface, taskResult=taskResult)        await InterfaceAPIWriter.write_interface_result(**result)        return _    async def run_interCase(self, interfaceCaseId: int, task: InterfaceTaskResultModel = None):        """        æ‰§è¡Œæ¥å£ç”¨ä¾‹        """        # æŸ¥è¯¢ç”¨ä¾‹        interfaceCase: InterfaceCase = await InterfaceCaseMapper.get_by_id(ident=interfaceCaseId)        if not interfaceCase:            await self.starter.send(f"æœªæ‰¾åˆ°ç”¨ä¾‹ {interfaceCaseId}")            return await self.starter.over()        # æŸ¥è¯¢ç”¨ä¾‹æ­¥éª¤å†…å®¹        case_steps: InterFaceCases = await InterfaceCaseMapper.query_content(case_id=interfaceCaseId)        await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"æŸ¥è¯¢åˆ°å…³è”Step x {len(case_steps)} ...")        if not case_steps:            await self.starter.send("æ— å¯æ‰§è¡Œæ­¥éª¤ï¼Œç»“æŸæ‰§è¡Œ")            return await self.starter.over()        # åŠ è½½ç”¨ä¾‹ä¸“å±å˜é‡        # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœå¯¹è±¡        await self.__init_interface_case_vars(interfaceCase)        log.info(f"__init_interface_case_vars = {self.vars}")        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         task=task,                                                                         starter=self.starter)        log.info(f"init_interface_case_result = {caseResult}")        flag = True        try:            for index, _step_content in enumerate(case_steps, start=1):                await self.starter.send(f"âœï¸âœï¸  EXECUTE_STEP {index} ï¼š {_step_content}")                caseResult.progress = round(index / len(case_steps), 2) * 100                log.debug(f"caseResult  progress= {caseResult.progress}")                # æ­¥éª¤å¼€å…³æ—¨åœ¨ ç”¨ä¾‹è°ƒè¯•ä¸­ä½¿ç”¨ ä»»åŠ¡æ‰§è¡Œé»˜è®¤å¼€å¯                if _step_content.enable == 0 and not task:                    await self.starter.send(f"âœï¸âœï¸  EXECUTE_STEP {index} ï¼š è°ƒè¯•ç¦ç”¨ è·³è¿‡æ‰§è¡Œ")                    continue                # å¦‚æœ flag å·²ç»æ˜¯ False ä¸”éœ€è¦é”™è¯¯åœæ­¢ï¼Œåˆ™è·³è¿‡åç»­æ­¥éª¤                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    await self.starter.send(f"â­ï¸â­ï¸  SKIP_STEP {index} ï¼š é‡åˆ°é”™è¯¯å·²åœæ­¢")                    continue                step_result = True                match _step_content.content_type:                    # æ‰§è¡Œå•æ¥å£                    case CaseStepContentType.STEP_API:                        step_result = await self.__execute_single_api(interface_id=_step_content.target_id,                                                                      case_result=caseResult)                    # æ‰§è¡Œæ¥å£ç»„                    case CaseStepContentType.STEP_API_GROUP:                        step_result = await self.__execute_group_apis(case_step=_step_content,                                                                      case_result=caseResult)                    # æ‰§è¡Œæ¡ä»¶çš†è‹¦                    case CaseStepContentType.STEP_API_CONDITION:                        step_result = await  self.__execute_condition_apis(case_step=_step_content,                                                                           case_result=caseResult)                    # æ‰§è¡Œç­‰å¾…                    case CaseStepContentType.STEP_API_WAIT:                        await self.starter.send(f"â°â°  ç­‰å¾… {_step_content.api_wait_time} ç§’")                        await asyncio.sleep(_step_content.api_wait_time)                        continue                    # æ‰§è¡Œè„šæœ¬                    case CaseStepContentType.STEP_API_SCRIPT:                        await self.__exec_script(script=_step_content.api_script_text)                        continue                # ä¸€æ—¦ flag å˜ä¸º Falseï¼Œå°±ä¸å†å˜å› True                flag = flag and step_result                # é‡åˆ°é”™åœæ­¢                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    caseResult.progress = 100                await InterfaceAPIWriter.write_process(caseResult=caseResult)                await self.starter.send(f"âœ…âœ…ï¸ FINISH STEP {index} ï¼š {_step_content}")                await self.starter.send(f"\n")            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return flag        except Exception as e:            log.error(e)            return False        finally:            await self.vars.clear()            await self.starter.over(caseResult.id)    async def __execute_single_api(self, interface_id: int, case_result: InterfaceCaseResultModel):        """        apiç±»å‹ç”¨ä¾‹æ‰§è¡Œ        """        interface: Interface = await InterfaceMapper.get_by_id(ident=interface_id)        result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)        await InterfaceAPIWriter.write_interface_result(**result)        if flag:            case_result.success_num += 1        else:            case_result.result = InterfaceAPIResultEnum.ERROR            case_result.fail_num += 1        return flag    async def __execute_condition_apis(self, case_step: InterfaceCaseStepContent,                                       case_result: InterfaceCaseResultModel):        """        é€»è¾‘ APIæ‰§è¡Œ        :param case_result ç”¨ä¾‹ç»“æœæ¨¡å‹        :param case_step  ç”¨ä¾‹æ­¥éª¤        """        condition: InterfaceCondition = await InterfaceConditionMapper.get_by_id(ident=case_step.target_id)        _execCondition = ExecCondition(self.vars)        flag = await _execCondition.invoke(condition, self.starter)        # é€»è¾‘é€šè¿‡ æ‰§è¡Œå­æ­¥éª¤        if flag:            condition_apis = await InterfaceConditionMapper.query_condition_apis_by_content_id(condition.id)            condition_result = await InterfaceConditionResultMapper.init_model(                condition_name=_execCondition.doc,                condition_api_num=len(condition_apis),                interface_case_result_id=case_result.id            )            log.info(f"condition_result  init {condition_result}")            if len(condition_apis) == 0:                return            for index, interface in enumerate(condition_apis, start=1):                await self.starter.send(f"âœï¸âœï¸  execute Condition Step {index} : {interface} ")                result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)                await InterfaceAPIWriter.write_interface_result(                    interface_condition_result_id=condition_result.id,                    **result)                # æŠ¥é”™åœæ­¢                if not flag:                    case_result.result = InterfaceAPIResultEnum.ERROR                    case_result.fail_num += 1                    return False        case_result.success_num += 1        return True    async def __execute_group_apis(self, case_step: InterfaceCaseStepContent,                                   case_result: InterfaceCaseResultModel):        """        ç»„å†… APIæ‰§è¡Œ        :param case_result ç”¨ä¾‹ç»“æœæ¨¡å‹        :param case_step  ç”¨ä¾‹æ­¥éª¤        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=case_step.target_id)        if not interfaces:            return        # åˆå§‹åŒ–GROUP RESULT        group_result = await InterfaceGroupResultMapper.init_model(            group_name=case_step.content_name,            group_api_num=len(interfaces),            interface_case_result_id=case_result.id        )        log.info(f"group result init {group_result}")        for index, interface in enumerate(interfaces, start=1):            await self.starter.send(f"âœï¸âœï¸  EXECUTE GROUP STEP {index} : {interface}")            result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)            # å†™APIç»“æœ å…³è”Group result            await InterfaceAPIWriter.write_interface_result(interface_group_result_id=group_result.id, **result)            # æŠ¥é”™åœæ­¢            if not flag:                case_result.result = InterfaceAPIResultEnum.ERROR                case_result.fail_num += 1                return False        case_result.success_num += 1        return True    async def __execute_interface(self,                                  interface: InterfaceModel,                                  caseResult: InterfaceCaseResultModel = None,                                  taskResult: InterfaceTaskResultModel = None                                  ) -> Tuple[Mapping[str, Any], bool]:        """        API æ‰§è¡Œ        è¿”å›æ‰§è¡Œç»“æœï¼Œflag        """        temp_variables = []        asserts_info = None        request_info = None        url = None        # è®°å½•è¯·æ±‚æ—¶é—´        t = GenerateTools.getTime(1)        try:            # 0ã€æ¥å£å¤„ç†è¯·æ±‚URL            url = await self.__set_req_url(interface)            # 1ã€å‰ç½®å˜é‡å‚æ•°            temp_variables.extend(await self.__exec_before_params(interface.before_params))            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            temp_variables.extend(await self.__exec_script(interface.before_script))            # 3.å‰ç½®sql            temp_variables.extend(await self.__exec_before_sql(interface))            # 3.1 å¤„ç†è¯·æ±‚ æ›¿æ¢å˜é‡            request_info = await self.sender.set_req_info(interface)  # request data            url = await self.vars.trans(url)  # url            # 4ã€æ‰§è¡Œæ¥å£è¯·æ±‚            self.response = await self.sender(url=url, method=interface.method, **request_info)            # 5ã€è¿›è¡Œæ–­è¨€            asserts_info = await self.__exec_assert(interface)            # 6ã€å‡ºå‚æå–            temp_variables.extend(await self.__exec_extract(interface))            # 7ã€æ‰§è¡Œåç½®å‡½æ•°            temp_variables.extend(await self.__exec_script(interface.after_script))        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            self.response = f"{str(e)} to {url}"        finally:            request_info['url'] = url            return await  InterfaceAPIWriter.set_interface_result_info(                startTime=t,                starter=self.starter,                request_info=request_info,                interface=interface,                response=self.response,                asserts=asserts_info,                caseResult=caseResult,                taskResult=taskResult,                variables=temp_variables            )    async def __exec_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """å¤„ç†å‰ç½®è„šæœ¬"""        if script:            exe = ExecSafeScript()            _extracted_vars = exe.execute(script)            await self.vars.add_vars(_extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³  è„šæœ¬ = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeScript                }                for k, v in _extracted_vars.items()            ]            return _vars        return []    async def __exec_before_params(self, before_params: List[Dict[str, Any]] = None):        """å¤„ç†å‰ç½®å‚æ•°"""        if before_params:            values = await self.vars.trans(before_params)            await self.vars.add_vars(values)            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeParams                }                for k, v in self.vars().items()            ]            return _vars        return []    async def __exec_before_sql(self, interface: InterfaceModel):        """        æ‰§è¡Œå‰ç½®sql æ“ä½œ        ## Select            sql:str            - select username from user => [{username:xxx}{username:xxx}][0]            - select username as un  from user => [{un:xxx}{un:xxx}][0]            sql_extracts: [{key:username,jp:$[0].username},{key:username,jp:$[1].username}]            - select username from user => [{username:xxx}{username:xxx}]            ==>  [{username:xx},{username:xx}]        ## Update        """        # ä¸æ‰§è¡Œ        if not interface.before_sql or not interface.before_db_id:            return []        _db = await DbConfigMapper.get_by_id(interface.before_db_id)        if not _db:            log.warning(f"æœªæ‰¾åˆ°æ•°æ®åº“é…ç½® ID: {interface.before_db_id}")            return []        script = await self.vars.trans(interface.before_sql.strip())        db_script = ExecDBScript(self.starter, script, interface.before_sql_extracts)        res = await db_script.invoke(_db.db_type, **_db.config)        await self.vars.add_vars(res)        await self.starter.send(f"ğŸ«³ğŸ«³    æ•°æ®åº“è¯»å– = {json.dumps(res, ensure_ascii=False)}")        if res:            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL                }                for k, v in res.items()            ]            return _vars        return []    async def __exec_assert(self, interface: InterfaceModel):        """        å“åº”æ–­è¨€        å‰æï¼š        1ã€æœ‰æ–­è¨€        2ã€æœ‰å“åº”        """        _assert = ExecAsserts(self.response, self.vars())        asserts_info = await _assert(interface.asserts)        await self.starter.send(f"ğŸ«³ğŸ«³    å“åº”æ–­è¨€ = {json.dumps(asserts_info, ensure_ascii=False)}")        return asserts_info    async def __exec_extract(self, interface: InterfaceModel):        """        å˜é‡æå–        å‰æï¼š        1ã€æœ‰æ–­è¨€        2ã€æœ‰å“åº”        3ã€å“åº”200        """        if interface.extracts and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExecResponseExtract(response=self.response)            _vars = await _extract(interface.extracts)            await self.starter.send(f"ğŸ«³ğŸ«³    å“åº”å‚æ•°æå– = {json.dumps(_vars, ensure_ascii=False)}")            await self.vars.add_vars(_vars)            return _vars        return []    async def __init_interface_case_vars(self, interfaceCase: InterfaceCase):        """åˆå§‹åŒ–ç”¨ä¾‹å˜é‡"""        try:            interfaceCaseVars: List[InterfaceVariables] = await InterfaceVarsMapper.query_by(case_id=interfaceCase.id)            if interfaceCaseVars:                for iar in interfaceCaseVars:                    _v = await self.vars.trans(iar.value)                    await self.vars.add_vars({iar.key: _v})            if self.vars():                await self.starter.send(f"ğŸ«³ğŸ«³ åˆå§‹åŒ–ç”¨ä¾‹å˜é‡ = {json.dumps(self.vars(), ensure_ascii=False)}")        except Exception as e:            log.error(e)    @staticmethod    async def __set_req_url(interface: Interface) -> str:        """        è®¾ç½®è¯·æ±‚url        :param interface:        :return: url        """        try:            if interface.env_id == -1:                return interface.url            else:                env = await EnvMapper.get_by_id(ident=interface.env_id)                return env.url + interface.url        except Exception as e:            log.error(f"è®¾ç½®è¯·æ±‚urlå¤±è´¥ = {e}")            raise ValueError("è¯·æ±‚ç¯å¢ƒä¸å­˜åœ¨ã€è¯·æ£€æŸ¥")