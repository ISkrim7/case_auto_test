# !/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/19# @Author : cyq# @File : runner# @Software: PyCharm# @Desc:import jsonfrom datetime import datetimefrom typing import List, Dict, Any, Mapping, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.interface.interfaceVarsMapper import InterfaceVarsMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.mapper.project.env import EnvMapperfrom app.model.interface import InterfaceModel, InterfaceCaseResultModel, InterFaceCaseModel, InterfaceTaskResultModel, \    InterfaceVariablesfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnum, \    InterfaceCaseErrorStep,InterfaceAPIStatusEnumfrom utils import MyLoguru, GenerateToolsfrom app.mapper.interface import InterfaceMapper, InterfaceCaseMapper, InterfaceGlobalVariableMapperfrom common.fakerClient import FakerClientfrom utils.execDBScript import ExecDBScriptfrom utils.transform import Transformfrom interface.exec import *from .sender import HttpSenderfrom .starter import APIStarterfrom .writer import InterfaceAPIWriterlog = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)InterfaceCase = TypeVar('InterfaceCase', bound=InterFaceCaseModel)Interfaces = List[Interface]async def set_req_url(interface: Interface) -> str:    """    设置请求url    :param interface:    :return:    """    try:        if interface.env_id == -1:            return interface.url        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            domain = env.host            if env.port:                domain += f":{env.port}"            return domain + interface.url    except Exception as e:        log.error(f"设置请求url失败 = {e}")        raise ValueError("请求环境不存在、请检查")class InterFaceRunner:    response: Response | str = None    def __init__(self, starter: APIStarter):        self.starter = starter        self.variables = {}        self.sender = HttpSender(self.variables, self.starter)    def set_variables(self, data: Dict[str, Any] | List[Dict[str, Any]]) -> Dict[str, Any]:        """        设置变量        :param data:        :return:        """        if isinstance(data, dict):            self.variables.update(**data)        elif isinstance(data, list):            data = GenerateTools.list2dict(data)            self.variables.update(**data)        return data    async def try_interface(self, interface: int) -> Mapping[str, Any]:        """        执行单个接口请求调试        无变量、有前置方法、        需要返回response        """        interface = await InterfaceMapper.get_by_id(ident=interface)        result, _ = await self.__execute_interface(interface)        return result    async def get_interface(self, interfaceId: int):        """获取接口信息"""        interface: Interface = await InterfaceMapper.get_by_id(ident=interfaceId)        if interface.env_id == -1:            from utils import Tools            parse = Tools.parse_url(interface.url)            url = parse.path            host = f"{parse.scheme}://{parse.netloc}"        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            host = env.host            url = interface.url            if env.port:                host += f":{env.port}"        # 1、前置变量参数        await self.__exec_before_params(interface.before_params)        # 2、执行前置函数        await self.__exec_before_script(interface.before_script)        # 3.前置sql        await self.__exec_before_sql(interface)        url = await self.sender.transform_target(target=url)        info = await self.sender.set_req_info(interface)        info.pop("follow_redirects")        info.pop("read")        info.pop("connect")        return {            "name": interface.name,            "method": interface.method.lower(),            "url": url,            "host": host,            **info        }    async def try_group(self, groupId: int):        """        执行接口组        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=groupId)        results = []        for interface in interfaces:            await self.starter.send(f"execute  ： {interface}")            result, _ = await self.__execute_interface(interface)            results.append(result)        return results    async def run_interface_by_task(self, interface: Interface, taskResult: InterfaceTaskResultModel) -> bool:        """任务执行api"""        result, _ = await self.__execute_interface(interface=interface, taskResult=taskResult)        await InterfaceAPIWriter.write_interface_result(**result)        return _    async def run_interfaceCase_by_task(self, interfaceCase: InterfaceCase,                                        taskResult: InterfaceTaskResultModel) -> bool:        """任务执行case"""        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCase.id)        await self.starter.send(f"用例 {interfaceCase.title} 执行开始。执行人 {self.starter.username}")        await self.starter.send(f"查询到关联API x {len(interfaces)} ...")        interfacesNum = len(interfaces)        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         taskId=taskResult.id,                                                                         starter=self.starter)        await self.starter.send(f"初始化结果模型 。。。 ✅ ID= '{caseResult.uid}'")        _f = True        try:            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"execute  Step {index} ： {interface}")                if interface.is_group:                    # 执行步骤组                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    for _index, _interface in enumerate(group_interfaces, start=1):                        await self.starter.send(f"execute Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        if not flag:                            _f = False                            caseResult.result = InterfaceAPIResultEnum.ERROR                            break                else:                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # 入库                    await InterfaceAPIWriter.write_interface_result(**result)                    caseResult.progress = round(index / interfacesNum, 1) * 100                    if flag:                        caseResult.success_num += 1                    else:                        _f = False                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            break                await InterfaceAPIWriter.write_process(caseResult=caseResult)            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return _f        finally:            await self.starter.send(f"用例 {interfaceCase.title} 执行结束")            await self.starter.send(f"{'====' * 20}")    async def run_interCase(self, interfaceCaseId: int):        """        执行接口用例        """        interfaceCase: InterfaceCase = await InterfaceCaseMapper.get_by_id(ident=interfaceCaseId)        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCaseId)        await self.starter.send(f"用例 {interfaceCase.title} 执行开始。执行人 {self.starter.username}")        await self.starter.send(f"查询到关联API x {len(interfaces)} ...")        interfacesNum = len(interfaces)        if interfacesNum == 0:            return await self.starter.over()        # 加载用例专属变量        await self.__init_interface_case_vars(interfaceCase)        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         starter=self.starter)        await self.starter.send(f"初始化结果模型 。。。 ✅ ID= '{caseResult.uid}'")        try:            total_steps = len(interfaces)  # 总步骤数（包括组步骤）            executed_steps = 0             # 已执行步骤计数器            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"✍️✍️ EXECUTE  Step {index} ： {interface}")                if interface.enable == 0:                    await self.starter.send(f"✍️✍️ EXECUTE Step {index} ： 调试禁用 跳过执行")                    continue                if interface.is_group:                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    group_total = len(group_interfaces)                    group_executed = 0                    group_has_failure = False                    group_success = 0  # 初始化组内成功计数器                    group_fail = 0     # 初始化组内失败计数器                    for _index, _interface in enumerate(group_interfaces, start=1):                        if _interface.enable == 0:                            continue  # 跳过禁用的组内接口                        group_executed += 1                        executed_steps += 1  # 全局步骤计数                        await self.starter.send(f"✍️✍️  EXECUTE Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        #if not flag:                        #    caseResult.result = InterfaceAPIResultEnum.ERROR                        #    break                        if flag:                            #group_success += 1                            caseResult.success_num += 1                        else:                            #group_fail += 1                            group_has_failure = True                            caseResult.fail_num += 1                            caseResult.result = InterfaceAPIResultEnum.ERROR                            if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                                break  # 停止组内执行                    # 更新用例的总成功和失败数                    caseResult.success_num += group_success                    caseResult.fail_num += group_fail                    # 更新进度（基于外部循环的接口步骤）                    #caseResult.progress = round(index / interfacesNum, 2) * 100                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                    # 若组内失败且需要停止，终止整个用例                    if group_fail > 0 and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        caseResult.progress = 100                        break  # 停止整个用例                    # 错误停止判断                    if group_has_failure and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        await self.starter.send("🛑🛑 组步骤执行失败，终止用例")                        caseResult.progress = 100                        break  # 终止整个用例                else:                    # 处理普通接口                    executed_steps += 1                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # 入库                    await InterfaceAPIWriter.write_interface_result(**result)                    caseResult.progress = round(index / interfacesNum, 1) * 100                    if flag:                        caseResult.success_num += 1                    else:                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            await self.starter.send("🛑🛑 接口步骤执行失败，终止用例")                            break                    # 更新进度                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                await InterfaceAPIWriter.write_process(caseResult=caseResult)                if not flag:                    # 更新失败状态                    caseResult.fail_num += 1                    caseResult.result = "FAIL"                    # 错误停止时强制完成状态                    if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        caseResult.status = "OVER"                        caseResult.progress = 100.0                    await InterfaceAPIWriter.write_process(caseResult=caseResult)                await self.starter.send(f"✅✅️ FINISH   Step {index} ： {interface}")                await self.starter.send(f"\n")            await self.starter.send(f"用例 {interfaceCase.title} 执行结束")            await self.starter.send(f"{'====' * 20}")            caseResult.interfaceLog = "".join(self.starter.logs)            return await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)        except Exception as e:            # 异常处理部分            caseResult.status = InterfaceAPIResultEnum.ERROR            caseResult.result = InterfaceAPIResultEnum.ERROR            caseResult.interfaceLog += f"\n未捕获异常: {str(e)}"            log.exception(f"用例执行异常: {str(e)}")        finally:            # 确保所有状态设置完成            if caseResult.status in [InterfaceAPIStatusEnum.RUNNING, None]:                caseResult.status = InterfaceAPIStatusEnum.OVER            # 强制设置最终状态            caseResult.status = InterfaceAPIStatusEnum.OVER            # 优化日志截断（考虑多字节字符）            if caseResult.interfaceLog:                truncated_mark = "\n...[日志已截断]"                max_length = 65535 - len(truncated_mark.encode('utf-8'))                encoded_log = caseResult.interfaceLog.encode('utf-8')[:max_length]                caseResult.interfaceLog = encoded_log.decode('utf-8', 'ignore') + truncated_mark            # 强制保存到数据库            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            # 最后调用over            await self.starter.over(caseResult.id)    async def __execute_interface(self,                                  interface: InterfaceModel,                                  caseResult: InterfaceCaseResultModel = None,                                  taskResult: InterfaceTaskResultModel = None                                  ) -> Tuple[Mapping[str, Any], bool]:        """        API 执行        返回执行结果，flag        """        temp_variables = []        asserts_info = None        url = None        after_sql_result = None  # 新增：后置SQL原始结果        after_vars = {}          # 新增：后置SQL提取的变量        before_sql_result = None        before_vars = {}        after_sql_raw_data = None  # 新增：原始数据        after_sql_extracted_vars = {}  # 新增：提取的变量        # 记录请求时间        t = GenerateTools.getTime(1)        try:            # -1 初始化全局变量            await self.__init_interface_global_vars()            # 0、接口处理请求URL            url = await set_req_url(interface)            # 1、前置变量参数            temp_variables.extend(await self.__exec_before_params(interface.before_params))            # 2、执行前置函数            temp_variables.extend(await self.__exec_before_script(interface.before_script))            # 3.前置sql            # 修改前的调用            #temp_variables.extend(await self.__exec_before_sql(interface))            # 修改后的调用            before_sql_res = await self.__exec_before_sql(interface)            #extracted_vars = before_sql_res["extracted_vars"]            # 正确获取原始数据和提取的变量            before_sql_result = before_sql_res.get("raw_data")            before_vars = before_sql_res.get("extracted_vars", {})            # 构建变量记录            before_sql_vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL                }                #for k, v in extracted_vars.items()                for k, v in before_vars.items()            ]            temp_variables.extend(before_sql_vars)            # 4、执行接口请求            self.response = await self.sender(url=url, interface=interface)            # 5、进行断言            asserts_info = await self.__exec_assert(interface)            # 6、出参提取            temp_variables.extend(await self.__exec_extract(interface))            # 7、执行后置函数            temp_variables.extend(await self.__exec_after_script(interface))            # +++ 新增步骤 8：执行后置SQL +++            #after_sql_vars = await self.__exec_after_sql(interface)            #temp_variables.extend(after_sql_vars)            sql_result = await self.__exec_after_sql(interface)            # 从结果中分离数据            # after_sql_raw_data = sql_result.get("raw_data")  # 原始数据（用于调试）            # after_sql_extracted_vars = sql_result.get("extracted_vars", {})  # 提取的变量            # # 确保extracted_vars不为None            # if after_sql_extracted_vars is None:            #     after_sql_extracted_vars = {}            # # 注入变量池（extracted_vars 是字典）            # self.set_variables(after_sql_extracted_vars)            # # 转换为变量记录格式            # after_sql_vars = [            #     {            #         InterfaceExtractTargetVariablesEnum.KEY: k,            #         InterfaceExtractTargetVariablesEnum.VALUE: v,            #         InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterSQL            #     }            #     for k, v in after_sql_extracted_vars.items()            # ] if after_sql_extracted_vars else []            after_sql_raw_data = sql_result["raw_data"]            after_sql_extracted_vars = sql_result["extracted_vars"]  # 确保提取这个字段            # 转换为变量记录格式            after_sql_vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterSQL                }                for k, v in after_sql_extracted_vars.items()  # 这里使用extracted_vars            ]            temp_variables.extend(after_sql_vars)            # 提取后置SQL结果            #if after_sql_vars:            # 构造原始结果（仅示例，按实际数据结构调整）            #after_sql_result = [var.get("value") for var in after_sql_vars]            # 构造提取变量            #after_vars = {var["key"]: var["value"] for var in after_sql_vars}            # 修改为（直接传递原始结果对象）：            # if after_sql_vars and isinstance(after_sql_vars, dict):            #     after_sql_result = after_sql_vars.get('raw_data', [])            #     after_vars = after_sql_vars.get('extracted_vars', {})            # else:            #     after_sql_result = []            #     after_vars = {}        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            self.response = f"{str(e)} to {url}"        finally:            return await  InterfaceAPIWriter.set_interface_result_info(                #startTime=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),                startTime=t,                starter=self.starter,                interface=interface,                response=self.response,                asserts=asserts_info,                caseResult=caseResult,                taskResult=taskResult,                variables=temp_variables,                # 新增两个字段                #after_sql_result=json.dumps(after_sql_result, ensure_ascii=False) if after_sql_result else None,                #after_vars=json.dumps(after_vars, ensure_ascii=False) if after_vars else None,                # 传递前置SQL结果                before_sql_result=before_sql_result,                before_vars=before_vars,                after_sql_result=after_sql_raw_data,  # 传入原始数据                after_vars=after_sql_extracted_vars   # 传入提取的变量            )    async def __exec_before_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """处理前置脚本"""        if script:            exe = ExecScriptForInterface()            _extracted_vars = self.set_variables(exe.exec_script(script))            await self.starter.send(f"🫳🫳 前置脚本 = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeScript                }                for k, v in _extracted_vars.items()            ]            return _vars        return []    async def __exec_before_params(self, before_params: List[Dict[str, Any]] = None):        """处理前置参数"""        if before_params:            trans = Transform(self.variables)            values = await trans.transform_target(before_params)            _extracted_vars = self.set_variables(values)            await self.starter.send(f"🫳🫳 前置参数 = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeParams                }                for k, v in _extracted_vars.items()            ]            return _vars        return []    async def __exec_before_sql(self, interface: InterfaceModel):        """        执行前置sql 操作        ## Select            sql:str            - select username from user => [{username:xxx}{username:xxx}][0]            - select username as un  from user => [{un:xxx}{un:xxx}][0]            sql_extracts: [{key:username,jp:$[0].username},{key:username,jp:$[1].username}]            - select username from user => [{username:xxx}{username:xxx}]            ==>  [{username:xx},{username:xx}]        ## Update        """        """执行前置SQL操作"""        default_result = {"raw_data": None, "extracted_vars": {}}        # 不执行        if not interface.before_sql or not interface.before_db_id:            #return []            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.before_db_id)            if not _db:                log.warning(f"未找到数据库配置 ID: {interface.before_db_id}")                #return []                return default_result            trans = Transform(self.variables)            script = await trans.transform_target(interface.before_sql.strip())            db_script = ExecDBScript(self.starter, script, interface.before_sql_extracts)            await self.starter.send(f"📝 前置SQL语句: {script}")            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"🫳🫳 数据库读取 = {json.dumps(res, ensure_ascii=False)}")            # if res:            #     _vars = [            #         {            #             InterfaceExtractTargetVariablesEnum.KEY: k,            #             InterfaceExtractTargetVariablesEnum.VALUE: v,            #             InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL            #         }            #         for k, v in res.items()            #     ]            #     return _vars            # return []            # 统一返回结构处理            if res:                # SELECT查询操作                if "raw_data" in res and "extracted_vars" in res:                    raw_data = res["raw_data"]                    extracted_vars = res["extracted_vars"]                # 写操作（UPDATE/INSERT/DELETE）                elif "execution_info" in res:                    raw_data = res["execution_info"]                    extracted_vars = {                        "rows_affected": raw_data.get("rows_affected", 0),                        "execution_status": raw_data.get("status", "SUCCESS")                    }                else:                    raw_data = res                    extracted_vars = {}                # 注入全局变量池                self.set_variables(extracted_vars)                return {                    "raw_data": raw_data,                    "extracted_vars": extracted_vars                }            return default_result        except Exception as e:            log.error(f"执行前置SQL失败: {str(e)}")            await self.starter.send(f"❌ 前置SQL执行失败: {str(e)}")            return default_result    async def __exec_after_sql(self, interface: InterfaceModel):        # 默认返回空字典结构        default_result = {"raw_data": None, "extracted_vars": {}}        """执行后置SQL操作"""        if not interface.after_sql or not interface.after_db_id:            #return []            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.after_db_id)            if not _db:                log.warning(f"未找到后置数据库配置 ID: {interface.after_db_id}")                #return []                return default_result        #try:            trans = Transform(self.variables)            script = await trans.transform_target(interface.after_sql.strip())            await self.starter.send(f"📝 后置SQL语句: {script}")  # 打印实际执行的SQL            db_script = ExecDBScript(self.starter, script, interface.after_sql_extracts)            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"🫳🫳 后置数据库操作结果 = {json.dumps(res, ensure_ascii=False)}")            # # ===== 关键修改开始 =====            # # 处理新结构的结果（包含execution_info）            # if isinstance(res, dict) and "execution_info" in res:            #     # 对于写操作，使用execution_info中的数据            #     return {            #         "raw_data": res.get("execution_info"),  # 返回执行信息            #         "extracted_vars": res.get("extracted_vars", {})  # 可能为None，确保为字典            #     }            # # ===== 关键修改结束 =====            if res:                # 情况1：写操作（包含execution_info）                if isinstance(res, dict) and "execution_info" in res:                    # 从execution_info中提取rows_affected                    rows_affected = res["execution_info"].get("rows_affected", 0)                    # ===== 关键修改开始 =====                    # 创建包含执行结果的提取变量                    extracted_vars = {                        "rows_affected": rows_affected,                        "execution_status": res["execution_info"].get("status", "SUCCESS")                    }                    # 如果原始结果中有extracted_vars，合并它们                    if res.get("extracted_vars"):                        extracted_vars.update(res["extracted_vars"])                    # ===== 关键修改结束 =====                    default_result["raw_data"] = res["execution_info"]                    default_result["extracted_vars"] = extracted_vars                else:                    # 情况2：SELECT查询操作                    default_result["raw_data"] = res.get("raw_data")                    default_result["extracted_vars"] = res.get("extracted_vars", {})                # 确保extracted_vars是字典类型                if default_result["extracted_vars"] is None:                    default_result["extracted_vars"] = {}                # 注入全局变量池                self.set_variables(default_result["extracted_vars"])                await self.starter.send(f"✅ 后置SQL提取结果: extracted_vars={default_result['extracted_vars']}")            # if not res:            #     await self.starter.send("ℹ️ 后置SQL执行成功但未提取到数据")            #     #return []            #     return default_result            # # 从结果中提取关键数据            # raw_data = res.get("raw_data", [])            # await self.starter.send(f"✅raw_data : {json.dumps(raw_data, ensure_ascii=False)}")            # # 将提取的变量合并到全局变量中            # extracted_vars = res.get('extracted_vars', {})            # # 确保extracted_vars是字典类型            # if extracted_vars is None:            #     extracted_vars = {}            # await self.starter.send(f"✅extracted_vars : {json.dumps(extracted_vars, ensure_ascii=False)}")            # self.set_variables(extracted_vars)  # 新增：将变量注入全局变量池            #            # await self.starter.send(f"✅ 后置SQL提取结果: {json.dumps(res, ensure_ascii=False)}")            # # return [            # #     {InterfaceExtractTargetVariablesEnum.KEY: k,            # #      InterfaceExtractTargetVariablesEnum.VALUE: v,            # #      InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterSQL}            # #     for k, v in res.items()            # # ]            # # 返回字典结构，包含原始数据和提取的变量            # return {            #     "raw_data": raw_data,            #     "extracted_vars": extracted_vars            # }            return default_result        except Exception as e:            log.error(f"执行后置SQL失败: {str(e)}")            await self.starter.send(f"❌ 后置SQL执行失败: {str(e)}")            #return []            return default_result    async def __exec_assert(self, interface: InterfaceModel):        """        响应断言        前提：        1、有断言        2、有响应        """        _assert = ExecAsserts(self.response, self.variables)        return await _assert(interface.asserts)    async def __exec_extract(self, interface: InterfaceModel):        """        变量提取        前提：        1、有断言        2、有响应        3、响应200        """        if interface.extracts and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExecResponseExtract(response=self.response)            _vars = await _extract(interface.extracts)            await self.starter.send(f"🫳🫳  响应参数提取 = {json.dumps(_vars, ensure_ascii=False)}")            self.set_variables(_vars)            return _vars        return []    async def __exec_after_script(self, interface: InterfaceModel):        """        执行后置脚本        """        if interface.after_script and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            exe = ExecScriptForInterface(response=self.response)            extracted_vars = self.set_variables(exe.exec_script(interface.after_script))            await self.starter.send(f"🫳🫳 前置脚本 = {json.dumps(extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterScript                }                for k, v in extracted_vars.items()            ]            return _vars        return []    async def __init_interface_case_vars(self, interfaceCase: InterfaceCase):        """初始化用例变量"""        try:            interfaceCaseVars: List[InterfaceVariables] = await InterfaceVarsMapper.query_by(case_id=interfaceCase.id)            f = FakerClient()            if interfaceCaseVars:                for var in interfaceCaseVars:                    if var.value.startswith("{{$"):                        _v = var.value[3:-2]                        self.variables[var.key] = f.value(_v)                    else:                        self.variables[var.key] = var.value            if self.variables:                await self.starter.send(f"🫳🫳 初始化用例变量 = {json.dumps(self.variables, ensure_ascii=False)}")        except Exception as e:            log.error(e)    async def __init_interface_global_vars(self):        try:            g_vars = await InterfaceGlobalVariableMapper.query_all()            if g_vars:                for g_var in g_vars:                    self.variables[g_var.key] = g_var.value        except Exception as e:            log.warning(e)