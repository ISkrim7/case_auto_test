# !/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/11/19# @Author : cyq# @File : runner# @Software: PyCharm# @Desc:import jsonfrom datetime import datetimefrom typing import List, Dict, Any, Mapping, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.interface.interfaceVarsMapper import InterfaceVarsMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.mapper.project.env import EnvMapperfrom app.model.interface import InterfaceModel, InterfaceCaseResultModel, InterFaceCaseModel, InterfaceTaskResultModel, \    InterfaceVariablesfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnum, \    InterfaceCaseErrorStep,InterfaceAPIStatusEnumfrom utils import MyLoguru, GenerateToolsfrom app.mapper.interface import InterfaceMapper, InterfaceCaseMapper, InterfaceGlobalVariableMapperfrom common.fakerClient import FakerClientfrom utils.execDBScript import ExecDBScriptfrom utils.transform import Transformfrom interface.exec import *from .sender import HttpSenderfrom .starter import APIStarterfrom .writer import InterfaceAPIWriterlog = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)InterfaceCase = TypeVar('InterfaceCase', bound=InterFaceCaseModel)Interfaces = List[Interface]async def set_req_url(interface: Interface) -> str:    """    è®¾ç½®è¯·æ±‚url    :param interface:    :return:    """    try:        if interface.env_id == -1:            return interface.url        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            domain = env.host            if env.port:                domain += f":{env.port}"            return domain + interface.url    except Exception as e:        log.error(f"è®¾ç½®è¯·æ±‚urlå¤±è´¥ = {e}")        raise ValueError("è¯·æ±‚ç¯å¢ƒä¸å­˜åœ¨ã€è¯·æ£€æŸ¥")class InterFaceRunner:    response: Response | str = None    def __init__(self, starter: APIStarter):        self.starter = starter        self.variables = {}        self.sender = HttpSender(self.variables, self.starter)    def set_variables(self, data: Dict[str, Any] | List[Dict[str, Any]]) -> Dict[str, Any]:        """        è®¾ç½®å˜é‡        :param data:        :return:        """        if isinstance(data, dict):            self.variables.update(**data)        elif isinstance(data, list):            data = GenerateTools.list2dict(data)            self.variables.update(**data)        return data    async def try_interface(self, interface: int) -> Mapping[str, Any]:        """        æ‰§è¡Œå•ä¸ªæ¥å£è¯·æ±‚è°ƒè¯•        æ— å˜é‡ã€æœ‰å‰ç½®æ–¹æ³•ã€        éœ€è¦è¿”å›response        """        interface = await InterfaceMapper.get_by_id(ident=interface)        result, _ = await self.__execute_interface(interface)        return result    async def get_interface(self, interfaceId: int):        """è·å–æ¥å£ä¿¡æ¯"""        interface: Interface = await InterfaceMapper.get_by_id(ident=interfaceId)        if interface.env_id == -1:            from utils import Tools            parse = Tools.parse_url(interface.url)            url = parse.path            host = f"{parse.scheme}://{parse.netloc}"        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            host = env.host            url = interface.url            if env.port:                host += f":{env.port}"        # 1ã€å‰ç½®å˜é‡å‚æ•°        await self.__exec_before_params(interface.before_params)        # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°        await self.__exec_before_script(interface.before_script)        # 3.å‰ç½®sql        await self.__exec_before_sql(interface)        url = await self.sender.transform_target(target=url)        info = await self.sender.set_req_info(interface)        info.pop("follow_redirects")        info.pop("read")        info.pop("connect")        return {            "name": interface.name,            "method": interface.method.lower(),            "url": url,            "host": host,            **info        }    async def try_group(self, groupId: int):        """        æ‰§è¡Œæ¥å£ç»„        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=groupId)        results = []        for interface in interfaces:            await self.starter.send(f"execute  ï¼š {interface}")            result, _ = await self.__execute_interface(interface)            results.append(result)        return results    async def run_interface_by_task(self, interface: Interface, taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œapi"""        result, _ = await self.__execute_interface(interface=interface, taskResult=taskResult)        await InterfaceAPIWriter.write_interface_result(**result)        return _    async def run_interfaceCase_by_task(self, interfaceCase: InterfaceCase,                                        taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œcase"""        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCase.id)        await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"æŸ¥è¯¢åˆ°å…³è”API x {len(interfaces)} ...")        interfacesNum = len(interfaces)        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         taskId=taskResult.id,                                                                         starter=self.starter)        await self.starter.send(f"åˆå§‹åŒ–ç»“æœæ¨¡å‹ ã€‚ã€‚ã€‚ âœ… ID= '{caseResult.uid}'")        _f = True        try:            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"execute  Step {index} ï¼š {interface}")                if interface.is_group:                    # æ‰§è¡Œæ­¥éª¤ç»„                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    for _index, _interface in enumerate(group_interfaces, start=1):                        await self.starter.send(f"execute Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        if not flag:                            _f = False                            caseResult.result = InterfaceAPIResultEnum.ERROR                            break                else:                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # å…¥åº“                    await InterfaceAPIWriter.write_interface_result(**result)                    caseResult.progress = round(index / interfacesNum, 1) * 100                    if flag:                        caseResult.success_num += 1                    else:                        _f = False                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            break                await InterfaceAPIWriter.write_process(caseResult=caseResult)            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return _f        finally:            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")    async def run_interCase(self, interfaceCaseId: int):        """        æ‰§è¡Œæ¥å£ç”¨ä¾‹        """        interfaceCase: InterfaceCase = await InterfaceCaseMapper.get_by_id(ident=interfaceCaseId)        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCaseId)        await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"æŸ¥è¯¢åˆ°å…³è”API x {len(interfaces)} ...")        interfacesNum = len(interfaces)        if interfacesNum == 0:            return await self.starter.over()        # åŠ è½½ç”¨ä¾‹ä¸“å±å˜é‡        await self.__init_interface_case_vars(interfaceCase)        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         starter=self.starter)        await self.starter.send(f"åˆå§‹åŒ–ç»“æœæ¨¡å‹ ã€‚ã€‚ã€‚ âœ… ID= '{caseResult.uid}'")        try:            total_steps = len(interfaces)  # æ€»æ­¥éª¤æ•°ï¼ˆåŒ…æ‹¬ç»„æ­¥éª¤ï¼‰            executed_steps = 0             # å·²æ‰§è¡Œæ­¥éª¤è®¡æ•°å™¨            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"âœï¸âœï¸ EXECUTE  Step {index} ï¼š {interface}")                if interface.enable == 0:                    await self.starter.send(f"âœï¸âœï¸ EXECUTE Step {index} ï¼š è°ƒè¯•ç¦ç”¨ è·³è¿‡æ‰§è¡Œ")                    continue                if interface.is_group:                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    group_total = len(group_interfaces)                    group_executed = 0                    group_has_failure = False                    group_success = 0  # åˆå§‹åŒ–ç»„å†…æˆåŠŸè®¡æ•°å™¨                    group_fail = 0     # åˆå§‹åŒ–ç»„å†…å¤±è´¥è®¡æ•°å™¨                    for _index, _interface in enumerate(group_interfaces, start=1):                        if _interface.enable == 0:                            continue  # è·³è¿‡ç¦ç”¨çš„ç»„å†…æ¥å£                        group_executed += 1                        executed_steps += 1  # å…¨å±€æ­¥éª¤è®¡æ•°                        await self.starter.send(f"âœï¸âœï¸  EXECUTE Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        #if not flag:                        #    caseResult.result = InterfaceAPIResultEnum.ERROR                        #    break                        if flag:                            #group_success += 1                            caseResult.success_num += 1                        else:                            #group_fail += 1                            group_has_failure = True                            caseResult.fail_num += 1                            caseResult.result = InterfaceAPIResultEnum.ERROR                            if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                                break  # åœæ­¢ç»„å†…æ‰§è¡Œ                    # æ›´æ–°ç”¨ä¾‹çš„æ€»æˆåŠŸå’Œå¤±è´¥æ•°                    caseResult.success_num += group_success                    caseResult.fail_num += group_fail                    # æ›´æ–°è¿›åº¦ï¼ˆåŸºäºå¤–éƒ¨å¾ªç¯çš„æ¥å£æ­¥éª¤ï¼‰                    #caseResult.progress = round(index / interfacesNum, 2) * 100                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                    # è‹¥ç»„å†…å¤±è´¥ä¸”éœ€è¦åœæ­¢ï¼Œç»ˆæ­¢æ•´ä¸ªç”¨ä¾‹                    if group_fail > 0 and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        caseResult.progress = 100                        break  # åœæ­¢æ•´ä¸ªç”¨ä¾‹                    # é”™è¯¯åœæ­¢åˆ¤æ–­                    if group_has_failure and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        await self.starter.send("ğŸ›‘ğŸ›‘ ç»„æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼Œç»ˆæ­¢ç”¨ä¾‹")                        caseResult.progress = 100                        break  # ç»ˆæ­¢æ•´ä¸ªç”¨ä¾‹                else:                    # å¤„ç†æ™®é€šæ¥å£                    executed_steps += 1                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # å…¥åº“                    await InterfaceAPIWriter.write_interface_result(**result)                    caseResult.progress = round(index / interfacesNum, 1) * 100                    if flag:                        caseResult.success_num += 1                    else:                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            await self.starter.send("ğŸ›‘ğŸ›‘ æ¥å£æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼Œç»ˆæ­¢ç”¨ä¾‹")                            break                    # æ›´æ–°è¿›åº¦                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                await InterfaceAPIWriter.write_process(caseResult=caseResult)                if not flag:                    # æ›´æ–°å¤±è´¥çŠ¶æ€                    caseResult.fail_num += 1                    caseResult.result = "FAIL"                    # é”™è¯¯åœæ­¢æ—¶å¼ºåˆ¶å®ŒæˆçŠ¶æ€                    if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        caseResult.status = "OVER"                        caseResult.progress = 100.0                    await InterfaceAPIWriter.write_process(caseResult=caseResult)                await self.starter.send(f"âœ…âœ…ï¸ FINISH   Step {index} ï¼š {interface}")                await self.starter.send(f"\n")            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")            caseResult.interfaceLog = "".join(self.starter.logs)            return await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)        except Exception as e:            # å¼‚å¸¸å¤„ç†éƒ¨åˆ†            caseResult.status = InterfaceAPIResultEnum.ERROR            caseResult.result = InterfaceAPIResultEnum.ERROR            caseResult.interfaceLog += f"\næœªæ•è·å¼‚å¸¸: {str(e)}"            log.exception(f"ç”¨ä¾‹æ‰§è¡Œå¼‚å¸¸: {str(e)}")        finally:            # ç¡®ä¿æ‰€æœ‰çŠ¶æ€è®¾ç½®å®Œæˆ            if caseResult.status in [InterfaceAPIStatusEnum.RUNNING, None]:                caseResult.status = InterfaceAPIStatusEnum.OVER            # å¼ºåˆ¶è®¾ç½®æœ€ç»ˆçŠ¶æ€            caseResult.status = InterfaceAPIStatusEnum.OVER            # ä¼˜åŒ–æ—¥å¿—æˆªæ–­ï¼ˆè€ƒè™‘å¤šå­—èŠ‚å­—ç¬¦ï¼‰            if caseResult.interfaceLog:                truncated_mark = "\n...[æ—¥å¿—å·²æˆªæ–­]"                max_length = 65535 - len(truncated_mark.encode('utf-8'))                encoded_log = caseResult.interfaceLog.encode('utf-8')[:max_length]                caseResult.interfaceLog = encoded_log.decode('utf-8', 'ignore') + truncated_mark            # å¼ºåˆ¶ä¿å­˜åˆ°æ•°æ®åº“            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            # æœ€åè°ƒç”¨over            await self.starter.over(caseResult.id)    async def __execute_interface(self,                                  interface: InterfaceModel,                                  caseResult: InterfaceCaseResultModel = None,                                  taskResult: InterfaceTaskResultModel = None                                  ) -> Tuple[Mapping[str, Any], bool]:        """        API æ‰§è¡Œ        è¿”å›æ‰§è¡Œç»“æœï¼Œflag        """        temp_variables = []        asserts_info = None        url = None        after_sql_result = None  # æ–°å¢ï¼šåç½®SQLåŸå§‹ç»“æœ        after_vars = {}          # æ–°å¢ï¼šåç½®SQLæå–çš„å˜é‡        before_sql_result = None        before_vars = {}        after_sql_raw_data = None  # æ–°å¢ï¼šåŸå§‹æ•°æ®        after_sql_extracted_vars = {}  # æ–°å¢ï¼šæå–çš„å˜é‡        # è®°å½•è¯·æ±‚æ—¶é—´        t = GenerateTools.getTime(1)        try:            # -1 åˆå§‹åŒ–å…¨å±€å˜é‡            await self.__init_interface_global_vars()            # 0ã€æ¥å£å¤„ç†è¯·æ±‚URL            url = await set_req_url(interface)            # 1ã€å‰ç½®å˜é‡å‚æ•°            temp_variables.extend(await self.__exec_before_params(interface.before_params))            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            temp_variables.extend(await self.__exec_before_script(interface.before_script))            # 3.å‰ç½®sql            # ä¿®æ”¹å‰çš„è°ƒç”¨            #temp_variables.extend(await self.__exec_before_sql(interface))            # ä¿®æ”¹åçš„è°ƒç”¨            before_sql_res = await self.__exec_before_sql(interface)            #extracted_vars = before_sql_res["extracted_vars"]            # æ­£ç¡®è·å–åŸå§‹æ•°æ®å’Œæå–çš„å˜é‡            before_sql_result = before_sql_res.get("raw_data")            before_vars = before_sql_res.get("extracted_vars", {})            # æ„å»ºå˜é‡è®°å½•            before_sql_vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL                }                #for k, v in extracted_vars.items()                for k, v in before_vars.items()            ]            temp_variables.extend(before_sql_vars)            # 4ã€æ‰§è¡Œæ¥å£è¯·æ±‚            self.response = await self.sender(url=url, interface=interface)            # 5ã€è¿›è¡Œæ–­è¨€            asserts_info = await self.__exec_assert(interface)            # 6ã€å‡ºå‚æå–            temp_variables.extend(await self.__exec_extract(interface))            # 7ã€æ‰§è¡Œåç½®å‡½æ•°            temp_variables.extend(await self.__exec_after_script(interface))            # +++ æ–°å¢æ­¥éª¤ 8ï¼šæ‰§è¡Œåç½®SQL +++            #after_sql_vars = await self.__exec_after_sql(interface)            #temp_variables.extend(after_sql_vars)            sql_result = await self.__exec_after_sql(interface)            # ä»ç»“æœä¸­åˆ†ç¦»æ•°æ®            # after_sql_raw_data = sql_result.get("raw_data")  # åŸå§‹æ•°æ®ï¼ˆç”¨äºè°ƒè¯•ï¼‰            # after_sql_extracted_vars = sql_result.get("extracted_vars", {})  # æå–çš„å˜é‡            # # ç¡®ä¿extracted_varsä¸ä¸ºNone            # if after_sql_extracted_vars is None:            #     after_sql_extracted_vars = {}            # # æ³¨å…¥å˜é‡æ± ï¼ˆextracted_vars æ˜¯å­—å…¸ï¼‰            # self.set_variables(after_sql_extracted_vars)            # # è½¬æ¢ä¸ºå˜é‡è®°å½•æ ¼å¼            # after_sql_vars = [            #     {            #         InterfaceExtractTargetVariablesEnum.KEY: k,            #         InterfaceExtractTargetVariablesEnum.VALUE: v,            #         InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterSQL            #     }            #     for k, v in after_sql_extracted_vars.items()            # ] if after_sql_extracted_vars else []            after_sql_raw_data = sql_result["raw_data"]            after_sql_extracted_vars = sql_result["extracted_vars"]  # ç¡®ä¿æå–è¿™ä¸ªå­—æ®µ            # è½¬æ¢ä¸ºå˜é‡è®°å½•æ ¼å¼            after_sql_vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterSQL                }                for k, v in after_sql_extracted_vars.items()  # è¿™é‡Œä½¿ç”¨extracted_vars            ]            temp_variables.extend(after_sql_vars)            # æå–åç½®SQLç»“æœ            #if after_sql_vars:            # æ„é€ åŸå§‹ç»“æœï¼ˆä»…ç¤ºä¾‹ï¼ŒæŒ‰å®é™…æ•°æ®ç»“æ„è°ƒæ•´ï¼‰            #after_sql_result = [var.get("value") for var in after_sql_vars]            # æ„é€ æå–å˜é‡            #after_vars = {var["key"]: var["value"] for var in after_sql_vars}            # ä¿®æ”¹ä¸ºï¼ˆç›´æ¥ä¼ é€’åŸå§‹ç»“æœå¯¹è±¡ï¼‰ï¼š            # if after_sql_vars and isinstance(after_sql_vars, dict):            #     after_sql_result = after_sql_vars.get('raw_data', [])            #     after_vars = after_sql_vars.get('extracted_vars', {})            # else:            #     after_sql_result = []            #     after_vars = {}        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            self.response = f"{str(e)} to {url}"        finally:            return await  InterfaceAPIWriter.set_interface_result_info(                #startTime=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),                startTime=t,                starter=self.starter,                interface=interface,                response=self.response,                asserts=asserts_info,                caseResult=caseResult,                taskResult=taskResult,                variables=temp_variables,                # æ–°å¢ä¸¤ä¸ªå­—æ®µ                #after_sql_result=json.dumps(after_sql_result, ensure_ascii=False) if after_sql_result else None,                #after_vars=json.dumps(after_vars, ensure_ascii=False) if after_vars else None,                # ä¼ é€’å‰ç½®SQLç»“æœ                before_sql_result=before_sql_result,                before_vars=before_vars,                after_sql_result=after_sql_raw_data,  # ä¼ å…¥åŸå§‹æ•°æ®                after_vars=after_sql_extracted_vars   # ä¼ å…¥æå–çš„å˜é‡            )    async def __exec_before_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """å¤„ç†å‰ç½®è„šæœ¬"""        if script:            exe = ExecScriptForInterface()            _extracted_vars = self.set_variables(exe.exec_script(script))            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®è„šæœ¬ = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeScript                }                for k, v in _extracted_vars.items()            ]            return _vars        return []    async def __exec_before_params(self, before_params: List[Dict[str, Any]] = None):        """å¤„ç†å‰ç½®å‚æ•°"""        if before_params:            trans = Transform(self.variables)            values = await trans.transform_target(before_params)            _extracted_vars = self.set_variables(values)            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®å‚æ•° = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeParams                }                for k, v in _extracted_vars.items()            ]            return _vars        return []    async def __exec_before_sql(self, interface: InterfaceModel):        """        æ‰§è¡Œå‰ç½®sql æ“ä½œ        ## Select            sql:str            - select username from user => [{username:xxx}{username:xxx}][0]            - select username as un  from user => [{un:xxx}{un:xxx}][0]            sql_extracts: [{key:username,jp:$[0].username},{key:username,jp:$[1].username}]            - select username from user => [{username:xxx}{username:xxx}]            ==>  [{username:xx},{username:xx}]        ## Update        """        """æ‰§è¡Œå‰ç½®SQLæ“ä½œ"""        default_result = {"raw_data": None, "extracted_vars": {}}        # ä¸æ‰§è¡Œ        if not interface.before_sql or not interface.before_db_id:            #return []            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.before_db_id)            if not _db:                log.warning(f"æœªæ‰¾åˆ°æ•°æ®åº“é…ç½® ID: {interface.before_db_id}")                #return []                return default_result            trans = Transform(self.variables)            script = await trans.transform_target(interface.before_sql.strip())            db_script = ExecDBScript(self.starter, script, interface.before_sql_extracts)            await self.starter.send(f"ğŸ“ å‰ç½®SQLè¯­å¥: {script}")            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"ğŸ«³ğŸ«³ æ•°æ®åº“è¯»å– = {json.dumps(res, ensure_ascii=False)}")            # if res:            #     _vars = [            #         {            #             InterfaceExtractTargetVariablesEnum.KEY: k,            #             InterfaceExtractTargetVariablesEnum.VALUE: v,            #             InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.BeforeSQL            #         }            #         for k, v in res.items()            #     ]            #     return _vars            # return []            # ç»Ÿä¸€è¿”å›ç»“æ„å¤„ç†            if res:                # SELECTæŸ¥è¯¢æ“ä½œ                if "raw_data" in res and "extracted_vars" in res:                    raw_data = res["raw_data"]                    extracted_vars = res["extracted_vars"]                # å†™æ“ä½œï¼ˆUPDATE/INSERT/DELETEï¼‰                elif "execution_info" in res:                    raw_data = res["execution_info"]                    extracted_vars = {                        "rows_affected": raw_data.get("rows_affected", 0),                        "execution_status": raw_data.get("status", "SUCCESS")                    }                else:                    raw_data = res                    extracted_vars = {}                # æ³¨å…¥å…¨å±€å˜é‡æ±                 self.set_variables(extracted_vars)                return {                    "raw_data": raw_data,                    "extracted_vars": extracted_vars                }            return default_result        except Exception as e:            log.error(f"æ‰§è¡Œå‰ç½®SQLå¤±è´¥: {str(e)}")            await self.starter.send(f"âŒ å‰ç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")            return default_result    async def __exec_after_sql(self, interface: InterfaceModel):        # é»˜è®¤è¿”å›ç©ºå­—å…¸ç»“æ„        default_result = {"raw_data": None, "extracted_vars": {}}        """æ‰§è¡Œåç½®SQLæ“ä½œ"""        if not interface.after_sql or not interface.after_db_id:            #return []            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.after_db_id)            if not _db:                log.warning(f"æœªæ‰¾åˆ°åç½®æ•°æ®åº“é…ç½® ID: {interface.after_db_id}")                #return []                return default_result        #try:            trans = Transform(self.variables)            script = await trans.transform_target(interface.after_sql.strip())            await self.starter.send(f"ğŸ“ åç½®SQLè¯­å¥: {script}")  # æ‰“å°å®é™…æ‰§è¡Œçš„SQL            db_script = ExecDBScript(self.starter, script, interface.after_sql_extracts)            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"ğŸ«³ğŸ«³ åç½®æ•°æ®åº“æ“ä½œç»“æœ = {json.dumps(res, ensure_ascii=False)}")            # # ===== å…³é”®ä¿®æ”¹å¼€å§‹ =====            # # å¤„ç†æ–°ç»“æ„çš„ç»“æœï¼ˆåŒ…å«execution_infoï¼‰            # if isinstance(res, dict) and "execution_info" in res:            #     # å¯¹äºå†™æ“ä½œï¼Œä½¿ç”¨execution_infoä¸­çš„æ•°æ®            #     return {            #         "raw_data": res.get("execution_info"),  # è¿”å›æ‰§è¡Œä¿¡æ¯            #         "extracted_vars": res.get("extracted_vars", {})  # å¯èƒ½ä¸ºNoneï¼Œç¡®ä¿ä¸ºå­—å…¸            #     }            # # ===== å…³é”®ä¿®æ”¹ç»“æŸ =====            if res:                # æƒ…å†µ1ï¼šå†™æ“ä½œï¼ˆåŒ…å«execution_infoï¼‰                if isinstance(res, dict) and "execution_info" in res:                    # ä»execution_infoä¸­æå–rows_affected                    rows_affected = res["execution_info"].get("rows_affected", 0)                    # ===== å…³é”®ä¿®æ”¹å¼€å§‹ =====                    # åˆ›å»ºåŒ…å«æ‰§è¡Œç»“æœçš„æå–å˜é‡                    extracted_vars = {                        "rows_affected": rows_affected,                        "execution_status": res["execution_info"].get("status", "SUCCESS")                    }                    # å¦‚æœåŸå§‹ç»“æœä¸­æœ‰extracted_varsï¼Œåˆå¹¶å®ƒä»¬                    if res.get("extracted_vars"):                        extracted_vars.update(res["extracted_vars"])                    # ===== å…³é”®ä¿®æ”¹ç»“æŸ =====                    default_result["raw_data"] = res["execution_info"]                    default_result["extracted_vars"] = extracted_vars                else:                    # æƒ…å†µ2ï¼šSELECTæŸ¥è¯¢æ“ä½œ                    default_result["raw_data"] = res.get("raw_data")                    default_result["extracted_vars"] = res.get("extracted_vars", {})                # ç¡®ä¿extracted_varsæ˜¯å­—å…¸ç±»å‹                if default_result["extracted_vars"] is None:                    default_result["extracted_vars"] = {}                # æ³¨å…¥å…¨å±€å˜é‡æ±                 self.set_variables(default_result["extracted_vars"])                await self.starter.send(f"âœ… åç½®SQLæå–ç»“æœ: extracted_vars={default_result['extracted_vars']}")            # if not res:            #     await self.starter.send("â„¹ï¸ åç½®SQLæ‰§è¡ŒæˆåŠŸä½†æœªæå–åˆ°æ•°æ®")            #     #return []            #     return default_result            # # ä»ç»“æœä¸­æå–å…³é”®æ•°æ®            # raw_data = res.get("raw_data", [])            # await self.starter.send(f"âœ…raw_data : {json.dumps(raw_data, ensure_ascii=False)}")            # # å°†æå–çš„å˜é‡åˆå¹¶åˆ°å…¨å±€å˜é‡ä¸­            # extracted_vars = res.get('extracted_vars', {})            # # ç¡®ä¿extracted_varsæ˜¯å­—å…¸ç±»å‹            # if extracted_vars is None:            #     extracted_vars = {}            # await self.starter.send(f"âœ…extracted_vars : {json.dumps(extracted_vars, ensure_ascii=False)}")            # self.set_variables(extracted_vars)  # æ–°å¢ï¼šå°†å˜é‡æ³¨å…¥å…¨å±€å˜é‡æ±             #            # await self.starter.send(f"âœ… åç½®SQLæå–ç»“æœ: {json.dumps(res, ensure_ascii=False)}")            # # return [            # #     {InterfaceExtractTargetVariablesEnum.KEY: k,            # #      InterfaceExtractTargetVariablesEnum.VALUE: v,            # #      InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterSQL}            # #     for k, v in res.items()            # # ]            # # è¿”å›å­—å…¸ç»“æ„ï¼ŒåŒ…å«åŸå§‹æ•°æ®å’Œæå–çš„å˜é‡            # return {            #     "raw_data": raw_data,            #     "extracted_vars": extracted_vars            # }            return default_result        except Exception as e:            log.error(f"æ‰§è¡Œåç½®SQLå¤±è´¥: {str(e)}")            await self.starter.send(f"âŒ åç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")            #return []            return default_result    async def __exec_assert(self, interface: InterfaceModel):        """        å“åº”æ–­è¨€        å‰æï¼š        1ã€æœ‰æ–­è¨€        2ã€æœ‰å“åº”        """        _assert = ExecAsserts(self.response, self.variables)        return await _assert(interface.asserts)    async def __exec_extract(self, interface: InterfaceModel):        """        å˜é‡æå–        å‰æï¼š        1ã€æœ‰æ–­è¨€        2ã€æœ‰å“åº”        3ã€å“åº”200        """        if interface.extracts and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExecResponseExtract(response=self.response)            _vars = await _extract(interface.extracts)            await self.starter.send(f"ğŸ«³ğŸ«³  å“åº”å‚æ•°æå– = {json.dumps(_vars, ensure_ascii=False)}")            self.set_variables(_vars)            return _vars        return []    async def __exec_after_script(self, interface: InterfaceModel):        """        æ‰§è¡Œåç½®è„šæœ¬        """        if interface.after_script and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            exe = ExecScriptForInterface(response=self.response)            extracted_vars = self.set_variables(exe.exec_script(interface.after_script))            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®è„šæœ¬ = {json.dumps(extracted_vars, ensure_ascii=False)}")            _vars = [                {                    InterfaceExtractTargetVariablesEnum.KEY: k,                    InterfaceExtractTargetVariablesEnum.VALUE: v,                    InterfaceExtractTargetVariablesEnum.Target: InterfaceExtractTargetVariablesEnum.AfterScript                }                for k, v in extracted_vars.items()            ]            return _vars        return []    async def __init_interface_case_vars(self, interfaceCase: InterfaceCase):        """åˆå§‹åŒ–ç”¨ä¾‹å˜é‡"""        try:            interfaceCaseVars: List[InterfaceVariables] = await InterfaceVarsMapper.query_by(case_id=interfaceCase.id)            f = FakerClient()            if interfaceCaseVars:                for var in interfaceCaseVars:                    if var.value.startswith("{{$"):                        _v = var.value[3:-2]                        self.variables[var.key] = f.value(_v)                    else:                        self.variables[var.key] = var.value            if self.variables:                await self.starter.send(f"ğŸ«³ğŸ«³ åˆå§‹åŒ–ç”¨ä¾‹å˜é‡ = {json.dumps(self.variables, ensure_ascii=False)}")        except Exception as e:            log.error(e)    async def __init_interface_global_vars(self):        try:            g_vars = await InterfaceGlobalVariableMapper.query_all()            if g_vars:                for g_var in g_vars:                    self.variables[g_var.key] = g_var.value        except Exception as e:            log.warning(e)