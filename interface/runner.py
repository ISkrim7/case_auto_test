import jsonfrom datetime import datetimefrom typing import List, Dict, Any, Mapping, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.interface.interfaceVarsMapper import InterfaceVarsMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.mapper.project.env import EnvMapperfrom app.model.interface import InterfaceModel, InterfaceCaseResultModel, InterFaceCaseModel, InterfaceTaskResultModel, \    InterfaceVariablesfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnum, \    InterfaceCaseErrorStep,InterfaceAPIStatusEnumfrom play.starter import UIStarterfrom utils import MyLoguru, GenerateToolsfrom app.mapper.interface import InterfaceMapper, InterfaceCaseMapperfrom app.mapper.project import GlobalVariableMapperfrom common.fakerClient import FakerClientfrom utils.execDBScript import ExecDBScriptfrom utils.transform import Transformfrom interface.exec import *from utils.variableTrans import VariableTransfrom .http_middleware import HttpxMiddlewarefrom .starter import APIStarterfrom .writer import InterfaceAPIWriterlog = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)InterfaceCase = TypeVar('InterfaceCase', bound=InterFaceCaseModel)Interfaces = List[Interface]async def set_req_url(interface: Interface) -> str:    """    è®¾ç½®è¯·æ±‚url    :param interface:    :return:    """    try:        if interface.env_id == -1:            return interface.url        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            domain = env.host            if env.port:                domain += f":{env.port}"            return domain + interface.url    except Exception as e:        log.error(f"è®¾ç½®è¯·æ±‚urlå¤±è´¥ = {e}")        raise ValueError("è¯·æ±‚ç¯å¢ƒä¸å­˜åœ¨ã€è¯·æ£€æŸ¥")class InterFaceRunner:    response: Response | str = None    def __init__(self, starter: APIStarter | UIStarter):        self.starter = starter        # ä¿®å¤ç‚¹1ï¼šæ¢å¤ä½¿ç”¨ VariableTransï¼Œå› ä¸º HttpxMiddleware ä¾èµ–å®ƒ        self.vars = VariableTrans()        self.sender = HttpxMiddleware(self.vars, self.starter)        self.faker = FakerClient()    async def execute_interface_by_ui(self, interface: Interface, ui_vars: Dict[str, Any] | None = None):        """        ui ä¾§æ‰§è¡Œæ¥å£        :param interfaceï¼šæ¥å£å¯¹è±¡        :param ui_vars: ui å˜é‡        """        if ui_vars:            await self.vars.add_vars(ui_vars)        result, _ = await self.__execute_interface(interface)        return result, _    async def try_interface(self, interface: int) -> Mapping[str, Any]:        """        æ‰§è¡Œå•ä¸ªæ¥å£è¯·æ±‚è°ƒè¯•        æ— å˜é‡ã€æœ‰å‰ç½®æ–¹æ³•ã€        éœ€è¦è¿”å›response        """        interface = await InterfaceMapper.get_by_id(ident=interface)        result, _ = await self.__execute_interface(interface)        return result    async def get_interface(self, interfaceId: int, use_var: bool = False):        """è·å–æ¥å£ä¿¡æ¯"""        interface: Interface = await InterfaceMapper.get_by_id(ident=interfaceId)        # è‡ªå®šä¹‰ç¯å¢ƒ        if interface.env_id == -1:            from utils import Tools            parse = Tools.parse_url(interface.url)            url = parse.path            host = f"{parse.scheme}://{parse.netloc}"        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            host = env.host            url = interface.url            if env.port:                host += f":{env.port}"        if use_var:            # 1ã€å‰ç½®å˜é‡å‚æ•°            await self.__exec_before_params(interface.before_params)            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            await self.__exec_before_script(interface.before_script)            # 3.å‰ç½®sql            await self.__exec_before_sql(interface)            url = await self.sender.transform_target(target=url)        info = await self.sender.set_req_info(interface)        info.pop("follow_redirects")        info.pop("read")        info.pop("connect")        return {            "name": interface.name,            "method": interface.method.lower(),            "url": url,            "host": host,            "asserts": interface.asserts,            **info        }    async def try_group(self, groupId: int):        """        æ‰§è¡Œæ¥å£ç»„        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=groupId)        results = []        for interface in interfaces:            await self.starter.send(f"âœï¸âœï¸  Execute    {interface}")            result, _ = await self.__execute_interface(interface)            results.append(result)        return results    async def run_interface_by_task(self, interface: Interface, taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œapi"""        result, _ = await self.__execute_interface(interface=interface, taskResult=taskResult)        await InterfaceAPIWriter.write_interface_result(**result)        return _    async def run_interfaceCase_by_task(self, interfaceCase: InterfaceCase,                                        taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œcase"""        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCase.id)        await self.starter.send(f"â±ï¸â±ï¸    ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"â±ï¸â±ï¸    æŸ¥è¯¢åˆ°å…³è”API x {len(interfaces)} ...")        # å…³è”çš„ API        interfacesNum = len(interfaces)        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         taskId=taskResult.id,                                                                         starter=self.starter)        await self.starter.send(f"åˆå§‹åŒ–ç»“æœæ¨¡å‹ ã€‚ã€‚ã€‚ âœ… ID= '{caseResult.uid}'")        _f = True        try:            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"Execute  Step {index} ï¼š {interface}")                if interface.is_group:                    # æ‰§è¡Œæ­¥éª¤ç»„                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    for _index, _interface in enumerate(group_interfaces, start=1):                        await self.starter.send(f"Execute Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        if not flag:                            _f = False                            caseResult.result = InterfaceAPIResultEnum.ERROR                            break                else:                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # å…¥åº“                    await InterfaceAPIWriter.write_interface_result(**result)                    caseResult.progress = round(index / interfacesNum, 1) * 100                    if flag:                        caseResult.success_num += 1                    else:                        _f = False                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            break                await InterfaceAPIWriter.write_process(caseResult=caseResult)            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return _f        finally:            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")    async def run_interCase(self, interfaceCaseId: int):        """        æ‰§è¡Œæ¥å£ç”¨ä¾‹        """        # æŸ¥è¯¢ç”¨ä¾‹        interfaceCase: InterfaceCase = await InterfaceCaseMapper.get_by_id(ident=interfaceCaseId)        # æŸ¥è¯¢ç”¨ä¾‹æ‰€å±API        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCaseId)        await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"æŸ¥è¯¢åˆ°å…³è”API x {len(interfaces)} ...")        interfacesNum = len(interfaces)        if interfacesNum == 0:            await self.starter.send(f"æ— å¯æ‰§è¡ŒAPI ç»“æŸ...")            return await self.starter.over()        # åŠ è½½ç”¨ä¾‹ä¸“å±å˜é‡        await self.__init_interface_case_vars(interfaceCase)        # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœå¯¹è±¡        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         starter=self.starter)        try:            total_steps = len(interfaces)  # æ€»æ­¥éª¤æ•°ï¼ˆåŒ…æ‹¬ç»„æ­¥éª¤ï¼‰            executed_steps = 0             # å·²æ‰§è¡Œæ­¥éª¤è®¡æ•°å™¨            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"âœï¸âœï¸  execute  Step {index} ï¼š {interface}")                if interface.enable == 0:                    await self.starter.send(f"âœï¸âœï¸  execute Step {index} ï¼š è°ƒè¯•ç¦ç”¨ è·³è¿‡æ‰§è¡Œ")                    continue                if interface.is_group:                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    group_has_failure = False                    group_executed = 0                    for _index, _interface in enumerate(group_interfaces, start=1):                        if _interface.enable == 0:                            continue  # è·³è¿‡ç¦ç”¨çš„ç»„å†…æ¥å£                        group_executed += 1                        executed_steps += 1  # å…¨å±€æ­¥éª¤è®¡æ•°                        await self.starter.send(f"âœï¸âœï¸  EXECUTE Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        if flag:                            caseResult.success_num += 1                        else:                            group_has_failure = True                            caseResult.fail_num += 1                            caseResult.result = InterfaceAPIResultEnum.ERROR                            if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                                break  # åœæ­¢ç»„å†…æ‰§è¡Œ                    # æ›´æ–°è¿›åº¦ï¼ˆåŸºäºå¤–éƒ¨å¾ªç¯çš„æ¥å£æ­¥éª¤ï¼‰                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                    # è‹¥ç»„å†…å¤±è´¥ä¸”éœ€è¦åœæ­¢ï¼Œç»ˆæ­¢æ•´ä¸ªç”¨ä¾‹                    if group_has_failure and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                        await self.starter.send("ğŸ›‘ğŸ›‘ ç»„æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼Œç»ˆæ­¢ç”¨ä¾‹")                        caseResult.progress = 100                        break  # ç»ˆæ­¢æ•´ä¸ªç”¨ä¾‹                else:                    # å¤„ç†æ™®é€šæ¥å£                    executed_steps += 1                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # å…¥åº“                    await InterfaceAPIWriter.write_interface_result(**result)                    if flag:                        caseResult.success_num += 1                    else:                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            await self.starter.send("ğŸ›‘ğŸ›‘ æ¥å£æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼Œç»ˆæ­¢ç”¨ä¾‹")                            break                    # æ›´æ–°è¿›åº¦                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                await InterfaceAPIWriter.write_process(caseResult=caseResult)                await self.starter.send(f"âœ…âœ…ï¸ FINISH   Step {index} ï¼š {interface}")                await self.starter.send(f"\n")            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")            caseResult.interfaceLog = "".join(self.starter.logs)            return await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)        except Exception as e:            # å¼‚å¸¸å¤„ç†éƒ¨åˆ†            caseResult.status = InterfaceAPIResultEnum.ERROR            caseResult.result = InterfaceAPIResultEnum.ERROR            caseResult.interfaceLog += f"\næœªæ•è·å¼‚å¸¸: {str(e)}"            log.exception(f"ç”¨ä¾‹æ‰§è¡Œå¼‚å¸¸: {str(e)}")            return False        finally:            # ç¡®ä¿æ‰€æœ‰çŠ¶æ€è®¾ç½®å®Œæˆ            if caseResult.status in [InterfaceAPIStatusEnum.RUNNING, None]:                caseResult.status = InterfaceAPIStatusEnum.OVER            # ä¼˜åŒ–æ—¥å¿—æˆªæ–­ï¼ˆè€ƒè™‘å¤šå­—èŠ‚å­—ç¬¦ï¼‰            if caseResult.interfaceLog:                truncated_mark = "\n...[æ—¥å¿—å·²æˆªæ–­]"                max_length = 65535 - len(truncated_mark.encode('utf-8'))                encoded_log = caseResult.interfaceLog.encode('utf-8')[:max_length]                caseResult.interfaceLog = encoded_log.decode('utf-8', 'ignore') + truncated_mark            # å¼ºåˆ¶ä¿å­˜åˆ°æ•°æ®åº“            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            # æ¸…ç†å˜é‡å¹¶ç»“æŸ            await self.vars.clear()            await self.starter.over(caseResult.id)    async def __execute_interface(self,                                  interface: InterfaceModel,                                  caseResult: InterfaceCaseResultModel = None,                                  taskResult: InterfaceTaskResultModel = None                                  ) -> Tuple[Mapping[str, Any], bool]:        """        API æ‰§è¡Œ        è¿”å›æ‰§è¡Œç»“æœï¼Œflag        """        temp_variables = []        asserts_info = None        request_info = None        url = None        after_sql_raw_data = None        after_sql_extracted_vars = {}        before_sql_result = None        before_vars = {}        # è®°å½•è¯·æ±‚æ—¶é—´        t = GenerateTools.getTime(1)        try:            # -1 åˆå§‹åŒ–å…¨å±€å˜é‡            await self.__init_interface_global_vars()            # 0ã€æ¥å£å¤„ç†è¯·æ±‚URL            url = await set_req_url(interface)            log.info(f"ğŸ«³ğŸ«³    å‰ç½®url = {url}")            # 1ã€å‰ç½®å˜é‡å‚æ•°            temp_variables.extend(await self.__exec_before_params(interface.before_params))            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            temp_variables.extend(await self.__exec_before_script(interface.before_script))            # 3.å‰ç½®sql            before_sql_res = await self.__exec_before_sql(interface)            before_sql_result = before_sql_res.get("raw_data")            before_vars = before_sql_res.get("extracted_vars", {})            if before_vars:                before_sql_vars = self.__format_variables(before_vars, InterfaceExtractTargetVariablesEnum.BeforeSQL)                temp_variables.extend(before_sql_vars)            # 3.1 å¤„ç†è¯·æ±‚ æ›¿æ¢å˜é‡            request_info = await self.sender.set_req_info(interface)            url = await self.vars.trans(url)            # 4ã€æ‰§è¡Œæ¥å£è¯·æ±‚            #self.response = await self.sender(url=url, method=interface.method, **request_info)            self.response = await self.sender(url=url, interface=interface, **request_info)            # 5ã€è¿›è¡Œæ–­è¨€            asserts_info = await self.__exec_assert(interface)            # 6ã€å‡ºå‚æå–            temp_variables.extend(await self.__exec_extract(interface))            # 7ã€æ‰§è¡Œåç½®å‡½æ•°            temp_variables.extend(await self.__exec_after_script(interface))            # 8ã€æ‰§è¡Œåç½®SQL            after_sql_res = await self.__exec_after_sql(interface)            after_sql_raw_data = after_sql_res.get("raw_data")            after_sql_extracted_vars = after_sql_res.get("extracted_vars", {})            if after_sql_extracted_vars:                after_sql_vars = self.__format_variables(after_sql_extracted_vars, InterfaceExtractTargetVariablesEnum.AfterSQL)                temp_variables.extend(after_sql_vars)        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            self.response = f"{str(e)} to {url}"        finally:            request_info['url'] = url            return await InterfaceAPIWriter.set_interface_result_info(                startTime=t,                starter=self.starter,                request_info=request_info,                interface=interface,                response=self.response,                asserts=asserts_info,                caseResult=caseResult,                taskResult=taskResult,                variables=temp_variables,                # ä¼ é€’å‰åç½®SQLç»“æœ                before_sql_result=before_sql_result,                before_vars=before_vars,                after_sql_result=after_sql_raw_data,                after_vars=after_sql_extracted_vars            )    def __format_variables(self, vars_dict: Dict[str, Any], target_enum) -> List[Dict[str, Any]]:        """æ ¼å¼åŒ–å˜é‡ï¼ˆå…¬å…±æ–¹æ³•ï¼‰"""        return [            {                InterfaceExtractTargetVariablesEnum.KEY: k,                InterfaceExtractTargetVariablesEnum.VALUE: v,                InterfaceExtractTargetVariablesEnum.Target: target_enum            }            for k, v in vars_dict.items()        ]    async def __exec_before_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """å¤„ç†å‰ç½®è„šæœ¬"""        if script:            exe = ExecScriptForInterface()            _extracted_vars = exe.exec_script(script)            # ä¿®å¤ç‚¹2ï¼šä½¿ç”¨ vars.add_vars è€Œä¸æ˜¯ set_variables            await self.vars.add_vars(_extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®è„šæœ¬ = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = self.__format_variables(_extracted_vars, InterfaceExtractTargetVariablesEnum.BeforeScript)            return _vars        return []    async def __exec_before_params(self, before_params: List[Dict[str, Any]] = None):        """å¤„ç†å‰ç½®å‚æ•°"""        if before_params:            # ä¿®å¤ç‚¹3ï¼šä½¿ç”¨ vars.trans è¿›è¡Œå˜é‡è½¬æ¢            values = await self.vars.trans(before_params)            await self.vars.add_vars(values)            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®å‚æ•° = {json.dumps(values, ensure_ascii=False)}")            _vars = self.__format_variables(values, InterfaceExtractTargetVariablesEnum.BeforeParams)            return _vars        return []    async def __exec_before_sql(self, interface: InterfaceModel):        """æ‰§è¡Œå‰ç½®SQLæ“ä½œ"""        default_result = {"raw_data": None, "extracted_vars": {}}        if not interface.before_sql or not interface.before_db_id:            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.before_db_id)            if not _db:                log.warning(f"æœªæ‰¾åˆ°æ•°æ®åº“é…ç½® ID: {interface.before_db_id}")                return default_result            # ä¿®å¤ç‚¹4ï¼šä½¿ç”¨ vars.trans è¿›è¡Œå˜é‡è½¬æ¢            script = await self.vars.trans(interface.before_sql.strip())            db_script = ExecDBScript(self.starter, script, interface.before_sql_extracts)            await self.starter.send(f"ğŸ“ å‰ç½®SQLè¯­å¥: {script}")            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"ğŸ«³ğŸ«³ æ•°æ®åº“è¯»å– = {json.dumps(res, ensure_ascii=False)}")            if res:                # SELECTæŸ¥è¯¢æ“ä½œ                if "raw_data" in res and "extracted_vars" in res:                    raw_data = res["raw_data"]                    extracted_vars = res["extracted_vars"]                # å†™æ“ä½œï¼ˆUPDATE/INSERT/DELETEï¼‰                elif "execution_info" in res:                    raw_data = res["execution_info"]                    extracted_vars = {                        "rows_affected": raw_data.get("rows_affected", 0),                        "execution_status": raw_data.get("status", "SUCCESS")                    }                else:                    raw_data = res                    extracted_vars = {}                # æ³¨å…¥å˜é‡æ±                 await self.vars.add_vars(extracted_vars)                return {                    "raw_data": raw_data,                    "extracted_vars": extracted_vars                }            return default_result        except Exception as e:            log.error(f"æ‰§è¡Œå‰ç½®SQLå¤±è´¥: {str(e)}")            await self.starter.send(f"âŒ å‰ç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")            return default_result    async def __exec_after_sql(self, interface: InterfaceModel):        """æ‰§è¡Œåç½®SQLæ“ä½œ"""        default_result = {"raw_data": None, "extracted_vars": {}}        if not interface.after_sql or not interface.after_db_id:            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.after_db_id)            if not _db:                log.warning(f"æœªæ‰¾åˆ°åç½®æ•°æ®åº“é…ç½® ID: {interface.after_db_id}")                return default_result            # ä¿®å¤ç‚¹5ï¼šä½¿ç”¨ vars.trans è¿›è¡Œå˜é‡è½¬æ¢            script = await self.vars.trans(interface.after_sql.strip())            await self.starter.send(f"ğŸ“ åç½®SQLè¯­å¥: {script}")            db_script = ExecDBScript(self.starter, script, interface.after_sql_extracts)            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"ğŸ«³ğŸ«³ åç½®æ•°æ®åº“æ“ä½œç»“æœ = {json.dumps(res, ensure_ascii=False)}")            if res:                # æƒ…å†µ1ï¼šå†™æ“ä½œï¼ˆåŒ…å«execution_infoï¼‰                if isinstance(res, dict) and "execution_info" in res:                    rows_affected = res["execution_info"].get("rows_affected", 0)                    extracted_vars = {                        "rows_affected": rows_affected,                        "execution_status": res["execution_info"].get("status", "SUCCESS")                    }                    if res.get("extracted_vars"):                        extracted_vars.update(res["extracted_vars"])                    default_result["raw_data"] = res["execution_info"]                    default_result["extracted_vars"] = extracted_vars                else:                    # æƒ…å†µ2ï¼šSELECTæŸ¥è¯¢æ“ä½œ                    default_result["raw_data"] = res.get("raw_data")                    default_result["extracted_vars"] = res.get("extracted_vars", {})                # ç¡®ä¿extracted_varsæ˜¯å­—å…¸ç±»å‹                if default_result["extracted_vars"] is None:                    default_result["extracted_vars"] = {}                # æ³¨å…¥å˜é‡æ±                 await self.vars.add_vars(default_result["extracted_vars"])                await self.starter.send(f"âœ… åç½®SQLæå–ç»“æœ: extracted_vars={default_result['extracted_vars']}")            return default_result        except Exception as e:            log.error(f"æ‰§è¡Œåç½®SQLå¤±è´¥: {str(e)}")            await self.starter.send(f"âŒ åç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")            return default_result    async def __exec_assert(self, interface: InterfaceModel):        """å“åº”æ–­è¨€"""        _assert = ExecAsserts(self.response, self.vars())        asserts_info = await _assert(interface.asserts)        await self.starter.send(f"ğŸ«³ğŸ«³    å“åº”æ–­è¨€ = {json.dumps(asserts_info, ensure_ascii=False)}")        return asserts_info    async def __exec_extract(self, interface: InterfaceModel):        """å˜é‡æå–"""        if interface.extracts and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExecResponseExtract(response=self.response)            _vars = await _extract(interface.extracts)            await self.starter.send(f"ğŸ«³ğŸ«³  å“åº”å‚æ•°æå– = {json.dumps(_vars, ensure_ascii=False)}")            # ä¿®å¤ç‚¹6ï¼šä½¿ç”¨ vars.add_vars            await self.vars.add_vars(_vars)            return _vars        return []    async def __exec_after_script(self, interface: InterfaceModel):        """æ‰§è¡Œåç½®è„šæœ¬"""        if interface.after_script and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            exe = ExecScriptForInterface(response=self.response)            extracted_vars = exe.exec_script(interface.after_script)            # ä¿®å¤ç‚¹7ï¼šä½¿ç”¨ vars.add_vars            await self.vars.add_vars(extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³ åç½®è„šæœ¬ = {json.dumps(extracted_vars, ensure_ascii=False)}")            _vars = self.__format_variables(extracted_vars, InterfaceExtractTargetVariablesEnum.AfterScript)            return _vars        return []    async def __init_interface_case_vars(self, interfaceCase: InterfaceCase):        """åˆå§‹åŒ–ç”¨ä¾‹å˜é‡"""        try:            interfaceCaseVars: List[InterfaceVariables] = await InterfaceVarsMapper.query_by(case_id=interfaceCase.id)            if interfaceCaseVars:                for var in interfaceCaseVars:                    if var.value.startswith("{{$"):                        _v = var.value[3:-2]                        # ä¿®å¤ç‚¹8ï¼šä½¿ç”¨ vars.add_var è€Œä¸æ˜¯ç›´æ¥æ“ä½œå­—å…¸                        await self.vars.add_var(var.key, self.faker.value(_v))                    else:                        await self.vars.add_var(var.key, var.value)            if self.vars():                await self.starter.send(f"ğŸ«³ğŸ«³ åˆå§‹åŒ–ç”¨ä¾‹å˜é‡ = {json.dumps(self.vars(), ensure_ascii=False)}")        except Exception as e:            log.error(e)    async def __init_interface_global_vars(self):        """åˆå§‹åŒ–å…¨å±€å˜é‡"""        try:            g_vars = await GlobalVariableMapper.query_all()            if g_vars:                for g_var in g_vars:                    # ä¿®å¤ç‚¹9ï¼šä½¿ç”¨ vars.add_var                    await self.vars.add_var(g_var.key, g_var.value)        except Exception as e:            log.warning(f"åˆå§‹åŒ–å…¨å±€å˜é‡å¤±è´¥: {e}")