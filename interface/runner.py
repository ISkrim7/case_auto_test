import asyncioimport jsonfrom datetime import datetimefrom typing import List, Dict, Any, Mapping, TypeVar, Tuplefrom httpx import Responsefrom app.mapper.interface.interfaceGroupMapper import InterfaceGroupMapperfrom app.mapper.interface.interfaceVarsMapper import InterfaceVarsMapperfrom app.mapper.project.dbConfigMapper import DbConfigMapperfrom app.mapper.project.env import EnvMapperfrom app.mapper.project import GlobalVariableMapperfrom app.model.interface import InterfaceModel, InterfaceCaseResultModel, InterFaceCaseModel, InterfaceTaskResultModel, \    InterfaceVariablesfrom app.model.interface.InterfaceCaseStepContent import InterfaceCaseStepContent, InterfaceConditionfrom enums import InterfaceExtractTargetVariablesEnum, InterfaceResponseStatusCodeEnum, InterfaceAPIResultEnum, \    InterfaceCaseErrorStep, InterfaceAPIStatusEnumfrom enums.CaseEnum import CaseStepContentTypefrom play.starter import UIStarterfrom utils import MyLoguru, GenerateToolsfrom app.mapper.interface import InterfaceMapper, InterfaceConditionMapper, InterfaceGroupResultMapper, \    InterfaceConditionResultMapper, InterfaceCaseMapperfrom utils.execDBScript import ExecDBScriptfrom interface.exec import *from utils.variableTrans import VariableTransfrom .middleware import HttpxMiddlewarefrom .starter import APIStarterfrom .writer import InterfaceAPIWriterfrom common.fakerClient import FakerClientlog = MyLoguru().get_logger()Interface = TypeVar('Interface', bound=InterfaceModel)InterfaceCase = TypeVar('InterfaceCase', bound=InterFaceCaseModel)Interfaces = List[Interface]InterFaceCases = List[InterfaceCaseStepContent]async def set_req_url(interface: Interface) -> str:    """    è®¾ç½®è¯·æ±‚urlï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„å®ç°ï¼‰    :param interface:    :return:    """    try:        if interface.env_id == -1:            return interface.url        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            domain = env.host            if env.port:                domain += f":{env.port}"            return domain + interface.url    except Exception as e:        log.error(f"è®¾ç½®è¯·æ±‚urlå¤±è´¥ = {e}")        raise ValueError("è¯·æ±‚ç¯å¢ƒä¸å­˜åœ¨ã€è¯·æ£€æŸ¥")class InterFaceRunner:    response: Response | str = None    def __init__(self, starter: APIStarter | UIStarter):        self.starter = starter        self.vars = VariableTrans()        self.sender = HttpxMiddleware(self.vars, self.starter)        self.faker = FakerClient()  # ä¿ç•™è€ç‰ˆæœ¬çš„fakeråŠŸèƒ½    async def execute_interface_by_ui(self, interface: Interface, ui_vars: Dict[str, Any] | None = None):        """        ui ä¾§æ‰§è¡Œæ¥å£        :param interfaceï¼šæ¥å£å¯¹è±¡        :param ui_vars: ui å˜é‡        """        if ui_vars:            await self.vars.add_vars(ui_vars)        result, _ = await self.__execute_interface(interface)        return result, _    async def try_interface(self, interface: int) -> Mapping[str, Any]:        """        æ‰§è¡Œå•ä¸ªæ¥å£è¯·æ±‚è°ƒè¯•        æ— å˜é‡ã€æœ‰å‰ç½®æ–¹æ³•ã€        éœ€è¦è¿”å›response        """        interface = await InterfaceMapper.get_by_id(ident=interface)        result, _ = await self.__execute_interface(interface)        return result    async def get_interface(self, interfaceId: int, use_var: bool = False):        """è·å–æ¥å£ä¿¡æ¯"""        interface: Interface = await InterfaceMapper.get_by_id(ident=interfaceId)        # è‡ªå®šä¹‰ç¯å¢ƒ        if interface.env_id == -1:            from utils import Tools            parse = Tools.parse_url(interface.url)            url = parse.path            host = f"{parse.scheme}://{parse.netloc}"        else:            env = await EnvMapper.get_by_id(ident=interface.env_id)            host = env.host            url = interface.url            if env.port:                host += f":{env.port}"        if use_var:            # 1ã€å‰ç½®å˜é‡å‚æ•°            await self.__exec_before_params(interface.before_params)            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            await self.__exec_before_script(interface.before_script)            # 3.å‰ç½®sql            await self.__exec_before_sql(interface)            url = await self.sender.transform_target(target=url)        info = await self.sender.set_req_info(interface)        info.pop("follow_redirects")        info.pop("read")        info.pop("connect")        return {            "name": interface.name,            "method": interface.method.lower(),            "url": url,            "host": host,            "asserts": interface.asserts,            **info        }    async def try_group(self, groupId: int):        """        æ‰§è¡Œæ¥å£ç»„        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=groupId)        results = []        for interface in interfaces:            await self.starter.send(f"âœï¸âœï¸  Execute    {interface}")            result, _ = await self.__execute_interface(interface)            results.append(result)        return results    async def run_interface_by_task(self, interface: Interface, taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œapi"""        result, _ = await self.__execute_interface(interface=interface, taskResult=taskResult)        await InterfaceAPIWriter.write_interface_result(**result)        return _    async def run_interfaceCase_by_task(self, interfaceCase: InterfaceCase,                                        taskResult: InterfaceTaskResultModel) -> bool:        """ä»»åŠ¡æ‰§è¡Œcaseï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„ä»»åŠ¡æ‰§è¡Œé€»è¾‘ï¼‰"""        interfaces: Interfaces = await InterfaceCaseMapper.query_interface_by_caseId(caseId=interfaceCase.id)        await self.starter.send(f"â±ï¸â±ï¸    ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"â±ï¸â±ï¸    æŸ¥è¯¢åˆ°å…³è”API x {len(interfaces)} ...")        # å…³è”çš„ API        interfacesNum = len(interfaces)        caseResult = await InterfaceAPIWriter.init_interface_case_result(interfaceCase=interfaceCase,                                                                         taskId=taskResult.id,                                                                         starter=self.starter)        await self.starter.send(f"åˆå§‹åŒ–ç»“æœæ¨¡å‹ ã€‚ã€‚ã€‚ âœ… ID= '{caseResult.uid}'")        _f = True        try:            for index, interface in enumerate(interfaces, start=1):                await self.starter.send(f"Execute  Step {index} ï¼š {interface}")                if interface.is_group:                    # æ‰§è¡Œæ­¥éª¤ç»„                    group_interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=interface.group_id)                    for _index, _interface in enumerate(group_interfaces, start=1):                        await self.starter.send(f"Execute Group Step {_index} : {_interface} ")                        result, flag = await self.__execute_interface(interface=_interface, caseResult=caseResult)                        await InterfaceAPIWriter.write_interface_result(interfaceGroupId=interface.group_id, **result)                        if not flag:                            _f = False                            caseResult.result = InterfaceAPIResultEnum.ERROR                            break                else:                    result, flag = await self.__execute_interface(interface=interface, caseResult=caseResult)                    # å…¥åº“                    await InterfaceAPIWriter.write_interface_result(**result)                    caseResult.progress = round(index / interfacesNum, 1) * 100                    if flag:                        caseResult.success_num += 1                    else:                        _f = False                        caseResult.result = InterfaceAPIResultEnum.ERROR                        caseResult.fail_num += 1                        if interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                            caseResult.progress = 100                            break                await InterfaceAPIWriter.write_process(caseResult=caseResult)            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return _f        finally:            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")    async def run_interCase(self, interfaceCaseId: int, task: InterfaceTaskResultModel = None):        """        æ‰§è¡Œæ¥å£ç”¨ä¾‹ï¼ˆä½¿ç”¨æ–°ç‰ˆæœ¬çš„æ¶æ„ï¼‰        """        # æŸ¥è¯¢ç”¨ä¾‹        interfaceCase: InterfaceCase = await InterfaceCaseMapper.get_by_id(ident=interfaceCaseId)        if not interfaceCase:            await self.starter.send(f"æœªæ‰¾åˆ°ç”¨ä¾‹ {interfaceCaseId}")            return await self.starter.over()        # æŸ¥è¯¢ç”¨ä¾‹æ­¥éª¤å†…å®¹        case_steps: InterFaceCases = await InterfaceCaseMapper.query_content(case_id=interfaceCaseId)        await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œå¼€å§‹ã€‚æ‰§è¡Œäºº {self.starter.username}")        await self.starter.send(f"æŸ¥è¯¢åˆ°å…³è”Step x {len(case_steps)} ...")        if not case_steps:            await self.starter.send("æ— å¯æ‰§è¡Œæ­¥éª¤ï¼Œç»“æŸæ‰§è¡Œ")            return await self.starter.over()        # åŠ è½½ç”¨ä¾‹ä¸“å±å˜é‡        await self.__init_interface_case_vars(interfaceCase)        # åˆå§‹åŒ–ç”¨ä¾‹ç»“æœå¯¹è±¡        caseResult = await InterfaceAPIWriter.init_interface_case_result(            interfaceCase=interfaceCase,            task=task,            starter=self.starter        )        flag = True        try:            total_steps = len([step for step in case_steps if step.enable != 0 or task])  # æœ‰æ•ˆæ­¥éª¤æ€»æ•°            executed_steps = 0  # å·²æ‰§è¡Œæ­¥éª¤è®¡æ•°å™¨            for index, _step_content in enumerate(case_steps, start=1):                # æ­¥éª¤å¼€å…³æ—¨åœ¨ç”¨ä¾‹è°ƒè¯•ä¸­ä½¿ç”¨ï¼Œä»»åŠ¡æ‰§è¡Œé»˜è®¤å¼€å¯                if _step_content.enable == 0 and not task:                    await self.starter.send(f"âœï¸âœï¸  EXECUTE_STEP {index} ï¼š è°ƒè¯•ç¦ç”¨ è·³è¿‡æ‰§è¡Œ")                    continue                await self.starter.send(f"âœï¸âœï¸  EXECUTE_STEP {index} ï¼š {_step_content}")                # å¦‚æœ flag å·²ç»æ˜¯ False ä¸”éœ€è¦é”™è¯¯åœæ­¢ï¼Œåˆ™è·³è¿‡åç»­æ­¥éª¤                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    await self.starter.send(f"â­ï¸â­ï¸  SKIP_STEP {index} ï¼š é‡åˆ°é”™è¯¯å·²åœæ­¢")                    continue                step_result = True                match _step_content.content_type:                    # æ‰§è¡Œå•æ¥å£                    case CaseStepContentType.STEP_API:                        step_result = await self.__execute_single_api(                            interface_id=_step_content.target_id,                            case_result=caseResult                        )                        if step_result:                            executed_steps += 1                    # æ‰§è¡Œæ¥å£ç»„                    case CaseStepContentType.STEP_API_GROUP:                        step_result = await self.__execute_group_apis(                            case_step=_step_content,                            case_result=caseResult                        )                        if step_result:                            executed_steps += 1                    # æ‰§è¡Œæ¡ä»¶æ¥å£                    case CaseStepContentType.STEP_API_CONDITION:                        step_result = await self.__execute_condition_apis(                            case_step=_step_content,                            case_result=caseResult                        )                        if step_result:                            executed_steps += 1                    # æ‰§è¡Œç­‰å¾…                    case CaseStepContentType.STEP_API_WAIT:                        await self.starter.send(f"â°â°  ç­‰å¾… {_step_content.api_wait_time} ç§’")                        await asyncio.sleep(_step_content.api_wait_time)                        executed_steps += 1                        continue                    # æ‰§è¡Œè„šæœ¬                    case CaseStepContentType.STEP_API_SCRIPT:                        await self.__exec_script(script=_step_content.api_script_text)                        executed_steps += 1                        continue                # æ›´æ–°è¿›åº¦ï¼ˆåŸºäºæœ‰æ•ˆæ­¥éª¤ï¼‰                if total_steps > 0:                    caseResult.progress = min(round(executed_steps / total_steps * 100, 2), 100)                # ä¸€æ—¦ flag å˜ä¸º Falseï¼Œå°±ä¸å†å˜å› True                flag = flag and step_result                # é‡åˆ°é”™è¯¯åœæ­¢                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    caseResult.progress = 100                    await self.starter.send("ğŸ›‘ğŸ›‘ æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼Œç»ˆæ­¢ç”¨ä¾‹")                await InterfaceAPIWriter.write_process(caseResult=caseResult)                await self.starter.send(f"âœ…âœ…ï¸ FINISH STEP {index} ï¼š {_step_content}")                await self.starter.send(f"\n")                # é”™è¯¯åœæ­¢æ—¶è·³å‡ºå¾ªç¯                if not flag and interfaceCase.error_stop == InterfaceCaseErrorStep.STOP:                    break            await self.starter.send(f"ç”¨ä¾‹ {interfaceCase.title} æ‰§è¡Œç»“æŸ")            await self.starter.send(f"{'====' * 20}")            caseResult.interfaceLog = "".join(self.starter.logs)            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            return flag        except Exception as e:            # å¼‚å¸¸å¤„ç†éƒ¨åˆ†ï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„å¼‚å¸¸å¤„ç†é€»è¾‘ï¼‰            caseResult.status = InterfaceAPIResultEnum.ERROR            caseResult.result = InterfaceAPIResultEnum.ERROR            caseResult.interfaceLog += f"\næœªæ•è·å¼‚å¸¸: {str(e)}"            log.exception(f"ç”¨ä¾‹æ‰§è¡Œå¼‚å¸¸: {str(e)}")            return False        finally:            # ç¡®ä¿æ‰€æœ‰çŠ¶æ€è®¾ç½®å®Œæˆï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„æ¸…ç†é€»è¾‘ï¼‰            if caseResult.status in [InterfaceAPIStatusEnum.RUNNING, None]:                caseResult.status = InterfaceAPIStatusEnum.OVER            # ä¼˜åŒ–æ—¥å¿—æˆªæ–­ï¼ˆè€ƒè™‘å¤šå­—èŠ‚å­—ç¬¦ï¼‰            if caseResult.interfaceLog:                truncated_mark = "\n...[æ—¥å¿—å·²æˆªæ–­]"                max_length = 65535 - len(truncated_mark.encode('utf-8'))                encoded_log = caseResult.interfaceLog.encode('utf-8')[:max_length]                caseResult.interfaceLog = encoded_log.decode('utf-8', 'ignore') + truncated_mark            # å¼ºåˆ¶ä¿å­˜åˆ°æ•°æ®åº“            await InterfaceAPIWriter.write_interface_case_result(caseResult=caseResult)            # æ¸…ç†å˜é‡å¹¶ç»“æŸ            await self.vars.clear()            await self.starter.over(caseResult.id)    async def __execute_single_api(self, interface_id: int, case_result: InterfaceCaseResultModel):        """        apiç±»å‹ç”¨ä¾‹æ‰§è¡Œ        """        interface: Interface = await InterfaceMapper.get_by_id(ident=interface_id)        result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)        await InterfaceAPIWriter.write_interface_result(**result)        if flag:            case_result.success_num += 1        else:            case_result.result = InterfaceAPIResultEnum.ERROR            case_result.fail_num += 1        return flag    async def __execute_condition_apis(self, case_step: InterfaceCaseStepContent,                                       case_result: InterfaceCaseResultModel):        """        é€»è¾‘ APIæ‰§è¡Œ        :param case_result ç”¨ä¾‹ç»“æœæ¨¡å‹        :param case_step  ç”¨ä¾‹æ­¥éª¤        """        condition: InterfaceCondition = await InterfaceConditionMapper.get_by_id(ident=case_step.target_id)        _execCondition = ExecCondition(self.vars)        flag = await _execCondition.invoke(condition, self.starter)        # é€»è¾‘é€šè¿‡ æ‰§è¡Œå­æ­¥éª¤        if flag:            condition_apis = await InterfaceConditionMapper.query_condition_apis_by_content_id(condition.id)            condition_result = await InterfaceConditionResultMapper.init_model(                condition_name=_execCondition.doc,                condition_api_num=len(condition_apis),                interface_case_result_id=case_result.id            )            if len(condition_apis) == 0:                return True            for index, interface in enumerate(condition_apis, start=1):                await self.starter.send(f"âœï¸âœï¸  execute Condition Step {index} : {interface} ")                result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)                await InterfaceAPIWriter.write_interface_result(                    interface_condition_result_id=condition_result.id,                    **result)                # æŠ¥é”™åœæ­¢                if not flag:                    case_result.result = InterfaceAPIResultEnum.ERROR                    case_result.fail_num += 1                    return False            case_result.success_num += 1            return True        else:            # æ¡ä»¶ä¸é€šè¿‡ï¼Œè·³è¿‡æ‰§è¡Œ            await self.starter.send("â­ï¸â­ï¸ æ¡ä»¶åˆ¤æ–­æœªé€šè¿‡ï¼Œè·³è¿‡æ‰§è¡Œ")            return True    async def __execute_group_apis(self, case_step: InterfaceCaseStepContent,                                   case_result: InterfaceCaseResultModel):        """        ç»„å†… APIæ‰§è¡Œ        :param case_result ç”¨ä¾‹ç»“æœæ¨¡å‹        :param case_step  ç”¨ä¾‹æ­¥éª¤        """        interfaces: Interfaces = await InterfaceGroupMapper.query_apis(groupId=case_step.target_id)        if not interfaces:            return True        # åˆå§‹åŒ–GROUP RESULT        group_result = await InterfaceGroupResultMapper.init_model(            group_name=case_step.content_name,            group_api_num=len(interfaces),            interface_case_result_id=case_result.id        )        for index, interface in enumerate(interfaces, start=1):            await self.starter.send(f"âœï¸âœï¸  EXECUTE GROUP STEP {index} : {interface}")            result, flag = await self.__execute_interface(interface=interface, caseResult=case_result)            # å†™APIç»“æœ å…³è”Group result            await InterfaceAPIWriter.write_interface_result(interface_group_result_id=group_result.id, **result)            # æŠ¥é”™åœæ­¢            if not flag:                case_result.result = InterfaceAPIResultEnum.ERROR                case_result.fail_num += 1                return False        case_result.success_num += 1        return True    async def __execute_interface(self,                                  interface: InterfaceModel,                                  caseResult: InterfaceCaseResultModel = None,                                  taskResult: InterfaceTaskResultModel = None                                  ) -> Tuple[Mapping[str, Any], bool]:        """        API æ‰§è¡Œ        è¿”å›æ‰§è¡Œç»“æœï¼Œflag        ï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬å‰åç½®SQLå¤„ç†ï¼‰        """        temp_variables = []        asserts_info = None        request_info = None        url = None        after_sql_raw_data = None        after_sql_extracted_vars = {}        before_sql_result = None        before_vars = {}        # è®°å½•è¯·æ±‚æ—¶é—´        t = GenerateTools.getTime(1)        try:            # -1 åˆå§‹åŒ–å…¨å±€å˜é‡ï¼ˆä¿ç•™è€ç‰ˆæœ¬åŠŸèƒ½ï¼‰            await self.__init_interface_global_vars()            # 0ã€æ¥å£å¤„ç†è¯·æ±‚URL            url = await set_req_url(interface)            log.info(f"ğŸ«³ğŸ«³    å‰ç½®url = {url}")            # 1ã€å‰ç½®å˜é‡å‚æ•°            temp_variables.extend(await self.__exec_before_params(interface.before_params))            # 2ã€æ‰§è¡Œå‰ç½®å‡½æ•°            temp_variables.extend(await self.__exec_before_script(interface.before_script))            # 3.å‰ç½®sql            before_sql_res = await self.__exec_before_sql(interface)            before_sql_result = before_sql_res.get("raw_data")            before_vars = before_sql_res.get("extracted_vars", {})            if before_vars:                before_sql_vars = self.__format_variables(before_vars, InterfaceExtractTargetVariablesEnum.BeforeSQL)                temp_variables.extend(before_sql_vars)            # 3.1 å¤„ç†è¯·æ±‚ æ›¿æ¢å˜é‡            request_info = await self.sender.set_req_info(interface)            url = await self.vars.trans(url)            # 4ã€æ‰§è¡Œæ¥å£è¯·æ±‚            self.response = await self.sender(url=url, interface=interface, **request_info)            # 5ã€è¿›è¡Œæ–­è¨€            try:                asserts_info = await self.__exec_assert(interface)                await self.starter.send("âœ… æ–­è¨€æ‰§è¡Œå®Œæˆ")            except Exception as e:                log.error(f"æ–­è¨€æ‰§è¡Œå¤±è´¥: {str(e)}")                await self.starter.send(f"âŒ æ–­è¨€æ‰§è¡Œå¤±è´¥: {str(e)}")                raise            # 6ã€å‡ºå‚æå–            try:                extracted_vars = await self.__exec_extract(interface)                temp_variables.extend(extracted_vars)                await self.starter.send("âœ… å˜é‡æå–å®Œæˆ")            except Exception as e:                log.error(f"å˜é‡æå–å¤±è´¥: {str(e)}")                await self.starter.send(f"âŒ å˜é‡æå–å¤±è´¥: {str(e)}")                raise            # 7ã€æ‰§è¡Œåç½®å‡½æ•°            try:                after_script_vars = await self.__exec_after_script(interface)                temp_variables.extend(after_script_vars)                await self.starter.send("âœ… åç½®è„šæœ¬æ‰§è¡Œå®Œæˆ")            except Exception as e:                log.error(f"åç½®è„šæœ¬æ‰§è¡Œå¤±è´¥: {str(e)}")                await self.starter.send(f"âŒ åç½®è„šæœ¬æ‰§è¡Œå¤±è´¥: {str(e)}")                raise            # 8ã€æ‰§è¡Œåç½®SQL            try:                after_sql_res = await self.__exec_after_sql(interface)                after_sql_raw_data = after_sql_res.get("raw_data")                after_sql_extracted_vars = after_sql_res.get("extracted_vars", {})                if after_sql_extracted_vars:                    after_sql_vars = self.__format_variables(after_sql_extracted_vars, InterfaceExtractTargetVariablesEnum.AfterSQL)                    temp_variables.extend(after_sql_vars)                await self.starter.send("âœ… åç½®SQLæ‰§è¡Œå®Œæˆ")            except Exception as e:                log.error(f"åç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")                await self.starter.send(f"âŒ åç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")                raise        except Exception as e:            log.exception(e)            await self.starter.send(f"Error occurred: \"{str(e)}\"")            self.response = f"{str(e)} to {url}"        finally:            request_info['url'] = url            return await InterfaceAPIWriter.set_interface_result_info(                startTime=t,                starter=self.starter,                request_info=request_info,                interface=interface,                response=self.response,                asserts=asserts_info,                caseResult=caseResult,                taskResult=taskResult,                variables=temp_variables,                # ä¼ é€’å‰åç½®SQLç»“æœ                before_sql_result=before_sql_result,                before_vars=before_vars,                after_sql_result=after_sql_raw_data,                after_vars=after_sql_extracted_vars            )    def __format_variables(self, vars_dict: Dict[str, Any], target_enum) -> List[Dict[str, Any]]:        """æ ¼å¼åŒ–å˜é‡ï¼ˆå…¬å…±æ–¹æ³•ï¼‰"""        return [            {                InterfaceExtractTargetVariablesEnum.KEY: k,                InterfaceExtractTargetVariablesEnum.VALUE: v,                InterfaceExtractTargetVariablesEnum.Target: target_enum            }            for k, v in vars_dict.items()        ]    async def __exec_before_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """å¤„ç†å‰ç½®è„šæœ¬"""        if script:            exe = ExecScriptForInterface()            _extracted_vars = exe.exec_script(script)            await self.vars.add_vars(_extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®è„šæœ¬ = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = self.__format_variables(_extracted_vars, InterfaceExtractTargetVariablesEnum.BeforeScript)            return _vars        return []    async def __exec_script(self, script: str) -> List[Any] | List[Mapping[str, Any]]:        """é€šç”¨è„šæœ¬æ‰§è¡Œï¼ˆç”¨äºæ­¥éª¤ä¸­çš„è„šæœ¬æ‰§è¡Œï¼‰"""        if script:            exe = ExecSafeScript()            _extracted_vars = exe.execute(script)            await self.vars.add_vars(_extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³  è„šæœ¬ = {json.dumps(_extracted_vars, ensure_ascii=False)}")            _vars = self.__format_variables(_extracted_vars, InterfaceExtractTargetVariablesEnum.BeforeScript)            return _vars        return []    async def __exec_after_script(self, interface: InterfaceModel):        """æ‰§è¡Œåç½®è„šæœ¬"""        if interface.after_script and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            exe = ExecScriptForInterface(response=self.response)            extracted_vars = exe.exec_script(interface.after_script)            await self.vars.add_vars(extracted_vars)            await self.starter.send(f"ğŸ«³ğŸ«³ åç½®è„šæœ¬ = {json.dumps(extracted_vars, ensure_ascii=False)}")            _vars = self.__format_variables(extracted_vars, InterfaceExtractTargetVariablesEnum.AfterScript)            return _vars        return []    async def __exec_before_params(self, before_params: List[Dict[str, Any]] = None):        """å¤„ç†å‰ç½®å‚æ•°"""        if before_params:            values = await self.vars.trans(before_params)            await self.vars.add_vars(values)            await self.starter.send(f"ğŸ«³ğŸ«³ å‰ç½®å‚æ•° = {json.dumps(values, ensure_ascii=False)}")            _vars = self.__format_variables(values, InterfaceExtractTargetVariablesEnum.BeforeParams)            return _vars        return []    async def __exec_before_sql(self, interface: InterfaceModel):        """æ‰§è¡Œå‰ç½®SQLæ“ä½œï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„å®Œæ•´å®ç°ï¼‰"""        default_result = {"raw_data": None, "extracted_vars": {}}        if not interface.before_sql or not interface.before_db_id:            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.before_db_id)            if not _db:                log.warning(f"æœªæ‰¾åˆ°æ•°æ®åº“é…ç½® ID: {interface.before_db_id}")                return default_result            script = await self.vars.trans(interface.before_sql.strip())            db_script = ExecDBScript(self.starter, script, interface.before_sql_extracts)            await self.starter.send(f"ğŸ“ å‰ç½®SQLè¯­å¥: {script}")            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"ğŸ«³ğŸ«³ æ•°æ®åº“è¯»å– = {json.dumps(res, ensure_ascii=False)}")            if res:                # SELECTæŸ¥è¯¢æ“ä½œ                if "raw_data" in res and "extracted_vars" in res:                    raw_data = res["raw_data"]                    extracted_vars = res["extracted_vars"]                # å†™æ“ä½œï¼ˆUPDATE/INSERT/DELETEï¼‰                elif "execution_info" in res:                    raw_data = res["execution_info"]                    extracted_vars = {                        "rows_affected": raw_data.get("rows_affected", 0),                        "execution_status": raw_data.get("status", "SUCCESS")                    }                else:                    raw_data = res                    extracted_vars = {}                # æ³¨å…¥å˜é‡æ±                 await self.vars.add_vars(extracted_vars)                return {                    "raw_data": raw_data,                    "extracted_vars": extracted_vars                }            return default_result        except Exception as e:            log.error(f"æ‰§è¡Œå‰ç½®SQLå¤±è´¥: {str(e)}")            await self.starter.send(f"âŒ å‰ç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")            return default_result    async def __exec_after_sql(self, interface: InterfaceModel):        """æ‰§è¡Œåç½®SQLæ“ä½œï¼ˆä¿ç•™è€ç‰ˆæœ¬çš„å®Œæ•´å®ç°ï¼‰"""        default_result = {"raw_data": None, "extracted_vars": {}}        if not interface.after_sql or not interface.after_db_id:            return default_result        try:            _db = await DbConfigMapper.get_by_id(interface.after_db_id)            if not _db:                log.warning(f"æœªæ‰¾åˆ°åç½®æ•°æ®åº“é…ç½® ID: {interface.after_db_id}")                return default_result            script = await self.vars.trans(interface.after_sql.strip())            await self.starter.send(f"ğŸ“ åç½®SQLè¯­å¥: {script}")            db_script = ExecDBScript(self.starter, script, interface.after_sql_extracts)            res = await db_script.invoke(_db.db_type, **_db.config)            await self.starter.send(f"ğŸ«³ğŸ«³ åç½®æ•°æ®åº“æ“ä½œç»“æœ = {json.dumps(res, ensure_ascii=False)}")            if res:                # æƒ…å†µ1ï¼šå†™æ“ä½œï¼ˆåŒ…å«execution_infoï¼‰                if isinstance(res, dict) and "execution_info" in res:                    rows_affected = res["execution_info"].get("rows_affected", 0)                    extracted_vars = {                        "rows_affected": rows_affected,                        "execution_status": res["execution_info"].get("status", "SUCCESS")                    }                    if res.get("extracted_vars"):                        extracted_vars.update(res["extracted_vars"])                    default_result["raw_data"] = res["execution_info"]                    default_result["extracted_vars"] = extracted_vars                else:                    # æƒ…å†µ2ï¼šSELECTæŸ¥è¯¢æ“ä½œ                    default_result["raw_data"] = res.get("raw_data")                    default_result["extracted_vars"] = res.get("extracted_vars", {})                # ç¡®ä¿extracted_varsæ˜¯å­—å…¸ç±»å‹                if default_result["extracted_vars"] is None:                    default_result["extracted_vars"] = {}                # æ³¨å…¥å˜é‡æ±                 await self.vars.add_vars(default_result["extracted_vars"])                await self.starter.send(f"âœ… åç½®SQLæå–ç»“æœ: extracted_vars={default_result['extracted_vars']}")            return default_result        except Exception as e:            log.error(f"æ‰§è¡Œåç½®SQLå¤±è´¥: {str(e)}")            await self.starter.send(f"âŒ åç½®SQLæ‰§è¡Œå¤±è´¥: {str(e)}")            return default_result    async def __exec_assert(self, interface: InterfaceModel):        """å“åº”æ–­è¨€"""        _assert = ExecAsserts(self.response, self.vars())        asserts_info = await _assert(interface.asserts)        await self.starter.send(f"ğŸ«³ğŸ«³    å“åº”æ–­è¨€ = {json.dumps(asserts_info, ensure_ascii=False)}")        return asserts_info    async def __exec_extract(self, interface: InterfaceModel):        """å˜é‡æå–"""        if interface.extracts and self.response.status_code == InterfaceResponseStatusCodeEnum.SUCCESS:            _extract = ExecResponseExtract(response=self.response)            _vars = await _extract(interface.extracts)            await self.starter.send(f"ğŸ«³ğŸ«³  å“åº”å‚æ•°æå– = {json.dumps(_vars, ensure_ascii=False)}")            await self.vars.add_vars(_vars)            return _vars        return []    async def __init_interface_case_vars(self, interfaceCase: InterfaceCase):        """åˆå§‹åŒ–ç”¨ä¾‹å˜é‡ï¼ˆç»“åˆä¸¤ä¸ªç‰ˆæœ¬çš„ä¼˜ç‚¹ï¼‰"""        try:            interfaceCaseVars: List[InterfaceVariables] = await InterfaceVarsMapper.query_by(case_id=interfaceCase.id)            if interfaceCaseVars:                for var in interfaceCaseVars:                    if var.value.startswith("{{$"):                        _v = var.value[3:-2]                        # ä½¿ç”¨fakerå¤„ç†åŠ¨æ€å˜é‡                        await self.vars.add_var(var.key, self.faker.value(_v))                    else:                        # ä½¿ç”¨å˜é‡è½¬æ¢å¤„ç†é™æ€å˜é‡                        _v = await self.vars.trans(var.value)                        await self.vars.add_var(var.key, _v)            if self.vars():                await self.starter.send(f"ğŸ«³ğŸ«³ åˆå§‹åŒ–ç”¨ä¾‹å˜é‡ = {json.dumps(self.vars(), ensure_ascii=False)}")        except Exception as e:            log.error(e)    async def __init_interface_global_vars(self):        """åˆå§‹åŒ–å…¨å±€å˜é‡ï¼ˆä¿ç•™è€ç‰ˆæœ¬åŠŸèƒ½ï¼‰"""        try:            g_vars = await GlobalVariableMapper.query_all()            if g_vars:                for g_var in g_vars:                    await self.vars.add_var(g_var.key, g_var.value)        except Exception as e:            log.warning(f"åˆå§‹åŒ–å…¨å±€å˜é‡å¤±è´¥: {e}")