#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/7/3# @Author : cyq# @File : httpxClient# @Software: PyCharm# @Desc:from typing import Optional, Callable, Dict, Listimport httpxfrom httpx import Response, Timeout, ReadTimeout, ConnectTimeout, ConnectError, AsyncClient, HTTPStatusError, Request, \    UnsupportedProtocolfrom enums import InterfaceResponseErrorMsgEnumfrom utils import MyLoguru, logLOG = MyLoguru().get_logger()class HttpxClient:    DEFAULT_HEADERS = {"user-agent": "case_Hub_http/v0.1"}    def __init__(            self,            logger: Optional[Callable] = None,            hooks: Optional[Dict[str, List[Callable]]] = None,            default_timeout: Optional[Timeout] = None,            **client_kwargs    ):        """        åˆå§‹åŒ–HTTPå®¢æˆ·ç«¯        :param logger: è‡ªå®šä¹‰æ—¥å¿—è®°å½•å™¨        :param hooks: è‡ªå®šä¹‰äº‹ä»¶é’©å­        :param default_timeout: é»˜è®¤è¶…æ—¶è®¾ç½®        :param client_kwargs: å…¶ä»–httpx.AsyncClientå‚æ•°        """        self.logger = logger        self._client = None  # å»¶è¿Ÿåˆå§‹åŒ–        # åˆå¹¶é»˜è®¤é’©å­å’Œè‡ªå®šä¹‰é’©å­        self._hooks = {            'request': [self.log_request],            'response': [self.log_response]        }        if hooks:            for event, event_hooks in hooks.items():                self._hooks.setdefault(event, []).extend(event_hooks)        # å®¢æˆ·ç«¯é…ç½®        self._client_config = {            "headers": self.DEFAULT_HEADERS,            "event_hooks": self._hooks,            **client_kwargs        }    @property    def client(self) -> AsyncClient:        """å»¶è¿Ÿåˆå§‹åŒ–å®¢æˆ·ç«¯"""        if self._client is None:            self._client = AsyncClient(**self._client_config)        return self._client    async def __call__(            self,            method: str,            url: str,            **kwargs    ) -> Response:        """        å‘èµ·HTTPè¯·æ±‚        :param method: HTTPæ–¹æ³• (GET, POSTç­‰)        :param url: è¯·æ±‚URL        :param kwargs: å…¶ä»–httpxè¯·æ±‚å‚æ•°        :return: å“åº”å¯¹è±¡        """        # è®¾ç½®é»˜è®¤è¶…æ—¶æ—¶é—´        self.client.timeout = Timeout(            None,            connect=kwargs.pop("connect", 10),            read=kwargs.pop("read", 10)        )        return await self._request(            method=method.lower(),            url=url,            **kwargs        )    async def _request(            self,            method: str,            url: str,            **kwargs    ) -> Response:        """        æ‰§è¡ŒHTTPè¯·æ±‚å¹¶å¤„ç†å“åº”        :param method: HTTPæ–¹æ³•        :param url: è¯·æ±‚URL        :param kwargs: å…¶ä»–httpxè¯·æ±‚å‚æ•°        :return: å“åº”å¯¹è±¡        :raises: å„ç§HTTPè¯·æ±‚å¼‚å¸¸        """        try:            response = await self.client.request(method, url, **kwargs)            # await self._validate_response(response)            return response        except UnsupportedProtocol:            raise UnsupportedProtocol(InterfaceResponseErrorMsgEnum.UnsupportedProtocol)        except ReadTimeout:            raise ReadTimeout(InterfaceResponseErrorMsgEnum.ResponseTimeout)        except ConnectTimeout:            raise ConnectTimeout(InterfaceResponseErrorMsgEnum.ConnectTimeout)        except ConnectError:            raise ConnectError(InterfaceResponseErrorMsgEnum.ConnectFailed)        except Exception as e:            LOG.exception(f"Request failed: {str(e)}")            raise    async def _validate_response(self, response: Response) -> None:        """        éªŒè¯å“åº”çŠ¶æ€ç         :param response: å“åº”å¯¹è±¡        :raises: å¦‚æœå“åº”çŠ¶æ€ç é2xxåˆ™æŠ›å‡ºå¼‚å¸¸        """        if not 200 <= response.status_code < 300:            error_msg = (                f"Request failed with status {response.status_code}. "                f"Response: {response.text[:500]}..."  # é™åˆ¶æ—¥å¿—é•¿åº¦            )            LOG.error(error_msg)            raise HTTPStatusError(error_msg)    async def log_request(self, request: Request) -> None:        """è®°å½•è¯·æ±‚æ—¥å¿—"""        log_msg = f"ğŸš€ğŸš€  Request {request.method.upper()}: {request.url}"        if self.logger:            await self.logger(log_msg)        LOG.info(log_msg)    async def log_response(self, response: Response) -> None:        """è®°å½•å“åº”æ—¥å¿—"""        log_msg = f"ğŸš€ğŸš€  Response {response.status_code} for  {response.request.url}"        if self.logger:            await self.logger(log_msg)        LOG.info(log_msg)    async def close(self) -> None:        """å…³é—­å®¢æˆ·ç«¯"""        if self._client is not None:            await self._client.aclose()            self._client = None    async def __aenter__(self):        """æ”¯æŒå¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨"""        return self    async def __aexit__(self, exc_type, exc_val, exc_tb):        """é€€å‡ºä¸Šä¸‹æ–‡æ—¶è‡ªåŠ¨å…³é—­"""        await self.close()