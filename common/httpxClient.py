#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/7/3# @Author : cyq# @File : httpxClient# @Software: PyCharm# @Desc:from typing import Optional, Callable, Dict, Listimport httpxfrom httpx import Response, Timeout, ReadTimeout, ConnectTimeout, ConnectError, AsyncClient, HTTPStatusError, Requestfrom enums import InterfaceResponseErrorMsgEnumfrom utils import MyLoguru, logLOG = MyLoguru().get_logger()class HttpxClient:    DEFAULT_HEADERS = {"user-agent": "case_Hub_http/v0.1"}    def __init__(            self,            logger: Optional[Callable] = None,            hooks: Optional[Dict[str, List[Callable]]] = None,            default_timeout: Optional[Timeout] = None,            **client_kwargs    ):        """        初始化HTTP客户端        :param logger: 自定义日志记录器        :param hooks: 自定义事件钩子        :param default_timeout: 默认超时设置        :param client_kwargs: 其他httpx.AsyncClient参数        """        self.logger = logger        self._client = None  # 延迟初始化        # 合并默认钩子和自定义钩子        self._hooks = {            'request': [self.log_request],            'response': [self.log_response]        }        if hooks:            for event, event_hooks in hooks.items():                self._hooks.setdefault(event, []).extend(event_hooks)        # 客户端配置        self._client_config = {            "headers": self.DEFAULT_HEADERS,            "event_hooks": self._hooks,            **client_kwargs        }    @property    def client(self) -> AsyncClient:        """延迟初始化客户端"""        if self._client is None:            self._client = AsyncClient(**self._client_config)        return self._client    async def __call__(            self,            method: str,            url: str,            **kwargs    ) -> Response:        """        发起HTTP请求        :param method: HTTP方法 (GET, POST等)        :param url: 请求URL        :param kwargs: 其他httpx请求参数        :return: 响应对象        """        # 设置默认超时时间        self.client.timeout = Timeout(            None,            connect=kwargs.pop("connect", 10),            read=kwargs.pop("read", 10)        )        return await self._request(            method=method.lower(),            url=url,            **kwargs        )    async def _request(            self,            method: str,            url: str,            **kwargs    ) -> Response:        """        执行HTTP请求并处理响应        :param method: HTTP方法        :param url: 请求URL        :param kwargs: 其他httpx请求参数        :return: 响应对象        :raises: 各种HTTP请求异常        """        try:            response = await self.client.request(method, url, **kwargs)            # await self._validate_response(response)            return response        except ReadTimeout:            raise ReadTimeout(InterfaceResponseErrorMsgEnum.ResponseTimeout)        except ConnectTimeout:            raise ConnectTimeout(InterfaceResponseErrorMsgEnum.ConnectTimeout)        except ConnectError:            raise ConnectError(InterfaceResponseErrorMsgEnum.ConnectFailed)        except Exception as e:            LOG.exception(f"Request failed: {str(e)}")            raise    async def _validate_response(self, response: Response) -> None:        """        验证响应状态码        :param response: 响应对象        :raises: 如果响应状态码非2xx则抛出异常        """        if not 200 <= response.status_code < 300:            error_msg = (                f"Request failed with status {response.status_code}. "                f"Response: {response.text[:500]}..."  # 限制日志长度            )            LOG.error(error_msg)            raise HTTPStatusError(error_msg)    async def log_request(self, request: Request) -> None:        """记录请求日志"""        log_msg = f"Request {request.method.upper()}: {request.url}"        if self.logger:            await self.logger(log_msg)        LOG.info(log_msg)    async def log_response(self, response: Response) -> None:        """记录响应日志"""        log_msg = f"Response {response.status_code} for {response.request.method} {response.request.url}"        if self.logger:            await self.logger(log_msg)        LOG.info(log_msg)    async def close(self) -> None:        """关闭客户端"""        if self._client is not None:            await self._client.aclose()            self._client = None    async def __aenter__(self):        """支持异步上下文管理器"""        return self    async def __aexit__(self, exc_type, exc_val, exc_tb):        """退出上下文时自动关闭"""        await self.close()