#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2024/7/3# @Author : cyq# @File : httpxClient# @Software: PyCharm# @Desc:import httpxfrom httpx import Response, Timeout, ReadTimeout, ConnectTimeout, HTTPStatusError, ConnectErrorfrom enums import InterfaceResponseErrorMsgEnumfrom utils import MyLoguru, GenerateTools, logLOG = MyLoguru().get_logger()class HttpxClient:    t: str    def __init__(self,                 log=None,                 hooks: dict = None,                 **kwargs):        default_event_hooks = {'request': [self.log_request],                               'response': [self.log_response]}        self.log = log if log else LOG.info        self.client = httpx.AsyncClient(            headers={"user-agent": "case_Hub_http/v0.1"}        )        self.client.event_hooks = hooks or default_event_hooks    async def __call__(self,                       method: str,                       url: str,                       **kwargs):        """        :param method: HTTP 方法        :param url: 请求的 URL        :param kwargs: 其他参数        :return: 请求的结果        """        # 设置默认超时时间        self.client.timeout = Timeout(            None,            connect=kwargs.pop("connect", 10),            read=kwargs.pop("read", 10)        )        return await self.invoke(method=method.lower(),                                 url=url,                                 **kwargs)    async def invoke(self, method, url, **kwargs) -> Response:        """        异步调用HTTP方法。        该方法通过反射从client对象上调用由`method`参数指定的HTTP方法，        并传递`url`和额外的关键字参数`kwargs`给该方法。它旨在为HTTP请求        提供一个灵活的接口，支持不同的HTTP方法和请求参数。        参数:        - method: 要调用的HTTP方法名，如 'get'、 'post'等。        - url: 请求的URL地址。        - **kwargs: 额外的关键字参数，将传递给HTTP方法。        返回:        - Response: HTTP请求的响应对象。        异常:        - ReadTimeout: 如果读取响应时发生超时，将引发`ReadTimeout`异常。        - ConnectTimeout: 如果连接时发生超时，将引发`ReadTimeout`异常。        - Exception: 如果发生其他异常，将原样抛出。        """        self.t = GenerateTools.getTime(1)        try:            response = await getattr(self.client, method)(                url,                **kwargs            )            # 非200 响应抛出异常            log.info(f"response [{response}")            # response.raise_for_status()            return response        except ReadTimeout:            raise ReadTimeout(InterfaceResponseErrorMsgEnum.ResponseTimeout)        except ConnectTimeout:            raise ConnectTimeout(InterfaceResponseErrorMsgEnum.ConnectTimeout)        except ConnectError as e:            raise ConnectTimeout(InterfaceResponseErrorMsgEnum.ConnectFailed)        except Exception as e:            raise e    async def log_request(self, request) -> None:        await self.log(f"Request {request.method.upper()} : [\"{request.url}\"]")    async def log_response(self, response: Response) -> None:        await self.log(f"Response status_code >> {response.status_code}")