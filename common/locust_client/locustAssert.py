#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/6/10# @Author : cyq# @File : locustAssert# @Software: PyCharm# @Desc:from json import JSONDecodeErrorfrom typing import List, Mapping, Anyimport refrom jmespath.exceptions import LexerErrorfrom locust.clients import ResponseContextManagerfrom app.schema.interface import IAssertfrom enums.CaseEnum import AssertTargetEnum, ExtraEnumfrom utils import log, JsonExtractfrom utils.assertsUtil import MyAssertsclass LocustAssert:    def __init__(self, response: ResponseContextManager):        self.response = response    def handle_assert(self, assert_info: List[IAssert]):        for assert_item in assert_info:            if assert_item.assert_switch is False:                continue            self.invoke(assert_item)    def invoke(self, assert_info: IAssert):        match assert_info.assert_target:            case AssertTargetEnum.StatusCode:  # 状态码断言                return self.assert_status_code(assert_info)            case AssertTargetEnum.ResponseText:  # 文本断言                return self.assert_response_text(assert_info)            case AssertTargetEnum.ResponseBody:  # body断言                return self.assert_response_json(assert_info)            case AssertTargetEnum.ResponseHeader:  # header断言                return self.assert_response_header(assert_info)    def assert_status_code(self, assertInfo: IAssert):        """        响应吗 断言        """        return self.__assert(assertInfo.assert_opt, assertInfo.assert_value, self.response.status_code)    def assert_response_text(self, assertInfo: IAssert):        """        响应 文本断言        assertInfo 只支持re 正则        """        if assertInfo.assert_extract != ExtraEnum.RE or not assertInfo.assert_text:            return        target = self.response.text        match = re.search(assertInfo.assert_text, target)        actual = match.group(1) if match else None        return self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)    def assert_response_json(self, assertInfo: IAssert):        """        响应 Json断言        assertInfo jsonpath jmespath        """        if assertInfo.assert_extract not in [ExtraEnum.JMESPATH, ExtraEnum.JSONPATH] or not assertInfo.assert_text:            log.error(f"assert_response_json {assertInfo.assert_extract} 不能对响应Json进行断言 或 断言语法为空！")            return        try:            target = self.response.json()            actual = self.__json_extract(target, assertInfo.assert_text, assertInfo.assert_extract)            return self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)        except Exception as e:            log.error(e)    def assert_response_header(self, assertInfo: IAssert):        """        响应 Header断言        参数提取只支持 jsonpath jmespath        """        if assertInfo.assert_extract not in [ExtraEnum.JMESPATH, ExtraEnum.JSONPATH] or not assertInfo.assert_text:            log.error(f"assert_response_header {assertInfo.assert_extract} 不能对响应。Json进行断言 或 断言语法为空！")            return        try:            target = dict(self.response.headers)            log.info(f"assert_response_header= {target}")            actual = self.__json_extract(target, assertInfo.assert_text, assertInfo.assert_extract)            self.__assert(assertInfo.assert_opt, assertInfo.assert_value, actual)        except JSONDecodeError:            log.warning(f"响应 {self.response.text} 非JSON 、无法提取")    def __assert(self, assert_opt: str, expect: Any, actual: Any):        try:            MyAsserts.option(assert_opt, expect, actual)            self.response.success()        except AssertionError as e:            self.response.failure(e)    @staticmethod    def __json_extract(target: Any, assert_text: str, assert_extract: str):        actual = None        jp = JsonExtract(target, assert_text)        match assert_extract:            case ExtraEnum.JSONPATH:                try:                    actual = jp.value()                except JSONDecodeError:                    log.warning(f"JSONPATH 提取失败")            case ExtraEnum.JMESPATH:                try:                    actual = jp.search()                except LexerError as e:                    log.warning(f"JMESPATH 提取失败")        return actual