#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/7/18# @Author : cyq# @File : variableTrans# @Software: PyCharm# @Desc: 增强版变量转换器import asyncioimport iofrom typing import Any, Dict, List, Tuple, TypeVarfrom app.mapper.project import GlobalVariableMapperfrom common.fakerClient import FakerClientfrom functools import singledispatchmethodimport refrom utils import GenerateTools, logVARS = TypeVar("VARS", bound=Dict[str, Any] | List[Dict[str, Any]])class VariableTrans:    def __init__(self):        self._vars: Dict[str, Any] = {}        self._faker = FakerClient()        # 采用健壮的正则策略        self._strict_pattern = re.compile(r"\{\{\s*([a-zA-Z_$][\w$]*)\s*\}\}")        self._loose_pattern = re.compile(r"{{(.*?)}}")        self._full_vars_pattern = re.compile(r"^{{(.*?)}}$")    def __call__(self) -> Dict[str, Any]:        return self._vars.copy()    async def clear(self):        self._vars.clear()    async def add_vars(self, data: VARS) -> None:        if isinstance(data, dict):            self._vars.update(**data)        elif isinstance(data, list):            data = GenerateTools.list2dict(data)            self._vars.update(**data)        else:            raise TypeError(f"Unsupported type: {type(data)}")    async def add_var(self, key: str, value: Any):        if not isinstance(key, str):            raise TypeError("Key must be a string")        self._vars[key] = value    @singledispatchmethod    async def trans(self, target: Any) -> Any:        """类型分发的主入口"""        if hasattr(target, 'read') and callable(target.read):            return target        if hasattr(target, '__iter__') and not isinstance(target, (str, bytes, dict, list, tuple)):            try:                return [await self.trans(item) for item in target]            except TypeError:                return target        return target    @trans.register(str)    async def _(self, target: str) -> str:        """处理字符串：采用健壮的替换策略"""        if not target:            return target        # 1. 优先处理完整的Faker变量占位符        if target.startswith("{{$") and target.endswith("}}"):            faker_key = target[3:-2].strip()            return self._faker.value(faker_key)        # 2. 检查是否为完整的变量占位符        full_match = self._full_vars_pattern.match(target)        if full_match:            var_name = full_match.group(1)            return await self._resolve_variable(var_name)        # 3. 采用健壮的替换策略        return await self._transform_str_robust(target)    @trans.register(dict)    async def _(self, target: Dict[str, Any]) -> Dict[str, Any]:        """处理字典"""        if not target:            return {}        keys = list(target.keys())        values = await asyncio.gather(*[self.trans(v) for v in target.values()])        return dict(zip(keys, values))    @trans.register(list)    async def _(self, target: List[Any]) -> List[Any]:        """处理列表"""        return await asyncio.gather(*[self.trans(item) for item in target])    @trans.register(tuple)    async def _(self, target: Tuple[Any, ...]) -> Tuple[Any, ...]:        """处理元组：保留文件对象处理逻辑"""        transformed_items = []        for item in target:            if isinstance(item, io.BufferedReader):                transformed_items.append(item)                continue            transformed = await self.trans(item)            transformed_items.append(transformed)        return tuple(transformed_items)    @trans.register(int)    @trans.register(float)    @trans.register(bool)    async def _(self, target: Any) -> Any:        """数值和布尔类型直接返回"""        return target    async def _transform_str_robust(self, target: str) -> str:        """核心替换逻辑：严格模式 + 宽松模式"""        # 先尝试严格模式        strict_replaced, was_replaced = await self._replace_with_pattern(            self._strict_pattern, target        )        # 如果严格模式没有进行任何替换，使用宽松模式兜底        if not was_replaced:            strict_replaced, _ = await self._replace_with_pattern(                self._loose_pattern, target            )        return strict_replaced    async def _replace_with_pattern(self, pattern: re.Pattern, target: str) -> Tuple[str, bool]:        """使用指定模式进行替换"""        parts = []        last_index = 0        replaced = False        for match in pattern.finditer(target):            replaced = True            parts.append(target[last_index:match.start()])            var_name = match.group(1).strip()            var_value = await self._resolve_variable(var_name)            parts.append(str(var_value))            last_index = match.end()        parts.append(target[last_index:])        return "".join(parts), replaced    async def _resolve_variable(self, var_name: str) -> Any:        """解析变量名"""        var_name = var_name.strip()        # 1. Faker 变量        if var_name.startswith("$"):            faker_key = var_name[1:]            try:                return self._faker.value(faker_key)            except Exception as e:                log.warning(f"Faker变量生成失败 '{var_name}': {e}")                return f"{{{{{var_name}}}"  # 返回原占位符        # 2. 全局变量        elif var_name.startswith("g_"):            global_val = await self._get_global_variable(var_name[2:])            if global_val is not None:                return global_val            else:                log.warning(f"全局变量未找到: '{var_name}'")                return f"{{{{{var_name}}}"  # 返回原占位符        # 3. 普通变量        elif var_name in self._vars:            return self._vars[var_name]        # 4. 变量未找到        else:            log.warning(f"变量未在池中找到: '{var_name}'")            return f"{{{{{var_name}}}"  # 返回原占位符    @staticmethod    async def _get_global_variable(key: str) -> Any:        """从数据库获取全局变量"""        try:            g_var = await GlobalVariableMapper.fetch_by_key(key)            return g_var.value if g_var else None        except Exception as e:            log.error(f"查询全局变量 '{key}' 时出错: {e}")            return None