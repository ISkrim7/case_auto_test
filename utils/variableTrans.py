#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/7/18# @Author : cyq# @File : variableTrans# @Software: PyCharm# @Desc:import asyncioimport iofrom typing import Any, Dict, List, Tuple, TypeVarfrom app.mapper.project import GlobalVariableMapperfrom common.fakerClient import FakerClientfrom functools import singledispatchmethodimport refrom utils import GenerateTools, logVARS = TypeVar("VARS", bound=Dict[str, Any] | List[Dict[str, Any]])MAX_LENGTH = 5class VariableTrans:    """    变量转换类    vars = {name:cyq,age:123,...}    {{name}} => cyq    {{g_data} => global table data    {{f_name}} => faker.name() func    {{timestamp}} => FakerClient.timestamp func    """    def __init__(self):        self._var = {}        self._faker = FakerClient()        self._var_pattern = re.compile(r"{{(.*?)}}")        self._full_var_pattern = re.compile(r"^{{(.*?)}}$")    def __call__(self, *args, **kwargs):        return self._var    async def clear(self):        self._var.clear()    async def add_vars(self, data: VARS):        if isinstance(data, dict):            self._var.update(**data)        elif isinstance(data, list):            data = GenerateTools.list2dict(data)            self._var.update(**data)    async def add_var(self, key: str, value: Any):        self._var.update(**{key: value})    @singledispatchmethod    async def trans(self, target: Any) -> Any:        """        类型分发        """        return target    @trans.register(str)    async def _(self, target: str) -> str:        """处理字符类型转换"""        if full_match := self._full_var_pattern.match(target):            return await self._resolve_var(full_match.group(1))        return await self._transform_str_with_vars(target)    @trans.register(dict)    async def _(self, target: Dict[str, Any]) -> Dict[str, Any]:        """处理字典类型的转换"""        keys, values = zip(*target.items())        if len(values) <= MAX_LENGTH:            transformed_values = [await self.trans(v) for v in values]        else:            transformed_values = await asyncio.gather(*[self.trans(v) for v in values])        return dict(zip(keys, transformed_values))    @trans.register(list)    async def _(self, target: List[Any]) -> List[Any]:        """处理列表类型的转换"""        if len(target) <= MAX_LENGTH:            transformed_items = [await self.trans(item) for item in target]        else:            transformed_items = await asyncio.gather(*[self.trans(item) for item in target])        return transformed_items    @trans.register(tuple)    async def _(self, target: Tuple[Any, ...]) -> Tuple[Any, ...]:        """处理元组类型的转换"""        transformed_items = []        for item in target:            # 兼容下 http 请求体中的文件上传            if isinstance(item, io.BufferedReader):                transformed_items.append(item)                continue            transformed = await self.trans(item)            transformed_items.append(transformed)        return tuple(transformed_items)    async def _resolve_var(self, var_name: str) -> Any:        """        解析变量名        :param var_name: 变量名        :return: 变量值或原始字符串        """        var_name = var_name.strip()        if var_name.startswith("$f_"):            # 处理 Faker 生成的 内置变量            return self._faker.value(var_name[1:])        elif var_name.startswith("$g_"):            # 处理全局变量            return await self.__find_g_var(var_name[1:])        # 常规变量        return self._var.get(var_name, f"{var_name}")    async def _transform_str_with_vars(self, target: str) -> str:        """        处理包含变量插值的字符串        :param target: 原始字符串        :return: 替换后的字符串        """        # 处理字符串中的变量插值        parts = []        last_end = 0        for match in self._var_pattern.finditer(target):            # 添加非变量部分            parts.append(target[last_end:match.start()])            # 解析变量部分            var_value = await self._resolve_var(match.group(1))            parts.append(str(var_value))            last_end = match.end()        # 添加剩余部分        parts.append(target[last_end:])        return "".join(parts)    @staticmethod    async def __find_g_var(script: str) -> Any:        log.info(f"g var = {script}")        script = script.split("g_")[-1]        g_var = await GlobalVariableMapper.fetch_by_key(script)        if g_var:            return g_var.value