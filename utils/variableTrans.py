#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/7/18# @Author : cyq# @File : variableTrans# @Software: PyCharm# @Desc:import asyncioimport iofrom typing import Any, Dict, List, Tuple, TypeVarfrom app.mapper.project import GlobalVariableMapperfrom common.fakerClient import FakerClientfrom functools import singledispatchmethodimport refrom utils import GenerateTools, logVARS = TypeVar("VARS", bound=Dict[str, Any] | List[Dict[str, Any]])# 定义一个默认长度，大于5的变量，使用并行处理MAX_LENGTH = 5class VariableTrans:    """    变量转换类    vars = {name:cyq,age:123,...}    {{name}} => cyq    {{g_data} => global table data    {{f_name}} => faker.name() func    {{timestamp}} => FakerClient.timestamp func    """    def __init__(self):        self._vars: Dict[str, Any] = {}        self._faker = FakerClient()        self._vars_pattern = re.compile(r"{{(.*?)}}")        self._full_vars_pattern = re.compile(r"^{{(.*?)}}$")    def __call__(self) -> Dict[str, Any]:        return self._vars.copy()    async def clear(self):        self._vars.clear()    async def add_vars(self, data: VARS) -> None:        """        添加多个变量        """        if isinstance(data, dict):            self._vars.update(**data)        elif isinstance(data, list):            data = GenerateTools.list2dict(data)            self._vars.update(**data)        else:            raise TypeError(f"Unsupported type: {type(data)}")    async def add_var(self, key: str, value: Any):        """        添加单变量        """        if not isinstance(key, str):            raise TypeError("Key must be a string")        self._vars.update(**{key: value})    @singledispatchmethod    async def trans(self, target: Any) -> Any:        """        类型分发        """        return target    @trans.register(str)    async def _(self, target: str) -> str:        """处理字符类型转换"""        if not target:            return target        if full_match := self._full_vars_pattern.match(target):            return await self._resolve_vars(full_match.group(1))        return await self._transform_str_with_vars(target)    @trans.register(dict)    async def _(self, target: Dict[str, Any]) -> Dict[str, Any]:        """        处理字典类型的转换        """        if not target:            return {}        keys, values = zip(*target.items())        if len(values) <= MAX_LENGTH:            transformed_values = [await self.trans(v) for v in values]        else:            # async with asyncio.TaskGroup() as tg:            #     transformed_values = [tg.create_task(self.trans(v)) for v in values]            transformed_values = await asyncio.gather(*[self.trans(v) for v in values])        return dict(zip(keys, transformed_values))    @trans.register(list)    async def _(self, target: List[Any]) -> List[Any]:        """处理列表类型的转换"""        if len(target) <= MAX_LENGTH:            transformed_items = [await self.trans(item) for item in target]        else:            # async with asyncio.TaskGroup() as tg:            #     transformed_items = [tg.create_task(self.trans(item)) for item in target]            transformed_items = await asyncio.gather(*[self.trans(item) for item in target])        return transformed_items    @trans.register(tuple)    async def _(self, target: Tuple[Any, ...]) -> Tuple[Any, ...]:        """处理元组类型的转换"""        transformed_items = []        for item in target:            # 兼容下 http 请求体中的文件上传            if isinstance(item, io.BufferedReader):                transformed_items.append(item)                continue            transformed = await self.trans(item)            transformed_items.append(transformed)        return tuple(transformed_items)    async def _resolve_vars(self, var_name: str) -> Any:        """        解析变量名        :param var_name: 变量名        :return: 变量值或原始字符串        """        var_name = var_name.strip()        if var_name.startswith("$f_"):            # 处理 Faker 生成的 内置变量            return self._faker.value(var_name[1:])        elif var_name.startswith("$g_"):            # 处理全局变量            return await self.__find_g_vars(var_name[1:])        # 常规变量        return self._vars.get(var_name, f"{var_name}")    async def _transform_str_with_vars(self, target: str) -> str:        """        处理包含变量插值的字符串        :param target: 原始字符串        :return: 替换后的字符串        """        # 处理字符串中的变量插值        parts = []        last_end = 0        for match in self._vars_pattern.finditer(target):            # 添加非变量部分            parts.append(target[last_end:match.start()])            # 解析变量部分            var_value = await self._resolve_vars(match.group(1))            parts.append(str(var_value))            last_end = match.end()        # 添加剩余部分        parts.append(target[last_end:])        return "".join(parts)    @staticmethod    async def __find_g_vars(script: str) -> Any:        log.info(f"g var = {script}")        script = script.split("g_")[-1]        g_vars = await GlobalVariableMapper.fetch_by_key(script)        if g_vars:            return g_vars.value