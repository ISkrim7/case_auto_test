#!/usr/bin/env python# -*- coding:utf-8 -*-# @Time : 2025/2/17# @Author : cyq# @File : execSql# @Software: PyCharm# @Desc:from typing import List, Dictfrom common import RedisClientfrom enums import BeforeSqlDBTypeEnumfrom interface.starter import APIStarterfrom common.mysqlClient import MySqlClientfrom play.starter import UIStarterfrom utils import log, JsonExtractimport refrom common.oracleClient import OracleClientfrom sqlparse import parse, tokensfrom sqlparse.sql import Identifier, Comparison, ParenthesisSELECT_KEYWORDS = ("select", "SELECT")class ExecDBScript:    def __init__(self, io: APIStarter | UIStarter, script_str: str,                 extracts: List[Dict[str, str]] = None,                 onlySearch: bool = False):        self._io = io        self._script = re.sub(r'\s+', ' ', script_str).strip(";")        self._extract = extracts        self._onlySearch = onlySearch        self.mysql_client = MySqlClient()        self.redis_client = RedisClient()        self.oracle_client = OracleClient()    async def invoke(self, db_type: int, **config) -> dict[str, any] | None:        """        执行        """        match db_type:            case BeforeSqlDBTypeEnum.MYSQL:                res = await self._exec_sql(**config)            case BeforeSqlDBTypeEnum.REDIS:                res = await self._exec_redis(**config)            case BeforeSqlDBTypeEnum.ORACLE:                res = await self._exec_oracle(**config)            case _:                log.warning(f"不支持的数据库类型 {db_type}")                return        return res    async def _exec_sql(self, **kwargs):        """执行sql"""        result = {}        try:            await self.mysql_client.create_pool(**kwargs)            # 如果是查询            if self._script.startswith(SELECT_KEYWORDS):                keys = await self.__get_keys()                try:                    search_data = await self.mysql_client.fetch_all(self._script)                    # 新增：转换datetime对象为字符串                    from datetime import datetime                    def convert_datetime(obj):                        if isinstance(obj, datetime):                            return obj.isoformat()                        return obj                    processed_data = []                    for row in search_data:                        processed_row = {k: convert_datetime(v) for k, v in row.items()}                        processed_data.append(processed_row)                    log.info(f"Get Search Data {search_data}")                    # 调试？                    if self._onlySearch:                        #return search_data                        return {                       # 返回结构化数据                            #"raw_data": search_data,    # 原始查询结果                            #"extracted_vars": None      # 调试模式不需要变量提取                            "raw_data": processed_data,  # 转换后的数据                            "extracted_vars": result                        }                    if not search_data:                        #return result                        return {"raw_data": processed_data, "extracted_vars": {}}                except Exception as e:                    log.info(f"Get Search Data  Err : {e}")                    #return None                    return {                        "raw_data": None,                        "extracted_vars": None,                        "error": str(e)                    }                # 正常执行流程                result = {}                first_data = search_data[0] if search_data else {}                keys = await self.__get_keys()                # 如果没有将keys 赋值查到的第一个数据返回                #first_data = search_data[0]                for key in keys:                    if first_data.get(key):                        result[key] = first_data.get(key)                # 如果有获取预期                if self._extract:                    log.debug(f"Get Extract {self._extract}")                    for item in self._extract:                        j = JsonExtract(search_data, item.get('jp'))                        value = await j.value()                        # result[item["key"]] = value  # 即使value为None也要记录                        # log.debug(f"Extracted {item['key']}={value} via {item['jp']}")                        # if value:                        #     result[item["key"]] = value                        # 关键修改：处理多值情况                        if isinstance(value, list):                            # 如果是列表，为每个元素创建索引变量                            for i, val in enumerate(value, start=1):                                key_name = f"{item['key']}_{i}"                                result[key_name] = val                                log.debug(f"Extracted {key_name}={val} via {item['jp']}")                        else:                            # 单值直接赋值                            result[item["key"]] = value                            log.debug(f"Extracted {item['key']}={value} via {item['jp']}")                #return result                return {                           # 返回结构化数据                    #"raw_data": search_data,        # 原始查询结果                    #"extracted_vars": result        # 提取的变量                    "raw_data": processed_data,  # 转换后的数据                    "extracted_vars": result                }            # 写操作            else:                #await self.mysql_client.execute(self._script)                #return None                try:                    # 执行SQL并获取影响行数                    rows_affected = await self.mysql_client.execute(self._script)                    # 返回结构化结果                    return {                        "raw_data": None,                        "extracted_vars": None,                        "execution_info": {                            "rows_affected": rows_affected,                            "status": "SUCCESS"                        }                    }                except Exception as e:                    log.exception(e)                    await self._io.send(f"Exec Sql Error: {e}")                    #return result                    return {                               # 异常时返回清晰结构                        "raw_data": None,                        "extracted_vars": None,                        "error": str(e)                    }        finally:            await self.mysql_client.close_pool()    async def _exec_redis(self, **kwargs):        result = {}        try:            await self.redis_client.set_pool(**kwargs)            value = await self.redis_client.execute_script(self._script)            await self._io.send(f"Exec Redis values: {value}")            if self._onlySearch:                return value            if self._extract:                for item in self._extract:                    j = JsonExtract(value, item.get('jp'))                    value = await j.value()                    if value:                        result[item["key"]] = value            return result        except Exception as e:            log.error(e)            await self._io.send(f"Exec Redis Error: {e}")            return result        finally:            await self.redis_client.close_pool()    async def _exec_oracle(self, **kwargs):        """执行 oracle sql"""        result = {}        try:            await self.oracle_client.connect(**kwargs)            if self._script.startswith(SELECT_KEYWORDS):                keys = await self.__get_keys()                log.debug(f"Oracle Get Keys {keys}")                try:                    log.debug(f"script {self._script}")                    search_data = await self.oracle_client.fetch_all(self._script)                    await self._io.send(f"Oracle Get Search Data {search_data}")                    if self._onlySearch:                        return search_data                    if not search_data:                        return result                except Exception as e:                    await self._io.send(f"Fetch Sql Error: {e}")                    return None                # 如果没有将keys 赋值查到的第一个数据返回                first_data = search_data[0]                log.debug(f"Oracle Get First Data {first_data}")                for key in keys:                    _key = key.upper()                    if first_data.get(_key):                        result[_key] = first_data.get(_key)                # 如果有获取预期                if self._extract:                    for item in self._extract:                        j = JsonExtract(search_data, item.get('jp'))                        value = await j.value()                        # if value:                        #     result[item["key"]] = value                        # 关键修改：处理多值情况                        if isinstance(value, list):                            # 如果是列表，为每个元素创建索引变量                            for i, val in enumerate(value, start=1):                                key_name = f"{item['key']}_{i}"                                result[key_name] = val                # return result                return {                    "raw_data": search_data,                    "extracted_vars": result                }            else:                await self.oracle_client.execute(self._script)                # return None                return {                    "execution_info": {                        "rows_affected": 1,  # Oracle写操作通常返回成功                        "status": "SUCCESS"                    }                }        except Exception as e:            log.error(e)            await self._io.send(f"Exec Oracle Error: {e}")            # return result            return {                "error": str(e)            }        finally:            await self.oracle_client.close()    async def __get_keys(self) -> List[str]:        """        # 提取 SELECT 和 FROM 之间的字段部分 作为key        select username,age from user keys = ['username','age']        select username as name,age as aaa from user keys = ['name'.'aaa']        select * from user keys = []        return keys        """        match = re.search(r'select\s+(.*?)\s+from', self._script, re.IGNORECASE)        if not match:            return []  # 如果未匹配到 SELECT 子句，返回空列表        params = [param.strip() for param in match.group(1).split(",")]        keys = [            _.strip().split(" as ")[1].strip() if " as " in _ else _.strip()            for _ in params        ]        return keys    @staticmethod    async def validate_single_row_operation(sql: str) -> bool:        stmt = parse(sql)[0]        # 禁止无 WHERE 的 DELETE/UPDATE        if not any(token.ttype == tokens.Keyword and token.value.upper() == "WHERE" for token in stmt.tokens):            return False        # 检查 WHERE 条件是否是单值匹配（如 id = 1）        where_clause = next(            token for token in stmt.tokens            if isinstance(token, Parenthesis) or            (hasattr(token, "ttype") and token.ttype == tokens.Keyword and token.value.upper() == "WHERE")        )        # 允许的条件形式：WHERE id = ? 或 WHERE user_id = ?        allowed_formats = ["=", "LIKE"]  # 允许的操作符        for token in where_clause.tokens:            if isinstance(token, Comparison):                # 检查是否是 "列 = 值" 格式                if token.get_operator() not in allowed_formats:                    return False        return True